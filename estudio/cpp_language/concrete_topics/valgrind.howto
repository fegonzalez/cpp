################################################################################

\info Testing the valgrind tool suite with C++

################################################################################

Index



# 4. Memcheck: a memory error detector
#
# 4.0 Valgrind quick start
#
#    2. Preparing your program
#    3. Running your program under Memcheck
#    4. Interpreting Memcheck's output
#
# 4.2. Explanation of error messages from Memcheck 
#   4.2.1. Illegal read / Illegal write errors
#   4.2.2. Use of uninitialised values
#   4.2.3. Use of uninitialised or unaddressable values in system calls
#   4.2.4. Illegal frees
#   4.2.5. When a heap block is freed with an inappropriate deallocation function
#   4.2.6. Overlapping source and destination blocks
#   4.2.7. Fishy argument values
#   4.2.8. Memory leak detection

# 5. Cachegrind: a cache and branch-prediction profiler

# 6. Callgrind: a call-graph generating cache and branch prediction profiler


# Appendix A - Useful valgrind options to C++

# Appendix K - Code examples (../code_examples)

# Appendix T - Defined Terms

# Appendix Z - References




################################################################################
# 4. Memcheck: a memory error detector
################################################################################

Memcheck is a memory error detector. It can detect the following
problems that are common in C and C++ programs.

- Accessing memory you shouldn't, e.g. overrunning and underrunning
  heap blocks, overrunning the top of the stack, and accessing memory
  after it has been freed.

- Using undefined values, i.e. values that have not been initialised,
  or that have been derived from other undefined values.

- Incorrect freeing of heap memory, such as double-freeing heap
  blocks, or mismatched use of malloc/new/new[] versus
  free/delete/delete[]

- Overlapping src and dst pointers in memcpy and related functions.

- Passing a fishy (presumably negative) value to the size parameter of
  a memory allocation function.

- Memory leaks.


#===============================================================================
# 4.0 Valgrind quick start (valgrind.org/docs/manual/quick-start.html)
#===============================================================================

# How to launch

  valgrind --tool=memcheck EXECUTABLE-NAME

or

  valgrind EXECUTABLE-NAME  # as memcheck is the default tool	


# 2. Preparing your program

a) Compiling with Debug info
   
   Compile your program with -g  (Makefile: DEBUG_FLAGS = -g)

b) compiling with Optimization

   Using -O0 is also a good idea (Makefile: OPTIM_FLAGS = -O0 # the default)


   WARNING
   If you are planning to use Memcheck: On rare occasions, compiler
   optimisations (at -O2 and above, and sometimes -O1) have been
   observed to generate code which fools Memcheck into wrongly
   reporting uninitialised value errors, or missing uninitialised
   value errors.  (valgrind manual, 2.2. Getting started)


   With -O1 line numbers in error messages can be inaccurate, although
   generally speaking running Memcheck on code compiled at -O1 works
   fairly well, and the speed improvement compared to running -O0 is
   quite significant.

   Use of -O2 and above is not recommended as Memcheck occasionally
   reports uninitialised-value errors which don't really exist.


# 3. Running your program under Memcheck

If you normally run your program like this:

>  myprog arg1 arg2

Use this command line:

>  valgrind --leak-check=yes myprog arg1 arg2

# Memcheck is the default tool.
# The --leak-check option turns on the detailed memory leak detector.


# 4. Interpreting Memcheck's output
 
[ Example

  #include <stdlib.h>

  void f(void)
  {
     int* x = malloc(10 * sizeof(int));
     x[10] = 0;        // problem 1: heap block overrun
  }                    // problem 2: memory leak -- x not freed

  int main(void)
  {
     f();
     return 0;
  }

end example ]


4.1 memory error

1) memory error messages look like this:

  ==19182== Invalid write of size 4
  ==19182==    at 0x804838F: f (example.c:6)
  ==19182==    by 0x80483AB: main (example.c:11)
  ==19182==  Address 0x1BA45050 is 0 bytes after a block of size 40 alloc'd
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (example.c:5)
  ==19182==    by 0x80483AB: main (example.c:11)
  ...


2) It's worth fixing errors in the order they are reported, as later
   errors can be caused by earlier errors. Failing to do this is a
   common cause of difficulty with Memcheck.


4.2 memory leak.

1) Memory leak messages look like this:

  ==19182== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (a.c:5)
  ==19182==    by 0x80483AB: main (a.c:11)

2) The stack trace tells you where the leaked memory was allocated, (x
   in this example). Memcheck cannot tell you why the memory leaked,
   unfortunately.

3) There are several kinds of leaks; the two most important categories are:

"definitely lost" your program is leaking memory -- fix it!

"probably lost": your program is leaking memory, unless you're doing
	  	 funny things with pointers (such as moving them to
	  	 point to the middle of a heap block).


4.3  uninitialised values

1) Memcheck also reports uses of uninitialised values, most commonly with
   the message "Conditional jump or move depends on uninitialised value(s)".

2) It can be difficult to determine the root cause of these
   errors. Try using the --track-origins=yes to get extra information.


5. Caveats

Memcheck is not perfect; it occasionally produces false positives, and
there are mechanisms for suppressing these (see Suppressing errors in
the Valgrind User Manual). However, it is typically right 99% of the time.


#===============================================================================
# 4.1. Overview
#===============================================================================

1)  Memory errors versus memory leaks [2_1]

    a) Memory errors: are a red alert, they can destroy your program.

    b) Memory leaks: are not an urgent situation.


2) Memory leaks

   --leak-check=full
   --show-leak-kinds=all

   Valgrind categorizes leaks using these terms:

   + definitely lost: heap-allocated memory that was never freed to
     which the program no longer has a pointer. Valgrind knows that
     you once had the pointer, but have since lost track of it. This
     memory is definitely orphaned.

   + indirectly lost: heap-allocated memory that was never freed to
     which the only pointers to it also are lost. For example, if you
     orphan a linked list, the first node would be definitely lost,
     the subsequent nodes would be indirectly lost.

   + possibly lost: heap-allocated memory that was never freed to
     which valgrind cannot be sure whether there is a pointer or not.

   + still reachable: heap-allocated memory that was never freed to
     which the program still has a pointer at exit (typically this
     means a global variable points to it).


   WARNING Check whether the memory leaks exists if the execution
      	   ends early due to a fatal error.


3) Using gdb and Valgrind together

One handy Valgrind trick is the ability to drop into the debugger as
soon as it encounters a memory error (not a leak). You do this by
specifying the db-attach option when starting valgrind:

      valgrind --db-attach=yes

As soon as it encounters a memory error, Valgrind will ask you if you
would like to start up the debugger:

      ==6459== ---- Attach to debugger? --- [Return/N/n/Y/y/C/c] ----

When you exit the debugger, you will return to valgrind.

WARNING (Sometimes gdb will ask if you would like to kill the running
	program to which you should answer "no")


#===============================================================================
# 4.2. Explanation of error messages from Memcheck 
#===============================================================================

1) \brief Most commone errors [2_1]

- Invalid read/write of size X

  The program was observed to read/write X bytes of memory that was
  invalid. Common causes include accessing beyond the end of a heap
  block, accessing memory that has been freed, or accessing into an
  unallocated region such as from use of a uninitialized pointer.

- Use of uninitialised value /
  Conditional jump or move depends on uninitialised value(s)

  The program read the value of a memory location that was not
  previously written to, i.e. uses random junk. The second more
  specifically indicates the read occurred in the test expression in
  an if/for/while.

  Tip: flag --track-origins=yes

- Source and destination overlap in memcpy()

  Tip: use memmove in the src. code instead

- Invalid free() The program attempted to free a non-heap address or
  free the same block more than once.


# 4.2.1. Illegal read / Illegal write errors
# 4.2.2. Use of uninitialised values
# 4.2.3. Use of uninitialised or unaddressable values in system calls
# 4.2.4. Illegal frees
# 4.2.5. When a heap block is freed with an inappropriate deallocation function
# 4.2.6. Overlapping source and destination blocks
# 4.2.7. Fishy argument values
# 4.2.8. Memory leak detection

See [1] for details



################################################################################
# 5. Cachegrind: a cache and branch-prediction profiler
################################################################################

5.1. Overview

1) Cachegrind simulates how your program interacts with a machine's
   cache hierarchy and (optionally) branch predictor.

2) Cache simulation [1]: Cachegrind always refers to the I1, D1 and LL
   (last-level) caches.

3) Cachegrind gathers the following statistics (abbreviations used for
   each statistic is given in parentheses):

   - I cache reads (Ir, which equals the number of instructions
     executed), I1 cache read misses (I1mr) and LL cache instruction
     read misses (ILmr).

   - D cache reads (Dr, which equals the number of memory reads), D1
     cache read misses (D1mr), and LL cache data read misses (DLmr).

   - D cache writes (Dw, which equals the number of memory writes), D1
     cache write misses (D1mw), and LL cache data write misses (DLmw).

   - Conditional branches executed (Bc) and conditional branches
     mispredicted (Bcm).

   - Indirect branches executed (Bi) and indirect branches mispredicted (Bim).

See [1] for details


################################################################################
# 6. Callgrind: a call-graph generating cache and branch prediction profiler
################################################################################

# 6.1. Overview

1) Callgrind is a profiling tool that records the call history among
   functions in a program's run as a call-graph:

   - number of instructions executed
   - their relationship to source lines
   - the caller/callee relationship between functions
   - and the numbers of such calls.
   - Optionally, cache simulation and/or branch prediction (similar to Cachegrind)


################################################################################
# Appendix A - Useful valgrind options to C++
################################################################################

# C++ compiler                # valgrind (alternative)

-g
-O0
-Wall

-fno-inline                    --read-inline-info=yes 


			       --leak-check=yes
			       --track-origins=yes
			       --undef-value-errors=yes


# ==============================================================================
# Appendix K - Code examples (../code_examples)
# ==============================================================================

# source path for boost test:  "../code_examples/valgrind/"

# Init (memcheck), "../code_examples/valgrind/quick_star_example"

# callgrind, "../code_examples/valgrind/callgrind"


################################################################################
# Appendix T - Defined Terms
################################################################################


P

- Profiling (computer programming)

  In software engineering, profiling ("program profiling", "software
  profiling") is a form of dynamic program analysis that measures, for
  example, the space (memory) or time complexity of a program, the
  usage of particular instructions, or the frequency and duration of
  function calls. Most commonly, profiling information serves to aid
  program optimization.
  (https://en.wikipedia.org/wiki/Profiling_(computer_programming)




################################################################################
# Appendix Z - References
################################################################################

[1] Official manual - http://valgrind.org/docs/manual/index.html


[2] memcheck-links

[2_1] Guide to memcheck - https://web.stanford.edu/class/cs107/guide_valgrind.html


[3] callgrind-links

[3_1] Guide to callgrind - https://web.stanford.edu/class/cs107/guide_callgrind.html

[3_2] How to profile C++ application with Callgrind / KCacheGrind - https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html


