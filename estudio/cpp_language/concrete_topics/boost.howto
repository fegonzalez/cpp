# ==============================================================================
# Summary
#
# (following the order in the c++ standard [1_1]; except chapter 14,
#  following [3_102])
# 
# ==============================================================================

# 1 Getting Started
#
# 1.1 The Boost Distribution
# 1.2 Header-Only Libraries
# 1.3 Build a Simple Program Using Boost
# 1.4 Prepare to Use a Boost Library Binary
# 1.5 Link Your Program to a Boost Library

# 2 Smart Pointer library
#
# 2.1 Sole Ownership (boost::scoped_ptr)
#     2.1.1 scoped_ptr FAQ
#
# 2.2 Shared Ownership (boost::shared_ptr)
#     2.2.1 user-defined deleter
#     2.2.2 Using boost::shared_array
#     2.2.3 Using boost::make_shared
#     2.2.4 boost::shared_ptr with BOOST_SP_USE_QUICK_ALLOCATOR
#
# 2.3 Special Smart Pointers
#     2.3.1 bosst::weak_ptr
#     2.3.2 boost::intrusive_ptr
#
# 2.4 Boost.PointerContainer
#     2.4.2 boost::ptr_vector
#     2.4.2 boost::ptr_set
#     2.4.3 Inserters for boost containers

# 3 Test library
#
# 3.1 Introduction to testing with Boost
#     3.1.1 A simple example
#     3.1.2 Generic usage recommendations
#
# 3.2 Usage Variants
#     3.2.1 Single-header usage variant (a.k.a. the included version)
#     3.2.2 Static library usage variant
#     3.2.3 Shared library usage variant
#
#
###  TEST LIB SECTION: Declaring and organizing tests
#
# 3.3 Test suite
#     3.3.1 Master Test Suite
#
# 3.4 Test cases
#     3.4.1 Test cases without parameters
#     3.4.2 Data-driven test cases
#     3.4.3 Template test cases
#
# 3.5 Decorators
#     3.5.1 Test-level decorators
#     3.5.2 Suite-level decorators
#     3.5.3 Explicit decorator declaration
#
# 3.6 Fixtures
#
#     3.6.1 Fixture models
#     3.6.2 Test case fixture
#     3.6.3 Test suite entry/exit fixture
#     3.6.4 Global fixture
#
# 3.7 Managing test dependencies
#
# 3.8 Grouping tests into logical units by labels
#
# 3.9 Enabling or disabling test unit execution
#
#     3.9.1 Unconditional run status       
#     3.9.2 Compilation-time run status
#     3.9.3 Runtime status
#
# 3.10 Adding semantic to a test
#
#
###  TEST LIB SECTION: Writing unit tests
#
# 3.11 Writing unit tests
#
# 3.11.1 Assertion severity level
# 3.11.2 BOOST_TEST: universal and general purpose assertions
# 3.11.3 Reported information
#
# 3.11.4 Extended comparisons support
# 	 3.11.4.1 Floating point comparison
# 	 3.11.4.2 Strings and C-strings comparison
# 	 3.11.4.3 Collections comparison
# 	 3.11.4.4 Bitwise comparison
#
# 3.11.5 Exception correctness
# 3.11.6 Time-out for test cases
# 3.11.7 Expected failures specification
# 3.11.8 Custom predicate support
# 3.11.9 Output streams testing tool
# 3.11.10 BOOST_TEST: details on expressions
# 3.11.11 Debugging the assertions
# 3.11.12 Summary of the API for writing tests
#
#
###  TEST LIB SECTION: Controlling outputs
#
###  TEST LIB SECTION:  Runtime parameters
#
###  TEST LIB SECTION: Advanced Usage Scenarios
#
###  TEST LIB SECTION: Practical usage recommendations
#

### TEST LIB SECTION: Test Lib Appendix

# 3.A Unit Test Framework API reference
#
# 3.B Frequently Asked Questions




# Appendix K - Code examples (./code_examples)
#

# Appendix Z - References
#

# ==============================================================================



# ==============================================================================
# 1 Getting Started
# ==============================================================================

# 1.1 The Boost Distribution

# boost path

The path to the boost root directory (often /usr/local/boost_1_64_0)
is sometimes referred to as $BOOST_ROOT.

   >>echo $BOOST_ROOT
   /home/swim/development/SWIS_root/toolbox/boost_dist


# 1.2 Header-Only Libraries

WARNING
The only Boost libraries that must be built separately are (see [1_1_1])


# 1.3 Build a Simple Program Using Boost [k1]

HINT 
All of Boost's header files have the .hpp extension

    #include <boost/whatever.hpp>

    or

    #include "boost/whatever.hpp"


# compilation

  >> c++ -I path/to/boost_1_64_0 example.cpp -o example

  (i.e. c++ -I $BOOST_ROOT example.cpp -o example)


# linkage

  case: #include <boost/test/unit_test.hpp>
  	LDLIBS = -lboost_unit_test_framework  # in the Makefile


# 1.4 Prepare to Use a Boost Library Binary

If you want to use any of the separately-compiled Boost libraries,
you'll need to acquire library binaries. (see [1_1_1] for details)


# 1.5 Link Your Program to a Boost Library

Similar to STL:
	# LDFLAGS: flags (i.e -g), and library paths (i.e. -L path-lib)
	# LDLIBS:  library names: (i.e. LDIBS="-lncurses -lm -lsdl")

See [1_1_1] for details.


# ==============================================================================
# 2 Smart Pointer library 
# ==============================================================================

# 2.1 Sole Ownership (boost::scoped_ptr, boost::scoped_array) [2_2]

#include <boost/scoped_ptr.hpp>   // for pointers to single objects
#include <boost/scoped_array.hpp> // for pointers to arrays

1) boost::scoped_ptr is a smart pointer that is the sole owner of a
   dynamically allocated object.

2) boost::scoped_ptr cannot be copied or moved.

3) boost::scoped_ptr require that T be a complete type at destruction
   time. [2_1]


4) Using boost::scoped_ptr

   [ Example

   #include <boost/scoped_ptr.hpp>
   #include <iostream>

   int main()
   {
    boost::scoped_ptr<int> p{new int{1}};
    std::cout << *p << '\n';
    p.reset(new int{2});
    std::cout << *p.get() << '\n';
    p.reset();
    std::cout << std::boolalpha << static_cast<bool>(p) << '\n';
   }

   end example ]


# 2.1.1 scoped_ptr FAQ [2_1]

FAQ Are there any advantages of boost::scoped_ptr over std::unique_ptr? 
    Shall one always prefer the latter while coding on c++11?

    >>> If you see a boost::scoped_ptr in someone's code, you know
        immediately that the object it owns isn't used outside of the
        current scope. If you see a std::unique_ptr, you have to look
        further to find out whether ownership is transferred and the
        object is used outside of the current scope. (If you know that
        this other developer knows both boost::scoped_ptr and
        std::unique_ptr, you can deduce that std::unique_ptr means
        that ownership will be transferred - otherwise he would have
        used boost::scoped_ptr.)


FAQ Are *p and *p.get() essentially equivalent?

    >>> That's correct. Two minor differences: get() is noexcept, and
        operator* checks with BOOST_ASSERT whether the pointer is not 0.


# ------------------------------------------------------------------------------
# 2.2 Shared Ownership (boost::shared_ptr) [2_3] [2_1] 
# ------------------------------------------------------------------------------

#include <boost/shared_ptr.hpp>

1) Similar to scoped_ptr BUT boost::shared_ptr is not necessarily the
   exclusive owner of an object. Ownership can be shared with other
   smart pointers of type boost::shared_ptr

2) The shared object is not released until the last copy of the shared
   pointer referencing the object is destroyed.

    reset(): decrements the counter of owners
    	     IF (counter == 0) THEN object destroyed ENDIF

3) BECAUSE it can share ownership, the smart pointer can be copied, 

4) Shared_ptr does not require that T be a complete type at
   destruction time. [2_1]

5) Using boost::shared_ptr 
   
   [ Example [k2_1]

     include <boost/shared_ptr.hpp>
     #include <iostream>

     int main()
     {
       boost::shared_ptr<int> p1{new int{1}};
       std::cout << *p1 << '\n';
       boost::shared_ptr<int> p2{p1};    // (*1)
       p1.reset(new int{2});  	       // (*2)
       std::cout << *p1.get() << '\n';
       p1.reset();
       std::cout << std::boolalpha << static_cast<bool>(p2) << '\n';
     }

   end example ]

   // (*1) p1 and p2 share THE SAME object

   // (*2) p1 is no longer an owner of the object, but p2 still is =>
   // 	   object not destroyed

6) Operators

   get()    retrieve the currently stored address
   reset()  store a new address


   Like boost::scoped_ptr, boost::shared_ptr overloads:

   operator bool():  return false if the pointer is NULL
   operator*():      and checks whether the pointer is not 0. (see 2.1.1)
   operator->()

7)  A non-initialized shared pointer is like a NULL pointer:

    [ Example:  boost::shared_ptr<int> p; cout << p ; // 0   end example ]


# 2.2.1 user-defined deleter

   As a second parameter, a deleter can be passed to the constructor
   of boost::shared_ptr. The deleter must be a function or function
   object that accepts as its sole parameter a pointer of the type
   boost::shared_ptr was instantiated with. The deleter is called in
   the destructor instead of delete. This makes it possible to manage
   resources other than dynamically allocated objects in a boost::shared_ptr.

   (see [3_1])


# 2.2.2 Using boost::shared_array

1) Operators
 
   get()
   reset()
   operator[] 
   operator bool()

 \warning operator*() and operator->() are not overloaded.


2) Using boost::shared_array 

   [ Example [k2_2]

      #include <boost/shared_array.hpp>
      #include <iostream>

      int main()
      {
        boost::shared_array<int> p1{new int[1]};
  	{
	  boost::shared_array<int> p2{p1};
    	  p2[0] = 1;
  	}
  	std::cout << p1[0] << '\n';
      }

   end example ]


3) NOTICE Since Boost 1.53.0, boost::shared_ptr is an alternative to
   	  boost::shared_array: [k2_3]

   Since Boost 1.53.0, boost::shared_ptr supports single objects and
   arrays and detects whether it has to release resources with delete
   or delete[]. Because boost::shared_ptr also overloads operator[]
   (since Boost 1.53.0), this smart pointer is an alternative for
   boost::shared_array.

   \bug [k2_3] compilation error upon trying operator[] with Boost
   	1.59.0 and C++98. \todo Try with more modern versions.

4) \bug shared_array allows out_of_bounds indexing [k2_2]

   [ Example     
   
     boost::shared_array<int> p1(new int[2]);
     p1[0]=0; p1[1]=1;
     p1[100]=77;                    // accepted!!
     std::cout << p1[100] << '\n';  // prints 77
     std::cout << p1[2] << '\n';    // prints 0
   
   end example ]

5) \warning No length operator available. The size of the pointed
   array must be manually managed.


# 2.2.3 Using boost::make_shared

1) The advantage of boost::make_shared() is that the memory for the
   object that has to be allocated dynamically and the memory for the
   reference counter used by the smart pointer internally can be
   reserved in one chunk (boost::shared_ptr requires two calls).

2) You can use boost::make_shared() for arrays, too.

   [ Example [k2_4]

   #include <boost/make_shared.hpp>
   #include <typeinfo>
   #include <iostream>
   int main()
   {
    auto p1 = boost::make_shared<int>(1);
    std::cout << typeid(p1).name() << '\n';

    //!\error with Boost 1.59.0 and C++98. \todo Try with more modern versions.
    auto p2 = boost::make_shared<int[]>(10);
    std::cout << typeid(p2).name() << '\n';
   }

   end example ]


# 2.2.4 boost::shared_ptr optimization with macros

1) Boost.SmartPointers supports macros to optimize the behavior of the
   smart pointers. 

   Idea behind: using macros => boost::shared_ptr >> std::shared_ptr

2) macro BOOST_SP_USE_QUICK_ALLOCATOR to activate an allocator shipped
   with Boost.SmartPointers. This allocator manages memory chunks to
   reduce the number of calls to new and delete for reference counters.


   \warning In my test (see [k2_5]), the results are not the expected:
   better without the optimization macro.


   [ Example [k2_5]

   // measure the time of a loop (computer dependent)

   // the example may run faster with BOOST_SP_USE_QUICK_ALLOCATOR than without
   
   #define BOOST_SP_USE_QUICK_ALLOCATOR
   #include <boost/shared_ptr.hpp>
   #include <iostream>
   #include <ctime>

   int main()
   {
     boost::shared_ptr<int> p;
     std::time_t then = std::time(nullptr);
     for (int i = 0; i < 1000000; ++i)
     	 p.reset(new int{i});
     std::time_t now = std::time(nullptr);
     std::cout << now - then << '\n';
   }

   end example ]

3) The names of the macros start with BOOST_SP_
   (i.e. BOOST_SP_ENABLE_DEBUG_HOOKS)


# 2.3 Special Smart Pointers

# 2.3.1 bosst::weak_ptr

1) Why it is needed?

   Problem: 

   We need to use an existing object (avoid using a pointer already destroyed)
   BUT  
   without having any impact on the lifetime of the object (avoid new
   references to the object).


   Solution: boost::weak_ptr 

   boost::weak_ptr makes sense whenever a function is expected to work
   with an object managed by a shared pointer, but the lifetime of the
   object does not depend on the function itself. The function can
   only use the object as long as it is owned by at least one shared
   pointer somewhere else in the program. In case the shared pointer
   is reset, the object cannot be kept alive because of an additional
   shared pointer inside the corresponding function.

   In the example bellow, we only want to print while the actual pointer exists.

  [ Example

    #include <boost/shared_ptr.hpp>
    #include <boost/weak_ptr.hpp>
    #include <thread>
    #include <functional>
    #include <iostream>

    void reset(boost::shared_ptr<int> &sh)
    {
	sh.reset();
    }

    void print(boost::weak_ptr<int> &w)
    {
	boost::shared_ptr<int> sh = w.lock();
  	if (sh)
    	   std::cout << *sh << '\n';
    }

    int main()
    {
      boost::shared_ptr<int> sh{new int{99}};
      boost::weak_ptr<int> w{sh};
      std::thread t1{reset, std::ref(sh)};
      std::thread t2{print, std::ref(w)};
      t1.join();
      t2.join();
    }

   end example ]

2) boost::weak_ptr must be initialized with a boost::shared_ptr. 

3) Its most important member function is lock(). lock() returns a
   boost::shared_ptr that shares ownership with the shared pointer
   used to initialize the weak pointer.

4) In case the shared pointer is empty, the returned pointer will be
   empty as well.


# 2.3.2 boost::intrusive_ptr

1) In general, boost::intrusive_ptr works the same as
   boost::shared_ptr. However, while boost::shared_ptr keeps track of
   the number of shared pointers referencing a particular object, the
   developer has to do this when using boost::intrusive_ptr. This can
   make sense if other classes already keep track of references.

   See example on [1_2]


# 2.4 Boost.PointerContainer

1) The library Boost.PointerContainer provides containers specialized
   to manage dynamically allocated objects. 

   Similar to C++11's std::vector<std::unique_ptr<int>>. However, the
   containers from Boost.PointerContainer can provide some extra comfort.

2) Available containers (they correspond to std containers)
   
   boost::ptr_vector
   boost::ptr_set
   boost::ptr_deque
   boost::ptr_list
   boost::ptr_map
   boost::ptr_array
   boost::ptr_unordered_set
   boost::ptr_unordered_map 


# 2.4.1 boost::ptr_vector

1) because boost::ptr_vector knows that it stores dynamically
   allocated objects, member functions like back() return a reference
   to a dynamically allocated object and not a pointer.

  [ Example [k2_6]

    #include <boost/ptr_container/ptr_vector.hpp>
    #include <iostream>

    int main()
    {
     boost::ptr_vector<int> v;
     v.push_back(new int{1});
     v.push_back(new int{2});
     std::cout << v.back() << '\n';  // prints 2
    }

  end example ]


# 2.4.2 boost::ptr_set

1) "boost::ptr_set" VS "std::set": with boost::ptr_set, the order of
   the elements depends on the int values, not on the pointers.

  [ Example [k2_7]

    #include <boost/ptr_container/ptr_set.hpp>
    #include <iostream>

    int main()
    {
     boost::ptr_set<int> s;
     s.insert(new int{2});
     s.insert(new int{1});
     std::cout << *s.begin() << '\n';
    }

  end example ]

2) HINT To make std::set sort the elements based on int values, the
   container must be told how to compare elements. (i.e. via
   boost::indirect_fun provided by Boost.PointerContainer)

  [ Example

    #include <boost/ptr_container/ptr_set.hpp>
    #include <boost/ptr_container/indirect_fun.hpp>
    #include <set>
    #include <memory>
    #include <functional>
    #include <iostream>

    int main()
    {
     std::set<std::unique_ptr<int>, boost::indirect_fun<std::less<int>>> v;
     v.insert(std::unique_ptr<int>(new int{2}));
     v.insert(std::unique_ptr<int>(new int{1}));
     std::cout << **v.begin() << '\n';
    }

  end example ]


# 2.4.3 Inserters for boost containers

1) Boost.PointerContainer provides inserters for its containers. 

2) Defined under  #include <boost/ptr_container/ptr_inserter.hpp>

3) Available of inserters

   boost::ptr_container::ptr_back_inserter()
   boost::ptr_container::ptr_front_inserter()
   boost::ptr_container::ptr_inserter()

4) boost::ptr_container::ptr_back_inserter() example
   
   This function creates an inserter of type
   boost::ptr_container::ptr_back_insert_iterator

   The inserter creates copies with new on the heap and adds the
   addresses to the container.

  [ Example [k2_8]

    #include <boost/ptr_container/ptr_vector.hpp>
    #include <boost/ptr_container/ptr_inserter.hpp>
    #include <array>
    #include <algorithm>
    #include <iostream>

    int main()
    {
     boost::ptr_vector<int> v;

     //[C++11]
     std::array<int, 3> a{{0, 1, 2}};
     std::copy(a.begin(), a.end(), boost::ptr_container::ptr_back_inserter(v));
     //[C++03]
     // int a[3] = {0, 1, 2};
     // std::copy(a, a+3, boost::ptr_container::ptr_back_inserter(v));

     std::cout << v.size() << '\n';
    }

  end example ]


# ==============================================================================
# 3 Test library
# ==============================================================================

Support for simple program testing, full unit testing, and for program
execution monitoring.

# 3.1 Introduction to testing with Boost

# 3.1.1 A simple example

  [ Example  (Test case [k3_1]); (Defined at [3_1])

  // 1) code
  
  #define BOOST_TEST_MODULE BoostTestHowto        // See 3.A.1
  #include <boost/test/included/unit_test.hpp>	  // See 3.2.1

  BOOST_AUTO_TEST_CASE(first_test)
  {
    int i = 1;
    BOOST_TEST(i);
    BOOST_TEST(i == 2);
  }

  // 2) execution

  >>./main
  Running 1 test case...

  main.cpp(8): error: in "first_test": check i == 2 has failed [1 != 2]

  *** 1 failure is detected in the test module "BoostTestHowto"

  end example ]



# ------------------------------------------------------------------------------
# 3.2 Usage Variants [3_1]
# ------------------------------------------------------------------------------
 
# 3.2.1 Single-header usage variant (a.k.a. the included version)

  #define BOOST_TEST_MODULE test module name
  #include <boost/test/included/unit_test.hpp>


1) This includes all (HUGE!) the Unit Test Framework in a "single header mode"

2) It even defines function main, which will call the subsequently
   defined test cases.

3) Drawback: huge library => very long compilation time

4) Drawback: you can only implement this way test modules with a
   single translation unit.


# 3.2.2 Static library usage variant

1) For most users, who has an access to pre-built static library [1]
   of the Unit Test Framework or can build it themselves, following
   usage can be most versatile and simple approach. This usage variant
   entails two steps.

  1. First add the following line to ALL TRANSLATION UNITS in a test module:

    	#include <boost/test/unit_test.hpp>

     and ONLY ONE translation unit should include following lines:

    	#define BOOST_TEST_MODULE test module name
    	#include <boost/test/unit_test.hpp>

  2. The second step is to link with the Unit Test Framework static library

     -lboost_unit_test_framework


NOTE
Header <boost/test/unit_test.hpp> is an 'aggregate' header: it includes most of
the other headers that contains the Unit Test Framework definitions.


2) Advantages: short compilation time

3) Drawback: Statically linked: each test module following this usage variant is
   going to be statically linked with Unit Test Framework, which might
   be something you interested to avoid (to save space for example).

4) Drawback: Customizing the module's entry point (*) will affect
   everybody else who is linking against the library. It may be less
   intrusive to switch to the shared library usage variant instead.

   (See http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/
   	/adv_scenarios/static_lib_customizations.html for details.)


# 3.2.3 Shared library usage variant [k3_2]

1) Solution to waste space problem of static lib. usage. (3.2.3.1)

2) Customizing the module's entry point and the initialization function

   First add the following line to ALL TRANSLATION UNITS in a test module:

	#define BOOST_TEST_DYN_LINK
	#include <boost/test/unit_test.hpp>

	//
	// test cases
	//


   and ONLY ONE translation unit should include following lines (3.2.3.1.1):

	/*!\warning Not need anymore if the init function
		    (init_unit_test()) is defined

        // #define BOOST_TEST_MODULE test module name

	\warning "Master Test Suite" is taken by default

	// #define BOOST_TEST_NO_MAIN  # (its value is irrelevant)
	*/	

	#define BOOST_TEST_DYN_LINK

	#include <boost/test/unit_test.hpp>

	// (MANUALLY DEFINED) initialization function:
	bool init_unit_test() { return true; }

	// (MANUALLY DEFINED) entry point:
	int main(int argc, char* argv[], char* envp[])
	{
	return boost::unit_test::unit_test_main( &init_unit_test, argc, argv );
	}
 

  2. The second step is to link with the Unit Test Framework shared library

     LDLIBS = -lboost_unit_test_framework  


2) Advantages: short compilation time

3) You will need to make sure the Unit Test Framework shared library
   is accessible at runtime to a test module.

4) WARNING In Windows, ... (see [3_1] for details)


# 3.2.3.1 Shared-library variant customizations [3_3]
 
1) BOOST_TEST_DYN_LINK is required

   WARNING
   Macro BOOST_TEST_DYN_LINK may be implicitly defined when macro
   BOOST_ALL_DYN_LINK is defined:

   Use #ifndef BOOST_TEST_DYN_LINK
       #define BOOST_TEST_DYN_LINK
       #endif

2) The the dynamic library of the Unit Test Framework must be in the path

   Linux: LD_LIBRARY_PATH
   Mac:   DYLD_LIBRARY_PATH

  [ Example echo $LD_LIBRARY_PATH

    /home/swim/development/SWIS_root/toolbox/boost_dist/stage/lib

  end example ]


3) Customizing the module's initialization function

   In the shared-library variant, it is impossible to customize the
   initialization function without customizing the entry point. We
   have to customize both:

   a) Automatically Defined entry point and init. function

      #define BOOST_TEST_MODULE any new name  //required
      
      #define BOOST_TEST_NO_MAIN              // forbidden
      bool init_unit_test(){ return true; }   // forbidden
      int main(int argc, char* argv[])        // forbidden   
      {return boost::unit_test::unit_test_main( &init_unit_test, argc, argv );}


   b) Manually Defined entry point and init. function

      #define BOOST_TEST_MODULE any new nmae  //required
      
      #define BOOST_TEST_NO_MAIN              // required
      bool init_unit_test(){ return true; }   // forbidden
      int main(int argc, char* argv[])        // required   
      {return boost::unit_test::unit_test_main( &init_unit_test, argc, argv );}


  [ Example Automatically Defined entry point and init. function  [k3_2] 
 
    //!\file main.cpp

    #define BOOST_TEST_MODULE BoostTestHowto_SharedUsageVariant //required
    #ifndef BOOST_TEST_DYN_LINK
    #define BOOST_TEST_DYN_LINK
    #endif

    #include <boost/test/unit_test.hpp>

    BOOST_AUTO_TEST_CASE(first_test)
    {
      BOOST_CHECK_EQUAL(77, 111);
    }


    //!\file test_2.cpp
    #define BOOST_TEST_DYN_LINK
    #include <boost/test/unit_test.hpp>

    BOOST_AUTO_TEST_CASE(another_test)
    { BOOST_CHECK(22 == 3); }


    //!\output 
    Running 2 test cases...
    main.cpp(63): error in "first_test": check 77 == 111 failed [77 != 111]
    test_2.cpp(5): error in "another_test": check 22 == 3 failed

    *** 2 failures detected in test suite "BoostTestHowto_SharedUsageVariant"

  end example  ]


# ------------------------------------------------------------------------------
# 3.3 Test suite
# ------------------------------------------------------------------------------

1) Test tree concept

   - test cases: leaves  (mandatory)
   
   - test suite: branch  (optional)

   - master test suite: root

2) If you do want to construct a hierarchical test suite structure the
   Unit Test Framework provides both manual and automated test suite
   creation and registration facilities:
 

# 3.4.1 Automated registration

1) namespace like concept in a single compilation unit

   BOOST_AUTO_TEST_SUITE(test_suite_name);
   ...
   // test cases here
   ...
   BOOST_AUTO_TEST_SUITE_END();


2) Test units declared at a test file scope become members of the
   master test suite (thus, the master test suit is just like the
   global namespace).

3) There is no limit on depth of test suite inclusion. 

4) Many different test suites can be defined in the same file


# 3.4.2 Manual registration

1) BOOST_TEST_SUITE(test_suite_name);

   See [3_1] for details.


2) (auto-question) Why use this instead of the automated mode?

   "If you use only free function based test cases advance to the
   automatic registration facility"  (3.???.1 Generic usage recommendations)

   "If most of your tests are unique, and you're not running the same
   test repeatedly with different parameters, then you probably won't
   see any benefit from switching to manual registration." [3_100_1]


# 3.4.3 Master Test Suite

1) Each test module built with the Unit Test Framework always has the
   master test suite defined. All other test units are registered as
   direct or indirect children of the master test suite.

   My_note.- like the global namespace in C++

2) To access single instance of the master test suite use the
   following interface:

   boost::unit_test::framework::master_test_suite_t& master_test_suite();


# 3.4.3.1 Command line arguments access interface

1) The M.T.S. maintains references to the command arguments passed to
   the test module. To access the command line arguments use:

   boost::unit_test::framework::master_test_suite().argc
   boost::unit_test::framework::master_test_suite().argv

2) Example: Command line access in initialization function [3_1]


# 3.4.3.2 Naming the Master test suite

1) The master test suite is created with default name Master Test Suite. 
   There are two methods two reset the name to a different value.

2)  Naming master test suite using the macro BOOST_TEST_MODULE

   	 #define BOOST_TEST_MODULE my master test suite name

   If the macro BOOST_TEST_MODULE is defined, the test module
   initialization function is automatically generated and the macro
   value becomes the name of the master test suite. The name may
   include spaces.


3) Naming master test suite explicitly in the test module init. function

   [ Example

     #include <boost/test/included/unit_test.hpp>
     using namespace boost::unit_test;

     BOOST_AUTO_TEST_CASE( free_test_function )
     {
      BOOST_TEST( true /* test assertion */ );
     }

     test_suite* init_unit_test_suite( int /*argc*/, char* /*argv*/[] )
     {
      framework::master_test_suite().p_name.value = "my master test suite name";
      return 0;
     }

   end example ]


# ------------------------------------------------------------------------------
# 3.4 Test cases
# ------------------------------------------------------------------------------

1) Is a unit of execution that is run by the test runner. It contains
   instructions and assertions (BOOST_TEST, BOOST_CHECK), and its
   execution is monitored by the Unit Test Framework. Information
   about the execution is recorded, and a log/report is produced.

2) Preferred APIs will declare the test case and register it
   automatically in a test tree.


# 3.4.1 Test cases without parameters

# 3.4.1.1 Automated registration

     	  BOOST_AUTO_TEST_CASE(test_case_name);

# 3.4.1.2 Manual registration

1) WARNING A test case can be implemented as a method of a class. See
   [3_4] for details.


# 3.4.2 Data-driven test cases [3_5]

1) Why data-driven test cases? Some tests are required to be repeated
   for a series of different input parameters.


See [3_5] for details.


# \todo 3.4.2.1 Datasets

Sample: is a polymorphic tuple. The size of the tuple will be by
	definition the arity of the sample itself.

Dataset: a (forward iterable & with known size) collection of samples.

Note.- Arity: the number of arguments or operands that a function takes.


1) WARNING Only "monomorphic" datasets are supported, which means that
	all samples in a dataset have the same type and same arity.


# \todo 3.4.2.2 Declaring and registering test cases with datasets

# \todo 3.4.2.3 Operations on dataset

    Joins
    Zips  ( i.e. [0,1] ^ ["lost", "won"] = pairs (0, "lost), (1, "won")  )
    Grid  (Cartesian products)

# \todo 3.4.2.4 Datasets generators


# 3.4.3  Template test cases [3_6]

1) Used to test Template classes

# \todo 3.4.3.1 Test case template with automated registration

# \todo 3.4.3.1 Test case template with manual registration


# ------------------------------------------------------------------------------
# 3.5 Decorators
# ------------------------------------------------------------------------------

1) WARNING Applied only for the automatically registered test units. 

2) Decorators list (API): [3_7]


# 3.5.1 Test case decorators

Define a decorator for a concrete test

1) A list of decorators is applied to a test case by specifying it as
   the second argument to macro BOOST_AUTO_TEST_CASE or the third
   argument to macro BOOST_FIXTURE_TEST_CASE.

   BOOST_AUTO_TEST_SUITE(suite1, * utf::label("trivial"))

2) Each decorator in the list is preceded by an asterisk (*)

   (i.e.  * utf::label("trivial") in the test bellow )

3) [ Example [k3_3]

     #define BOOST_TEST_MODULE decorator_01
     #include <boost/test/included/unit_test.hpp>

     namespace utf = boost::unit_test;

     BOOST_AUTO_TEST_CASE(test_case1, * utf::label("trivial"))
     {
       BOOST_TEST(true);
     }

     BOOST_AUTO_TEST_CASE(test_case2,
	* utf::label("trivial")
	* utf::label("cmp")
	* utf::description("testing equality of ones"))
     {
       BOOST_TEST(1 == 1);
     }

   end example ]


# 3.5.2 Suite-level decorators

Define a decorator for the entire suite

1) Similarly to test case it is possible to apply list of decorators
   to test suite. It is done by specifying a list of decorators as the
   second argument to the macro BOOST_AUTO_TEST_SUITE or the third
   argument to the macro BOOST_FIXTURE_TEST_SUITE.

   BOOST_AUTO_TEST_SUITE(suite1, * utf::label("trivial"))


# 3.5.3 Explicit decorator declaration

1) WARNING 
   The above syntax for decorators requires that the compiler supports
   variadic macros (added in C++11). If you intend for your test
   program to also work for compilers without variadic macros, use
   explicit decorator syntax, described below.

2) Macro BOOST_TEST_DECORATOR indicates that its set of decorators is
   to be applied to the test unit or test case sequence that
   immediately follows the declaration.

3) [ Example [k3_3]

     #define BOOST_TEST_MODULE decorator_00
     #include <boost/test/included/unit_test.hpp>

     #include <boost/test/data/test_case.hpp>

     namespace utf  = boost::unit_test;
     namespace data = boost::unit_test::data;

     BOOST_TEST_DECORATOR(* utf::description("with description"))
     BOOST_DATA_TEST_CASE(test_1, data::xrange(4))
     {
	BOOST_TEST(sample >= 0);
     }

   end example ]


# ------------------------------------------------------------------------------
# 3.6 Fixtures
# ------------------------------------------------------------------------------

1) In general terms a test fixture or test context is the collection
   of one or more of the following items, required to perform the test:

    preconditions
    particular states of tested units
    necessary cleanup procedures

2) Test modules may contain hundreds of single assertion test cases,
   many requiring very similar test setup/cleanup. This is the problem
   that the test fixture is designed to solve.


# 3.6.1 Fixture models

# 3.6.1.1 Fixture class model

  struct <fixture-name>
  {
    <fixture-name>();      // setup function
    ~<fixture-name>();     // teardown function
  };

  This model is expected from fixtures used with BOOST_FIXTURE_TEST_CASE and 
  BOOST_FIXTURE_TEST_SUITE.

# 3.6.1.2 Flexible models

  A decorator fixture. 

  See [3_1] for details


# 3.6.2 Test case fixture

1) A test case fixture is a fixture consumed by a test case

   a) the fixture setup is called before the test case executes

   b) the fixture teardown is called after the test case finished its
      execution, INDEPENDENTLY FROM ITS EXECUTION STATE.


# 3.6.2.1 Single test case fixture with BOOST_FIXTURE_TEST_CASE


  BOOST_FIXTURE_TEST_CASE(test_case_name, fixture_name);


1) Equivalent to BOOST_AUTO_TEST_CASE but using 'fixture_name' fixture

2) ONLY ONE FIXTURE can be attached to a test-case.

3) All non- pivate members of the fixture are directly accessible from
   the test case body.

   HINT Do not make private members in a fixture class, it is absurd.

4) [ Example [k3_4]

     #define BOOST_TEST_MODULE example
     #include <boost/test/included/unit_test.hpp>

     struct F 
     {
	F() : i( 0 ) { BOOST_TEST_MESSAGE( "setup fixture" ); }
     	~F()         { BOOST_TEST_MESSAGE( "teardown fixture" ); }
	int i;
     };

     BOOST_FIXTURE_TEST_CASE( test_case1, F )
     {
          BOOST_TEST( i == 1 );
     	  ++i;  // direct access to the fixture members !
     }

     BOOST_FIXTURE_TEST_CASE( test_case2, F )
     {
	BOOST_CHECK_EQUAL( i, 1 );
     }

     BOOST_AUTO_TEST_CASE( test_case3 )
     {
	BOOST_TEST( true );
     }

   end example ]


# 3.6.2.2 Single test case fixture with fixture decorator

1) Allows attach SEVERAL FIXTURES to a unique test case

   See [3_1] for details.


# 3.6.2.3 Fixture for a complete subtree


  BOOST_FIXTURE_TEST_SUITE(suite_name, fixture_name);


1) Use BOOST_FIXTURE_TEST_SUITE(suite_name, fixture_name); in place of
   the macro BOOST_AUTO_TEST_SUITE(suite_name)

2) TIP
   If necessary you can reset the fixture for a particular test case
   using the macro BOOST_FIXTURE_TEST_CASE. Similarly you can reset
   the fixture for a particular sub test suite using BOOST_FIXTURE_TEST_SUITE.

3) Note.- The fixture assignment is deep. (recursive)

4) WARNING
   The fixture constructor and destructor is called for each test
   cases (the state of the fixture is not shared among the test cases).

5) [ Example [k3_5]

     #define BOOST_TEST_MODULE fixture_subtree
     #include <boost/test/included/unit_test.hpp>

     struct F 
     {
	F() : the_i( 0 ) { BOOST_TEST_MESSAGE( "setup fixture" ); }
     	~F()             { BOOST_TEST_MESSAGE( "teardown fixture" ); }
	int the_i;
     };

     
     BOOST_FIXTURE_TEST_SUITE(suite_subtree, F)

     BOOST_AUTO_TEST_CASE(test_case1)
     {
	BOOST_TEST_MESSAGE("running test_case1");
     	BOOST_TEST(the_i == 0);
     }

     BOOST_AUTO_TEST_CASE(test_case2)
     {
	BOOST_TEST_MESSAGE("running test_case2");
     	BOOST_TEST(the_i == 0);
     }

     BOOST_AUTO_TEST_SUITE_END()


     // Output

      > fixture_02 --log_level=message
      Running 2 test cases...
      setup fixture
      running test_case1
      teardown fixture
      setup fixture
      running test_case2
      teardown fixture

      *** No errors detected

   end example ]


# 3.6.3 Test suite entry/exit fixture

  i) execute the setup function once (upon suite exit)
  ii) execute all the tests
  i) execute the teardown function once (upon suite exit)

1) This is facilitated by the decorator fixture  See [3_1]

2) In case of this fixture type, however, it is not possible to access
   any members of the fixture object.

3) WARNING
   This is not equivalent to using the method described at 3.6.2.3
   (Fixture for a complete subtree)


# 3.6.4 Global fixture

1) Though some initialization can be implemented in the test module
   initialization function, there are several reasons to prefer the
   global fixture approach. (see [3_1] for details)

2) To define a global test module fixture you need to implement a
   class that matched generic fixture model and passed it as an
   argument to the macro BOOST_GLOBAL_FIXTURE.

3) The statement, that performs global fixture definition, has to
   reside at a test file scope.

4) [ Example

     #define BOOST_TEST_MODULE example
     #include <boost/test/included/unit_test.hpp>
     #include <iostream>

     //____________________________________________

     struct MyConfig {
        MyConfig()   { std::cout << "global setup\n"; }
        ~MyConfig()  { std::cout << "global teardown\n"; }
      };

    //____________________________________________

     BOOST_GLOBAL_FIXTURE( MyConfig );

     BOOST_AUTO_TEST_CASE( test_case )
     {
       BOOST_TEST( true );
     }


     // Output

     > example
     global setup
     Running 1 test case...
     global teardown

     *** No errors detected

   end example ]


# ------------------------------------------------------------------------------
# 3.7 Managing test dependencies
# ------------------------------------------------------------------------------

In general, you should make sure that test cases are independent on one another.

# 3.7.1 Declaring a test case dependency

1) The test cases must belong to the same suite.

\todo See [3_1] for details


# ------------------------------------------------------------------------------
# 3.8 Grouping tests into logical units by labels
# ------------------------------------------------------------------------------

1) Explicit FLEXIBLE organization of test by using the decorator "label"

   label(const_string label_name);

   Associates a test unit with label label_name. It is possible to
   associate more than one label with a test unit.

2) Labels can be associated to test cases and test suites: decorating
   a test suite with label L is equivalent to decorating every test
   unit inside with L.

3) Tip: it is possible to list all labels of a test module from the
   CLI by using the --list_labels switch

4) The label selection is executed through the command line parameter:

   --run_test=@label_name

5) [ Example

     #define BOOST_TEST_MODULE decorator_04
     #include <boost/test/included/unit_test.hpp>
     namespace utf = boost::unit_test;

     BOOST_AUTO_TEST_CASE(test1,  * utf::label("l1"))
     {  BOOST_TEST(false); }

     BOOST_AUTO_TEST_CASE(test2,  * utf::label("l1")  
     				  * utf::label("l2"))
     { BOOST_TEST(false); }

     BOOST_AUTO_TEST_CASE(test3)
     { BOOST_TEST(false); }

     //----------------------------------

      Output

      > decorator_04 # executes all the test ignoring the label decorator
      Running 3 test cases...
 
      > decorator_04 --run_test=@l1   # executes only label l1 tests
      Running 2 test cases...
      test.cpp(8): error: in "test1": check false has failed
      test.cpp(15): error: in "test2": check false has failed

   end example]


# ------------------------------------------------------------------------------
# 3.9 Enabling or disabling test unit execution
# ------------------------------------------------------------------------------
 
# 3.9.1 Unconditional run status

1) Setting DEFAULT run status with decorators "disabled" & "enabled"

2) The run status can be overridden by the command line parameters

3) [ Example  [k3_6]

     #define BOOST_TEST_MODULE decorator_05
     #include <boost/test/included/unit_test.hpp>
     namespace utf = boost::unit_test;

     BOOST_AUTO_TEST_SUITE(suite1, * utf::disabled())

     BOOST_AUTO_TEST_CASE(test1)
     { BOOST_TEST(1 != 1); }

     BOOST_AUTO_TEST_CASE(test2, * utf::enabled())
     { BOOST_TEST(2 != 2); }

     BOOST_AUTO_TEST_SUITE_END()   

     // -------------------------

     Output:

     > decorator_05
     Only SUITE1/test2 is executed

     > decorator_05 --list_content
     suite1*
	test1
	test2*
   end example ]

       
# 3.9.2 Compilation-time run status

1) Decorator enable_if<true>() is equivalent to decorator enabled(). Similarly,
   enable_if<false>() is equivalent to decorator disabled().

2) [ Example

    #define BOOST_TEST_MODULE decorator_06
    #include <boost/test/included/unit_test.hpp>
    namespace utf = boost::unit_test;
    const bool io_implemented = true;
    const bool db_implemented = false;

    BOOST_AUTO_TEST_CASE(test_io,
      * utf::enable_if<io_implemented>())
    { BOOST_TEST(1 != 1); }

    BOOST_AUTO_TEST_CASE(test_db,
      * utf::enable_if<db_implemented>())
    { BOOST_TEST(2 != 2); }

  end example ]


# 3.9.3 Runtime status

1) Decorator "precondition" associates a predicate with a test unit. 

2) [ Example (see [3_1] for details)

     /* predicate: evaluates to true if at least one of the two
     	specified tests passed.
     */
     struct if_etither{ ... }

     /* Test case test3 has a precondition that at either test1 or test2 passed.
        This precondition is checked at runtime.
     */
     BOOST_AUTO_TEST_CASE(test3,
       * utf::precondition(if_either("test1", "test2")))
     { BOOST_TEST(false); }

   end example ]


# ------------------------------------------------------------------------------
# 3.10 Adding semantic to a test
# ------------------------------------------------------------------------------

1) Message description added to a test unit.

2) Decorator "description" attaches an arbitrary string to the test unit. 

3) [ Example 

     #define BOOST_TEST_MODULE decorator_09
     #include <boost/test/included/unit_test.hpp>
     namespace utf = boost::unit_test;

     BOOST_AUTO_TEST_CASE(test_1,
	* utf::disabled()
     	* utf::description("enable only when ODBC is available"))
     {
       BOOST_TEST(1 == 1);
     }

     BOOST_AUTO_TEST_CASE(test_2,
	* utf::description("descriptions ")
     	* utf::description("add up"))
     { BOOST_TEST(2 == 2); }


     Output

     > decorator_09 --list_content
     test_1 : enable only when ODBC is available
     test_2*: descriptions add up

   end example ]


#==============================================================================
# 3.11 Writing unit tests
#==============================================================================

1) A test case is a sequence of operations in which ASSERTIONS are inserted.

2) Finally reporting failures and/or information in a uniform manner,
   depending on the LOG LEVEL (*)

3) The toolbox supplied is in most part in a form of macro
   declarations. An (almost) unique interface to all of them
   implemented by the macro BOOST_TEST.

4) The granularity of the report depends on the current log level and
   report level.

5) NOTICE
   All macros arguments are calculated once, so it's safe to pass
   complex expressions in their place.

6) All tools automatically supply an error location: a file name and a
   line number, which can also be overridden.

7) WARNING
   The testing tools are intended for unit test code rather than
   library or production code, where throwing exceptions, using
   assert(), boost::concept_check or BOOST_STATIC_ASSERT() may be more
   suitable ways to detect and report errors.

8) List of testing tools (see [3.11.12])


#------------------------------------------------------------------------------
# 3.11.1 Assertion severity level
#------------------------------------------------------------------------------

Table 3.11.1 Assertions severity levels

===========================================================================
 Level     Test log content                    Errors           Test
                                               Counter          execution(**)
===========================================================================
 WARN(*)   warning in <test-case-name>:        not affected     continues
           condition <assertion
           description> is not satisfied 
---------------------------------------------------------------------------
 CHECK     error in <test-case-name>: test     increased        continues    
           <assertion description> failed 
---------------------------------------------------------------------------
 REQUIRE   fatal error in <test-case-name>:    increased        aborts
           critical test <assertion 
           description> failed 
===========================================================================

(*) This level of assertion can be used to validate aspects less
    important then correctness: performance, portability, usability, etc.

(**) Related to the current test case only. Hence "aborts" means that
     the current test case is aborted, but other test cases in the
     test tree are still executed.


#------------------------------------------------------------------------------
# 3.11.2 BOOST_TEST: universal and general purpose assertions
#------------------------------------------------------------------------------


	BOOST_TEST(statement);
	BOOST_TEST_<level>(statement, optional_modifiers)

	where level can be: WARN, CHECK, REQUIRE


1) WARNING
   To get all the functionalities of BOOST_TEST family of assertions,
   a C++11 capable compiler is required, especially supporting the
   auto and decltype keywords and the variadic macros. The
   documentation focuses on these set of compilers.

2) [ Example: BOOST_TEST overview

    BOOST_AUTO_TEST_CASE( test_macro_overview )
    {
      BOOST_TEST( a-boolean-expression );
      ...
    }

  end example ]

3) Complex Statements

   BOOST_TEST provides an enhanced reporting capability: additional details of 
   the failing operands and operations are provided in the log:

   [ Example: BOOST_TEST enhanced reporting

     BOOST_AUTO_TEST_CASE( test_op_reportings )
     {
      BOOST_TEST( a-boolean-expression );
      ...
     }

   end example ]


4) Limitations and workaround  [3_8]

   There are a few constructions that are however unsupported, but
   adding an extra parenthesis usually solves that 
   
   (i.e. BOOST_TEST((true || false));


#------------------------------------------------------------------------------
# 3.11.3 Reported information
#------------------------------------------------------------------------------

1) Default reporting:

   - the body of the statement that failed 
   - file: name & line 
   - test case: name

2) Custom messages:

   The BOOST_TEST macro let you override the default message by the
   use of a second argument: 

   BOOST_TEST(statement, "custom log message");


#------------------------------------------------------------------------------
# 3.11.4 Extended comparisons support
#------------------------------------------------------------------------------

# 3.11.4.1 Floating point comparison

  1) Enabling tolerance for user-defined types

  2) Tolerance-based comparisons

  3) Theory behind floating point comparisons

# 3.11.4.2 Strings and C-strings comparison

When type of the the pointers are char* or wchar_t*, BOOST_TEST promotes 
them as null terminated char arrays and string comparison is used.

# 3.11.4.3 Collections comparison

  See [3_1]

# 3.11.4.4 Bitwise comparison

WARNING This feature is not available for non C++11 compilers. 


#------------------------------------------------------------------------------
# 3.11.5 Exception correctness
#------------------------------------------------------------------------------

1) Any unexpected/uncaught exception raised in the test case body will
   be intercepted by the Boost.test framework and will result in the
   termination of the TEST-CASE with the status failed.

2) The Unit Test Framework provides several assertions for testing a
   code with respect to the exceptions correctness:

   BOOST_<level>_NO_THROW 

      checks that no exception is raised from an expression,
    
   BOOST_<level>_THROW 

      checks that an expression raises an exception of a specific type
    
   BOOST_<level>_EXCEPTION 

      checks that an expression raises an exception of a specific
      type, a passes the exception instance to a predicate function
      for further validation (introspection for instance)

3) WARNING
   An assert(...) might call abort(): the use of the macros above may
   not be suitable for testing for assert's in a portable manner.


#------------------------------------------------------------------------------
# 3.11.6 Time-out for test cases
#------------------------------------------------------------------------------

1) Decorator "timeout": specifies a time-out for a specific test
   case. If this time is exceeded the test case is forced to stop and
   is reported as failure.

2) [ Example

   #define BOOST_TEST_MODULE decorator_11
   #include <boost/test/included/unit_test.hpp>
   namespace utf = boost::unit_test;
   BOOST_AUTO_TEST_CASE(test1, * utf::timeout(2))
   {
   #ifdef BOOST_SIGACTION_BASED_SIGNAL_HANDLING
      for(;;) {}
      BOOST_TEST(true);
   #else
      BOOST_TEST(false);
   #endif
   }

   // Output
   > decorator_11
   Running 1 test case...
   unknown location(0): fatal error: in "test1": signal: SIGALRM
   (timeout while executing function)
   test.cpp(5): last checkpoint: "test1" entry.

   *** 1 failures is detected in test module "decorator_11"

   end example ]


3) WARNING Applied at test suite level, this decorator has no effect. 


#------------------------------------------------------------------------------
# 3.11.7 Expected failures specification
#------------------------------------------------------------------------------

1) CASE OF USE: we want to to temporarily allow a PARTICULAR TEST CASE to fail.

2) This feature allows specifying an expected number of failed
   assertions per test unit. The value is specified during test tree
   construction, and CAN NOT be updated during test execution.

3) WARNING
   If an assertion at fault is fixed and passed while an expected
   failures specification still present, the number of failures
   becomes smaller than expected. The test is going to be reported as
   passed; instead, a warning message will be issued.


# 3.11.7.1 Expected failure specification

1) The decorator "expected_failures" defines the number of assertions
   that are expected to fail within the corresponding test unit.

2) It is reported as failure when the number of failed assertions is
   greater than the declared expected number of failures. If the
   number of failed assertions is less than the number of expected
   failures a message is reported. The total number of expected
   failures for a given test suite S is the sum of the declared
   expected failures in S and the sum of expected failures in all
   nested test units

3) Example [3_1]


# 3.11.7.2 Usage with automatically registered test cases

WARNING
This usage is considered as deprecated. Please consider using the
expected_failures decorator instead.

For backwards compatibility, it is possible to indicate the expected
failures with BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES [15] before the
test case definition.

# 3.11.7.3 Usage with manually registered test cases

WARNING
Ddeprecated. Please consider using the expected_failures decorator instead.


#------------------------------------------------------------------------------
# 3.11.8 Custom predicate support
#------------------------------------------------------------------------------

1) CASE OF USE: in some cases you may want to implement and use custom
   predicate that perform complex check and produce intelligent report
   on failure.

2) There two layers of custom predicate support implemented by testing
   tools toolbox: with and without custom error message generation.

   - layer 1: Custom predicate support using BOOST_<level>_PREDICATE

   - layer 2: Custom predicate support using class
     	   boost::test_tools::predicate_result

[3_1] for details.


#------------------------------------------------------------------------------
# 3.11.9 Output streams testing tool
#------------------------------------------------------------------------------

1) GOAL: automatic testing std::ostream operations 
   (i.e. operator<< ( std::ostream &, ... ))

2) boost::test_tools::output_test_stream 

3) All output_test_stream validation member functions by default flush
   the stream once the check is performed. If you want to perform
   several checks with the same output, specify parameter flush_stream
   with value false [16].

# 3.11.9.1 Usage

1) Explicit output checks [3_1]

2) Pattern file matching  [3_1]


#------------------------------------------------------------------------------
# 3.11.10 BOOST_TEST: details on expressions
#------------------------------------------------------------------------------

Issue: It was already mentioned that the reporting is not symmetrical 

Goal: Fix this issue


#------------------------------------------------------------------------------
# 3.11.11 Debugging the assertions
#------------------------------------------------------------------------------

Goal: build the test suite to allow debugging.


#------------------------------------------------------------------------------
# 3.11.12 Summary of the API for writing tests
#------------------------------------------------------------------------------

1) Summary - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/testing_tools/summary.html

2) Reference API for writing tests

   BOOST_TEST
   expected_failures (decorator)
   timeout (decorator)
   tolerance (decorator)
   BOOST_<level>
   BOOST_<level>_BITWISE_EQUAL
   BOOST_<level>_EQUAL
   BOOST_<level>_EQUAL_COLLECTIONS
   BOOST_<level>_CLOSE
   BOOST_<level>_CLOSE_FRACTION
   BOOST_<level>_GE
   BOOST_<level>_GT
   BOOST_<level>_LE
   BOOST_<level>_LT
   BOOST_<level>_MESSAGE
   BOOST_<level>_NE
   BOOST_<level>_PREDICATE
   BOOST_<level>_NO_THROW
   BOOST_<level>_THROW
   BOOST_<level>_EXCEPTION
   BOOST_<level>_SMALL
   BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES
   BOOST_ERROR
   BOOST_FAIL
   BOOST_IS_DEFINED
   BOOST_TEST_TOOLS_UNDER_DEBUGGER
   BOOST_TEST_TOOLS_DEBUGGABLE


#------------------------------------------------------------------------------
# 3.A Unit Test Framework API reference [3_A_1]
#------------------------------------------------------------------------------

# 3.A.1 Build scenarios and behaviors

#  BOOST_TEST_MODULE

  - (The same as BOOST_MAIN)):

  1) Creates stub for test module initialization (the main function)

  2) WARNING Must be defined before "#include <boost/test/unit_test.hpp>"

  3) WARNING Must be defined exactly for one compilation unit of your
     	     test module

  - Plus: 

  4) Defines the name defines the name of the master test suite.
     This name can include spaces and does not need to be wrapped in quotes.


# BOOST_TEST_DYN_LINK

  1) Define this flag to link against the Unit Test Framework shared library.

  2) Note.- The same flag is used for the Unit Test Framework and the
    /Program Execution Monitor components.


# BOOST_TEST_NO_MAIN         // required

  1) Prevents the auto generation of the test module initialization
     functions (bool init_unit_test() is required)
   
  2) WARNING This macro is particularly relevant for manually registered tests 
     	     in conjunction with dynamic variant of the Unit Test Framework.

  3) When defined, a main function registering all the tests should be
     implemented.



# 3.A.2 Tests declaration and organization

# BOOST_AUTO_TEST_CASE

  1) Declares and registers automatically a (named) test case.
     (see 3.4.1.1 Automated registration)






\todo
# 3.1.4 Checking error macros


# 3.1.4.1 BOOST_TEST macros

1) WARNING Avaliable since boost 1.59 version.

  BOOST_TEST // or BOOST_TEST_CHECK
  BOOST_TEST_REQUIRE
  BOOST_TEST_WARN

  Warning
  To get all the functionalities of BOOST_TEST family of assertions, a
  C++11 capable compiler is required
  
  \doc http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/testing_tools/boost_test_universal_macro.html


    3.2.1) BOOST_CHECK macros

     	     BOOST_CHECK
	     BOOST_CHECK_EQUAL
	     BOOST_CHECK_MESSAGE
	     ...

	     a) Check if an error occurs
	     b) Behavior on error: shows and error message and continues

    3.2.2) BOOST_REQUIRE macros

    	   BOOST_REQUIRE
	   ...

	   a) Check if an error occurs
	   b) Behavior on error: throws an exception

3.3) Non-checking error macros

     a) The code to check the error must be explicit (i.e. if(1==2) )

     Then, the macro handle the error:

     3.3.1) BOOST_ERROR

	    b) Behavior on error: shows and error message and continues

     3.3.1) BOOST_FAIL

	    b) Behavior on error: shows and error message throws an exception


2) Quick example

   [ Example  [k3_1]

   #define BOOST_TEST_MODULE BoostTestHowto
   #include <boost/test/unit_test.hpp>

   int add( int i, int j ) { return i+j; }

   BOOST_AUTO_TEST_CASE( my_test )
   {
    // seven ways to detect and report the same error:
    BOOST_CHECK( add( 2,2 ) == 4 );        // #1 show msg & continues on error

    BOOST_REQUIRE( add( 2,2 ) == 4 );      // #2 throws on error

    if( add( 2,2 ) != 4 )
      BOOST_ERROR( "Ouch..." );            // #3 continues on error

    if( add( 2,2 ) != 4 )
      BOOST_FAIL( "Ouch..." );             // #4 throws on error

    if( add( 2,2 ) != 4 ) throw "Ouch..."; // #5 throws on error

    BOOST_CHECK_MESSAGE( add( 2,2 ) == 4,  // #6 continues on error
       "add(..) result: " << add( 2,2 ) );

    BOOST_CHECK_EQUAL( add( 2,2 ), 4 );	  // #7 continues on error
   } 

   end example ]


# 3.B Frequently Asked Questions

# Q) How to create test case using the Unit Test Framework?

  BOOST_AUTO_TEST_CASE( test_function );

# Q) How to create test suite using the Unit Test Framework?

  BOOST_AUTO_TEST_SUITE( suite_name );

# Q) Linker error: Unresolved external init_unit_test_suite(int, char**).

  The reason for this error is that in your implementation you should
  specify second argument of init_unit_test_suite exactly as in the
  specification, i.e.: char* [].

# Q) How can I redirect testing output?

  unit_test_log::instance().set_log_output( std::ostream & )

# Q) I want different default log trace level

  Use environment variable BOOST_TEST_LOG_LEVEL to define desired log trace 
  level. You still will be able to reset this value from the command line.

# Q) How to set up a CMake project using Unit Test Framework (extended)

  See [3_1]


# ------------------------------------------------------------------------------
# 3.??? Practical usage recommendations
# ------------------------------------------------------------------------------

# 3.???.1 Generic usage recommendations

[doc] http://www.boost.org/doc/libs/1_50_0/libs/test/doc/html/utf/usage-recommendations/generic.html

1) Prefer offline compiled libraries to the inline included components (3.2)

2) If you use only free function based test cases advance to the
   automatic registration facility

3) To find location of first error reported by test tool within reused
   template function, use special hook within framework headers.

4) To test reusable template base component with different template
   parameter use test case template facility.

5) Prefer BOOST_CHECK_EQUAL to BOOST_CHECK



# ==============================================================================
# Appendix C - cmake file example
# ==============================================================================

//!\file boost_projectname.cmake
//
// importing boost libraries


IF( NOT boost_projectname.cmake )

SET ( boost_projectname.cmake TRUE)

  #Boost framework configuration

  #After installing boost libraries manually this directory
  #should exist
  SET (BOOST_ROOT $ENV{PROJECTNAME_HOME}/toolbox/boost_dist)
  SET (BOOST_INCLUDE_PATH ${BOOST_ROOT})
  SET (BOOST_LIBS_PATH ${BOOST_ROOT}/stage/lib)

  ADD_LIBRARY(boost_unit_test_framework STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_unit_test_framework PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_unit_test_framework.a)

  ADD_LIBRARY(boost_thread STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_thread PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_thread.a)

  ADD_LIBRARY(boost_chrono STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_chrono PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_chrono.a)

  ADD_LIBRARY(boost_system STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_system PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_system.a)

  ADD_LIBRARY(boost_filesystem STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_filesystem PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_filesystem.a)

  ADD_LIBRARY(boost_program_options STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_program_options PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_program_options.a)

  #ADD_LIBRARY(boost_log_setup STATIC IMPORTED)
  #SET_TARGET_PROPERTIES(boost_log_setup PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_log_setup.a)

  ADD_LIBRARY(boost_log STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_log PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_log.a)
  
  ADD_LIBRARY(boost_date_time STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_date_time PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_date_time.a)

  ADD_LIBRARY(boost_serialization STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_serialization PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_serialization.a)
    
  ADD_LIBRARY(boost_regex STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_regex PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_regex.a)
    
  ADD_LIBRARY(boost_iostreams STATIC IMPORTED)
  SET_TARGET_PROPERTIES(boost_iostreams PROPERTIES IMPORTED_LOCATION ${BOOST_LIBS_PATH}/libboost_iostreams.a)

  INCLUDE_DIRECTORIES(${BOOST_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR})


ENDIF(NOT boost_projectname.cmake )



# ==============================================================================
# Appendix K - Code examples (../code_examples)
# ==============================================================================

# source path for boost test:  "../code_examples/boost/"


# Init to boost library, "../code_examples/boost/1_init_boost/"

[k1] Build a Simple Program Using Boost - ./simple_example


# smart pointer library, "../code_examples/boost/2_smart_pointers/"

[k2_1] shared_ptr example - ./basic_examples/

[k2_2] shared_array example - ./basic_examples/

[k2_3] shared_ptr used as a shared_array - ./basic_examples/

[k2_4] boost::make_shared - ./basic_examples/

[k2_5] boost::shared_ptr optimization with macros - ./basic_examples/

[k2_6] boost::ptr_vector - ./basic_examples/

[k2_7] boost::ptr_set - ./basic_examples/

[k2_8] container inserter - ./basic_examples/


# test library, "../code_examples/boost/3_test/"

[k3_1] Basic detect and report error detection - ./3_1_basic/
[k3_2] Shared library usage variant - ./3_2_usage_variants/3_2_3_shared_lib/
[k3_3] decorators - ./3_5_decorators/
[k3_4] Single test case fixture with BOOST_FIXTURE_TEST_CASE - 
	./3_6_fixtures/3_6_2_1_single_test_case_with_BOOST_FIXTURE_TEST_CASE/
[k3_5] Fixture for a complete subtree - ./3_6_fixtures/3_6_2_3_subtree
[k3_6] Enabling/disabling test execution - 
       ./3_9_test_execution/3_9_1_unconditional_run_status




# ==============================================================================
# Appendix Z - References
# ==============================================================================

# ------------------------------------------------------------------------------

[1] General doc

[1_1] Official website - http://www.boost.org/

[1_1_1] Getting started - http://www.boost.org/doc/libs/1_64_0/more/getting_started/unix-variants.html

[1_2] Boost book the boost cpp libraries - https://theboostcpplibraries.com/

# ------------------------------------------------------------------------------

[2] Smart pointer library

[2_1] Official website - http://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/smart_ptr.htm

[2_2] theboostcpplibraries sole ownership - https://theboostcpplibraries.com/boost.smartpointers-sole-ownership

[2_3] theboostcpplibraries shared ownership - https://theboostcpplibraries.com/boost.smartpointers-shared-ownership

# ------------------------------------------------------------------------------

[3] Test library

[3_1] Boost.test official doc - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/index.html

[3_2] Select the desired test feature - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/intro/how_to_read.html

[3_3] Shared-library variant customizations - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/adv_scenarios/shared_lib_customizations.html

[3_4] Test cases without parameters - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_organization_nullary.html

[3_5] Data-driven test cases - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_case_generation.html

[3_6] Template test cases - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_organization_templates.html

[3_7] Decorators list (API) - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/tests_organization/summary_of_the_api_for_declaring.html

[3_8] Limitations and workaround - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/testing_tools/internal_details.html



[3_A_1] Test library API - http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/boost_test/utf_reference.html


[3_100] Special section dedicated to manual registration: WHY we need this?

[3_100_1] When/Why to use manual registration in Boost Test library? - http://stackoverflow.com/questions/11860310/when-to-use-manual-registration-in-boost-test-library
