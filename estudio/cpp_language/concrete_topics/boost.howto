# ==============================================================================
# Summary
#
# (following the order in the c++ standard [1_1]; except chapter 14,
#  following [3_102])
# 
# ==============================================================================

# 1 Getting Started
#
# 1.1 The Boost Distribution
# 1.2 Header-Only Libraries
# 1.3 Build a Simple Program Using Boost
# 1.4 Prepare to Use a Boost Library Binary
# 1.5 Link Your Program to a Boost Library


# 2 Smart Pointers
#
# 2.1 Sole Ownership (boost::scoped_ptr)
#     2.1.1 scoped_ptr FAQ
#
# 2.2 Shared Ownership (boost::shared_ptr)
#     2.2.1 user-defined deleter
#     2.2.2 Using boost::shared_array
#     2.2.3 Using boost::make_shared
#     2.2.4 boost::shared_ptr with BOOST_SP_USE_QUICK_ALLOCATOR
#
# 2.3 Special Smart Pointers
#     2.3.1 bosst::weak_ptr
#     2.3.2 boost::intrusive_ptr
#
# 2.4 Boost.PointerContainer
#     2.4.2 boost::ptr_vector
#     2.4.2 boost::ptr_set
#     2.4.3 Inserters for boost containers

# Appendix K - Code examples (./code_examples)
#

# Appendix Z - References
#

# ==============================================================================



# ==============================================================================
# 1 Getting Started
# ==============================================================================

# 1.1 The Boost Distribution

# boost path

The path to the boost root directory (often /usr/local/boost_1_64_0)
is sometimes referred to as $BOOST_ROOT.

   >>echo $BOOST_ROOT
   /home/swim/development/SWIS_root/toolbox/boost_dist


# 1.2 Header-Only Libraries

WARNING
The only Boost libraries that must be built separately are (see [1_1_1])


# 1.3 Build a Simple Program Using Boost [k1]

HINT 
All of Boost's header files have the .hpp extension

    #include <boost/whatever.hpp>

    or

    #include "boost/whatever.hpp"


# compilation

  >> c++ -I path/to/boost_1_64_0 example.cpp -o example

  (i.e. c++ -I $BOOST_ROOT example.cpp -o example)



# 1.4 Prepare to Use a Boost Library Binary

If you want to use any of the separately-compiled Boost libraries,
you'll need to acquire library binaries. (see [1_1_1] for details)


# 1.5 Link Your Program to a Boost Library

Similar to STL:
	# LDFLAGS: flags (i.e -g), and library paths (i.e. -L path-lib)
	# LDLIBS:  library names: (i.e. LDIBS="-lncurses -lm -lsdl")

See [1_1_1] for details.



# ==============================================================================
# 2 Smart Pointers
# ==============================================================================

# 2.1 Sole Ownership (boost::scoped_ptr, boost::scoped_array) [2_2]

#include <boost/scoped_ptr.hpp>   // for pointers to single objects
#include <boost/scoped_array.hpp> // for pointers to arrays

1) boost::scoped_ptr is a smart pointer that is the sole owner of a
   dynamically allocated object.

2) boost::scoped_ptr cannot be copied or moved.

3) boost::scoped_ptr require that T be a complete type at destruction
   time. [2_1]


4) Using boost::scoped_ptr

   [ Example

   #include <boost/scoped_ptr.hpp>
   #include <iostream>

   int main()
   {
    boost::scoped_ptr<int> p{new int{1}};
    std::cout << *p << '\n';
    p.reset(new int{2});
    std::cout << *p.get() << '\n';
    p.reset();
    std::cout << std::boolalpha << static_cast<bool>(p) << '\n';
   }

   end example ]


# 2.1.1 scoped_ptr FAQ [2_1]

FAQ Are there any advantages of boost::scoped_ptr over std::unique_ptr? 
    Shall one always prefer the latter while coding on c++11?

    >>> If you see a boost::scoped_ptr in someone's code, you know
        immediately that the object it owns isn't used outside of the
        current scope. If you see a std::unique_ptr, you have to look
        further to find out whether ownership is transferred and the
        object is used outside of the current scope. (If you know that
        this other developer knows both boost::scoped_ptr and
        std::unique_ptr, you can deduce that std::unique_ptr means
        that ownership will be transferred - otherwise he would have
        used boost::scoped_ptr.)


FAQ Are *p and *p.get() essentially equivalent?

    >>> That's correct. Two minor differences: get() is noexcept, and
        operator* checks with BOOST_ASSERT whether the pointer is not 0.


# ------------------------------------------------------------------------------
# 2.2 Shared Ownership (boost::shared_ptr) [2_3] [2_1] 
# ------------------------------------------------------------------------------

#include <boost/shared_ptr.hpp>

1) Similar to scoped_ptr BUT boost::shared_ptr is not necessarily the
   exclusive owner of an object. Ownership can be shared with other
   smart pointers of type boost::shared_ptr

2) The shared object is not released until the last copy of the shared
   pointer referencing the object is destroyed.

    reset(): decrements the counter of owners
    	     IF (counter == 0) THEN object destroyed ENDIF

3) BECAUSE it can share ownership, the smart pointer can be copied, 

4) Shared_ptr does not require that T be a complete type at
   destruction time. [2_1]

5) Using boost::shared_ptr 
   
   [ Example [k2_1]

     include <boost/shared_ptr.hpp>
     #include <iostream>

     int main()
     {
       boost::shared_ptr<int> p1{new int{1}};
       std::cout << *p1 << '\n';
       boost::shared_ptr<int> p2{p1};    // (*1)
       p1.reset(new int{2});  	       // (*2)
       std::cout << *p1.get() << '\n';
       p1.reset();
       std::cout << std::boolalpha << static_cast<bool>(p2) << '\n';
     }

   end example ]

   // (*1) p1 and p2 share THE SAME object

   // (*2) p1 is no longer an owner of the object, but p2 still is =>
   // 	   object not destroyed

6) Operators

   get()    retrieve the currently stored address
   reset()  store a new address


   Like boost::scoped_ptr, boost::shared_ptr overloads:

   operator bool():  return false if the pointer is NULL
   operator*():      and checks whether the pointer is not 0. (see 2.1.1)
   operator->()

7)  A non-initialized shared pointer is like a NULL pointer:

    [ Example:  boost::shared_ptr<int> p; cout << p ; // 0   end example ]


# 2.2.1 user-defined deleter

   As a second parameter, a deleter can be passed to the constructor
   of boost::shared_ptr. The deleter must be a function or function
   object that accepts as its sole parameter a pointer of the type
   boost::shared_ptr was instantiated with. The deleter is called in
   the destructor instead of delete. This makes it possible to manage
   resources other than dynamically allocated objects in a boost::shared_ptr.

   (see [3_2])


# 2.2.2 Using boost::shared_array

1) Operators
 
   get()
   reset()
   operator[] 
   operator bool()

 \warning operator*() and operator->() are not overloaded.


2) Using boost::shared_array 

   [ Example [k2_2]

      #include <boost/shared_array.hpp>
      #include <iostream>

      int main()
      {
        boost::shared_array<int> p1{new int[1]};
  	{
	  boost::shared_array<int> p2{p1};
    	  p2[0] = 1;
  	}
  	std::cout << p1[0] << '\n';
      }

   end example ]


3) NOTICE Since Boost 1.53.0, boost::shared_ptr is an alternative to
   	  boost::shared_array: [k2_3]

   Since Boost 1.53.0, boost::shared_ptr supports single objects and
   arrays and detects whether it has to release resources with delete
   or delete[]. Because boost::shared_ptr also overloads operator[]
   (since Boost 1.53.0), this smart pointer is an alternative for
   boost::shared_array.

   \bug [k2_3] compilation error upon trying operator[] with Boost
   	1.59.0 and C++98. \todo Try with more modern versions.

4) \bug shared_array allows out_of_bounds indexing [k2_2]

   [ Example     
   
     boost::shared_array<int> p1(new int[2]);
     p1[0]=0; p1[1]=1;
     p1[100]=77;                    // accepted!!
     std::cout << p1[100] << '\n';  // prints 77
     std::cout << p1[2] << '\n';    // prints 0
   
   end example ]

5) \warning No length operator available. The size of the pointed
   array must be manually managed.


# 2.2.3 Using boost::make_shared

1) The advantage of boost::make_shared() is that the memory for the
   object that has to be allocated dynamically and the memory for the
   reference counter used by the smart pointer internally can be
   reserved in one chunk (boost::shared_ptr requires two calls).

2) You can use boost::make_shared() for arrays, too.

   [ Example [k2_4]

   #include <boost/make_shared.hpp>
   #include <typeinfo>
   #include <iostream>
   int main()
   {
    auto p1 = boost::make_shared<int>(1);
    std::cout << typeid(p1).name() << '\n';

    //!\error with Boost 1.59.0 and C++98. \todo Try with more modern versions.
    auto p2 = boost::make_shared<int[]>(10);
    std::cout << typeid(p2).name() << '\n';
   }

   end example ]


# 2.2.4 boost::shared_ptr optimization with macros

1) Boost.SmartPointers supports macros to optimize the behavior of the
   smart pointers. 

   Idea behind: using macros => boost::shared_ptr >> std::shared_ptr

2) macro BOOST_SP_USE_QUICK_ALLOCATOR to activate an allocator shipped
   with Boost.SmartPointers. This allocator manages memory chunks to
   reduce the number of calls to new and delete for reference counters.


   \warning In my test (see [k2_5]), the results are not the expected:
   better without the optimization macro.


   [ Example [k2_5]

   // measure the time of a loop (computer dependent)

   // the example may run faster with BOOST_SP_USE_QUICK_ALLOCATOR than without
   
   #define BOOST_SP_USE_QUICK_ALLOCATOR
   #include <boost/shared_ptr.hpp>
   #include <iostream>
   #include <ctime>

   int main()
   {
     boost::shared_ptr<int> p;
     std::time_t then = std::time(nullptr);
     for (int i = 0; i < 1000000; ++i)
     	 p.reset(new int{i});
     std::time_t now = std::time(nullptr);
     std::cout << now - then << '\n';
   }

   end example ]

3) The names of the macros start with BOOST_SP_
   (i.e. BOOST_SP_ENABLE_DEBUG_HOOKS)


# 2.3 Special Smart Pointers

# 2.3.1 bosst::weak_ptr

1) Why it is needed?

   Problem: 

   We need to use an existing object (avoid using a pointer already destroyed)
   BUT  
   without having any impact on the lifetime of the object (avoid new
   references to the object).


   Solution: boost::weak_ptr 

   boost::weak_ptr makes sense whenever a function is expected to work
   with an object managed by a shared pointer, but the lifetime of the
   object does not depend on the function itself. The function can
   only use the object as long as it is owned by at least one shared
   pointer somewhere else in the program. In case the shared pointer
   is reset, the object cannot be kept alive because of an additional
   shared pointer inside the corresponding function.

   In the example bellow, we only want to print while the actual pointer exists.

  [ Example

    #include <boost/shared_ptr.hpp>
    #include <boost/weak_ptr.hpp>
    #include <thread>
    #include <functional>
    #include <iostream>

    void reset(boost::shared_ptr<int> &sh)
    {
	sh.reset();
    }

    void print(boost::weak_ptr<int> &w)
    {
	boost::shared_ptr<int> sh = w.lock();
  	if (sh)
    	   std::cout << *sh << '\n';
    }

    int main()
    {
      boost::shared_ptr<int> sh{new int{99}};
      boost::weak_ptr<int> w{sh};
      std::thread t1{reset, std::ref(sh)};
      std::thread t2{print, std::ref(w)};
      t1.join();
      t2.join();
    }

   end example ]

2) boost::weak_ptr must be initialized with a boost::shared_ptr. 

3) Its most important member function is lock(). lock() returns a
   boost::shared_ptr that shares ownership with the shared pointer
   used to initialize the weak pointer.

4) In case the shared pointer is empty, the returned pointer will be
   empty as well.


# 2.3.2 boost::intrusive_ptr

1) In general, boost::intrusive_ptr works the same as
   boost::shared_ptr. However, while boost::shared_ptr keeps track of
   the number of shared pointers referencing a particular object, the
   developer has to do this when using boost::intrusive_ptr. This can
   make sense if other classes already keep track of references.

   See example on [1_2]


# 2.4 Boost.PointerContainer

1) The library Boost.PointerContainer provides containers specialized
   to manage dynamically allocated objects. 

   Similar to C++11's std::vector<std::unique_ptr<int>>. However, the
   containers from Boost.PointerContainer can provide some extra comfort.

2) Available containers (they correspond to std containers)
   
   boost::ptr_vector
   boost::ptr_set
   boost::ptr_deque
   boost::ptr_list
   boost::ptr_map
   boost::ptr_array
   boost::ptr_unordered_set
   boost::ptr_unordered_map 


# 2.4.1 boost::ptr_vector

1) because boost::ptr_vector knows that it stores dynamically
   allocated objects, member functions like back() return a reference
   to a dynamically allocated object and not a pointer.

  [ Example [k2_6]

    #include <boost/ptr_container/ptr_vector.hpp>
    #include <iostream>

    int main()
    {
     boost::ptr_vector<int> v;
     v.push_back(new int{1});
     v.push_back(new int{2});
     std::cout << v.back() << '\n';  // prints 2
    }

  end example ]


# 2.4.2 boost::ptr_set

1) "boost::ptr_set" VS "std::set": with boost::ptr_set, the order of
   the elements depends on the int values, not on the pointers.

  [ Example [k2_7]

    #include <boost/ptr_container/ptr_set.hpp>
    #include <iostream>

    int main()
    {
     boost::ptr_set<int> s;
     s.insert(new int{2});
     s.insert(new int{1});
     std::cout << *s.begin() << '\n';
    }

  end example ]

2) HINT To make std::set sort the elements based on int values, the
   container must be told how to compare elements. (i.e. via
   boost::indirect_fun provided by Boost.PointerContainer)

  [ Example

    #include <boost/ptr_container/ptr_set.hpp>
    #include <boost/ptr_container/indirect_fun.hpp>
    #include <set>
    #include <memory>
    #include <functional>
    #include <iostream>

    int main()
    {
     std::set<std::unique_ptr<int>, boost::indirect_fun<std::less<int>>> v;
     v.insert(std::unique_ptr<int>(new int{2}));
     v.insert(std::unique_ptr<int>(new int{1}));
     std::cout << **v.begin() << '\n';
    }

  end example ]


# 2.4.3 Inserters for boost containers

1) Boost.PointerContainer provides inserters for its containers. 

2) Defined under  #include <boost/ptr_container/ptr_inserter.hpp>

3) Available of inserters

   boost::ptr_container::ptr_back_inserter()
   boost::ptr_container::ptr_front_inserter()
   boost::ptr_container::ptr_inserter()

4) boost::ptr_container::ptr_back_inserter() example
   
   This function creates an inserter of type
   boost::ptr_container::ptr_back_insert_iterator

   The inserter creates copies with new on the heap and adds the
   addresses to the container.

  [ Example [k2_8]

    #include <boost/ptr_container/ptr_vector.hpp>
    #include <boost/ptr_container/ptr_inserter.hpp>
    #include <array>
    #include <algorithm>
    #include <iostream>

    int main()
    {
     boost::ptr_vector<int> v;

     //[C++11]
     std::array<int, 3> a{{0, 1, 2}};
     std::copy(a.begin(), a.end(), boost::ptr_container::ptr_back_inserter(v));
     //[C++03]
     // int a[3] = {0, 1, 2};
     // std::copy(a, a+3, boost::ptr_container::ptr_back_inserter(v));

     std::cout << v.size() << '\n';
    }

  end example ]



# ==============================================================================
# Appendix K - Code examples (./code_examples)
# ==============================================================================

# source path for boost test ("./" from this point):  "./code_examples/boost/"


# Init to boost library ./1_init_boost/

[k1] Build a Simple Program Using Boost - ./simple_example


# smart pointers, "./code_examples/boost/2_smart_pointers

[k2_1] shared_ptr example - basic_examples/

[k2_2] shared_array example - basic_examples/

[k2_3] shared_ptr used as a shared_array - basic_examples/

[k2_4] boost::make_shared - basic_examples/

[k2_5] boost::shared_ptr optimization with macros - basic_examples/

[k2_6] boost::ptr_vector - basic_examples/

[k2_7] boost::ptr_set - basic_examples/

[k2_8] container inserter - basic_examples/


# ==============================================================================
# Appendix Z - References
# ==============================================================================

# ------------------------------------------------------------------------------

[1] General doc

[1_1] Official website - http://www.boost.org/

[1_1_1] Getting started - http://www.boost.org/doc/libs/1_64_0/more/getting_started/unix-variants.html

[1_2] Boost book the boost cpp libraries - https://theboostcpplibraries.com/

# ------------------------------------------------------------------------------

[2] Smart pointers

[2_1] Official website - http://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/smart_ptr.htm

[2_2] theboostcpplibraries sole ownership - https://theboostcpplibraries.com/boost.smartpointers-sole-ownership

[2_3] theboostcpplibraries shared ownership - https://theboostcpplibraries.com/boost.smartpointers-shared-ownership

# ------------------------------------------------------------------------------

