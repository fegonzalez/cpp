# ==============================================================================
# Summary
#
# (following the order in the c++ standard [1_1]; except chapter 14,
#  following [3_102])
# 
# ==============================================================================

# 0 The (C++) standard
#

# 1 General
#
# 1.1 Scope
# 1.7 The C++ memory model
# 1.8 The C++ object model
# 1.9 Program execution
#  1.10 Multi-threaded executions and data races


# 2 Lexical conventions
#
# 2.1 Separate translation
# 2.2 Phases of translation
# 2.3 Character sets
# 2.4 Preprocessing tokens
# 2.5 Alternative tokens
# 2.6 Tokens
# 2.7 Comments
# 2.8 Header names
# 2.9 Preprocessing numbers
# 2.10 Identifiers
# 2.11 Keywords
# 2.12 Operators and punctuators
# 2.13 literals
#      2.13.1 Kinds of literals
#      2.13.2 integer-literal
#      2.13.3 character-literal
#      2.13.4 floating-literal
#      2.13.5 string-literal
#      2.13.6 boolean-literal
#      2.13.7 pointer-literal
#      2.13.8 user-defined-literal


# 3 Basic concepts
#
# 3.1 Declarations and definitions
#
# 3.2 One-definition rule
#     3.2.1 One-per-Program Constraints
#     3.2.2 One-per-Translation Unit Constraints
#     3.2.3 Cross-Translation Unit Equivalence Constraints

# 3.3 Scope
#     3.3.1 Declarative regions and scopes
#     3.3.2 Point of declaration
#     3.3.3 Block scope
#     3.3.4 Function prototype scope
#     3.3.5 Function scope
#     3.3.6 Namespace scope
#     	    3.3.6.1 (Translation unit) local scope or internal linkage
#     	    3.3.6.2 Global scope & global names
#     3.3.7 Class scope
#     3.3.8 Enumeration scope

# \todo # 3.3.9 Template parameter scope

#     3.3.10 Name hiding
#
# 3.4 Name lookup
#     3.4.1 Unqualified name (Appendix T) lookup
#     3.4.2 Argument-dependent name lookup
#     3.4.3 Qualified name lookup
#     	    3.4.3.1 Class members
# 	    3.4.3.2 Namespace members
#     3.4.4 Elaborated type specifiers
#     3.4.5 Class member access
#     3.4.6 Using-directives and namespace aliases [basic.lookup.udir]
#
# 3.5 Program and linkage
#

# \todo # 3.6 Start and termination
# \todo # 3.7 Storage duration
# \todo # 3.8 Object lifetime
#
# 3.9 Types
#     3.9.1 Fundamental (built-in) types
#           3.9.1.1 Integral types
#           3.9.1.2 Arithmetic types
#           3.9.1.3 Scalar types
# \todo # 3.9.2 Compound types
#     3.9.3 CV-qualifiers
#     3.9.4 Types not defined in the standard
#           3.9.4.1 TrivialType
#           3.9.4.2 StandardLayoutType
#           3.9.4.3 PODType
#
# \todo # 3.10 Lvalues and rvalues
# \todo # 3.11 Alignment


# \todo # 4 Standard conversions
#
# \todo # 4.1 Explicit conversions
#
# 4.2 Implicit conversions
#     4.2.1 Order of the conversions
#     4.2.2 Implicitly convertible expression
#     4.2.3 \todo Contextual conversions
#     4.2.4 \todo Value transformations
#
# \todo 4.3 User-defined conversions
#
# \todo 4.4 cpp standard chapter 4


# \todo # 5 Expressions
#
# 
# 5.2 Postfix expressions
#     
# \todo    5.2.7 Dynamic cast
# \todo    5.2.8 Type identification
# \todo    5.2.9 Static cast
# \todo    5.2.10 Reinterpret cast
# \todo    5.2.11 Const cast



# \todo # 6 Statements
#
# 6.5 Iteration statements


# \todo # 7 Declarations
#
# \todo # 7.1 Specifiers
# \todo    7.1.1 Storage class specifiers
#     	    7.1.1.1 extern (Appendix T)
# \todo    7.1.2 Function specifiers
#     	    7.1.2.1 inline

# \todo # 8 Declarators
#
# 8.3 Meaning of declarators
#
#     8.3.3 Pointers to members
#
#
# 8.5 Initializers
#
#     8.5.0 Initialiation before C++11	
#	
#     8.5.1 Aggregates
#
#     8.5.2 Character arrays
#
#     8.5.3 References
#	    8.5.3.1 Uses of references
#	    8.5.3.2 Issues on using references
#	    8.5.3.3 Defining (binding) references to objects
#	    8.5.3.4 References as functions parameters
#	    8.5.3.5 functions returning references
#       \todo Rvalue References [3_1].13.6.1.  (see examples at [4_2_0])
#       \todo std::ref
#
#     8.5.4 List-initialization (or braced-init-list)
#
#     8.5.5 Class Member Initialization (or In-Class Initializers)


# \todo # 9 Classes
#


# \todo # 10 Derived classes
#
#   10.3 Virtual functions
#   	10.3.1 Calling virtual member functions vs calling non-virtual members
# 	10.3.2 virtual table & virtual pointer: resolving dynamic binding
#
#	10.3.10 Virtual functions FAQ   \todo


# 11 Member access control
#
# 11.1 Access specifiers
# 11.2 Accessibility of base classes and base class members
# 11.3 Friends
# 11.4 Protected member access
# 11.5 Access to virtual functions
# 11.6 Multiple access
# 11.7 Nested classes


# \todo # 12 Special member functions
#
# 12.1 Constructors
#      12.1.1 Trivial Constructors
#      12.1.2 Non-Trivial Constructors
# 	      a) Default constructor
# 	      b) Converting Constructor
# 	      c) Explicit Constructor
#	      d) Constructors of Built-in Types (char, int, ...)
# 	      e) Member Initialization Lists
# 	      f) Copy constructor 
#	      g) CV-qualifiers on constructors  \todo test me

# \todo # 12.1.3 Initialization order
#
#	      \todo [C++11] Delegating Constructors [3_1] 7.5.2., p 378
#       \todo [C++11] constexpr Constructors [3_1] 7.5.6. Literal Classes, p 387
#	      	      			     [1_1] 7.1.5
# 	      \todo [3_1] 15.7 Constructors and Copy Control (p. 768),
# 	      \todo [3_1] 18.1.3 Function try Blocks and Constructors (p. 953),
# 	      \todo [3_1] Chapter 13. (p. 615)
#
#	12.1.4 Constructors FAQ
# 	      FAQ return-by-value
# 	      FAQ The “static initialization order fiasco”
#
#   todo 12.4 Destructors 
#   	12.4.1 Destruction order
#
#   todo 12.5 Free store
#
#   todo 12.6 initialization
#
#   todo 12.7 Construction and destruction
#
#   12.8 Copying and moving class objects
#       12.8.1 copy-constructor & assignment-operator
# \todo #       12.8.2 move-constructor & move-operator


# \todo # 13 Overloading
#
# 13.5 Overloaded operators
#      13.5.1 Unary operators
#      13.5.2 Binary operators
#      13.5.3 operator= assignment operator
#      13.5.4 operator()  function call, or call operator
#      13.5.5 operator[]  Subscripting 
#      13.5.6 operator->  Class member access
#      13.5.7 operator++  operator--  Increment and decrement
#      13.5.8 User-defined literals
#
# 13.6 Built-in operators


# \todo # 14 Templates
#
# 14.1 Function Templates
#      14.1.1 Defining the template
#      14.1.2 Using the template
#      14.1.3 Argument deduction
#      14.1.4 Template Parameters
#      14.1.5 Overloading Function Templates
#
# 14.2 Class Templates
#      14.2.1 Declaration of Class Templates
#      	      14.2.1.1 Type and Name
#      14.2.2 Implementation (definition) of Member Functions
#      14.2.3 Use (instantiation) of Class Templates
#      14.2.4 (Explicit) Specializations of Class Templates
#      14.2.5 Partial specialization
#      14.2.6 Template Arguments
#      14.2.7 Default Template Arguments
#
# 14.3 Nontype Template Parameters
#      14.3.1 Nontype Class Template Parameters
#      14.3.2 Nontype Function Template Parameters
#      14.3.3 Restrictions for Nontype Template Parameters
#
# 14.4 Tricky Basics
#      14.4.1 Keyword Typename
#      	      14.4.1.1 The `.template' Construct
#      14.4.2 Using this->
#      14.4.3 Member Template
#      14.4.4 Template Template Parameters
#      14.4.5 Zero Initialization
#      14.4.6 Using string literals as Arguments for Function Templates
#
# 14.5 Using Templates in Practice
#      14.5.1 The Inclusion Model
#      	      14.5.1.1 Linker Errors
#      14.5.1.2 Templates in Header Files
#      14.5.2 Explicit Instantiation
#      	      14.5.2.1 Example of Explicit Instantiation
# 	      14.5.2.2 Combining the Inclusion Model and Explicit Instantiation
#      14.5.3 The Separation Model
#      14.5.4 Templates and inline
#      14.5.5 Precompiled Headers
#      14.5.6 Debugging Templates
# 	      14.5.6.1 Tracers
# 	      14.5.6.2 Oracles
# 	      14.5.6.3 Archetypes
#
# 14.6 Basic Template Terminology
#      14.6.1 Template Arguments versus Template Parameters
#
# 14.7 Friends



# todo 15 Exception handling

# todo 16 Preprocessing directives
#
#   16.2 Source file inclusion


# todo 17 Library introduction

# todo 18 ... to 30: libraries

# todo 25 Algorithms library

# todo 27 Input/output library

# todo 29 Atomic operations library

# ... todo 30 Thread support library



# Appendix A - Advanced concepts
#
# A.1 Reference and Value Semantics



# Appendix B - Debug, memory, ...
#
# B.1 Aids for Debugging: assert and NDEBUG [3_1].6.5.3
#
# B.2 gdb
#     B.2.1 Handling cores
#
# B.3 memory analysis
#     B.3.1 valgrind tool


# Appendix C - Compilation, Linkage, ...
#
# C.0. Compiling and Executing Our Program
# C.1. 'gcc' versus 'g++'  Compilation
# C.2. File naming
# C.3. Name mangling: C & C++ compatibility
# C.4. Compilation options
# C.5. Linkage
# C.6. C++11 compilation options  [6]
# C.7. Static libraries
# C.8. Shared libraries


# Appendix I - Undocumented Issues
#
# I.1 Local static variables are shared


# Appendix K - Code examples (./code_examples)
#
# Compilation, Linkage, ...
# io_first_look
# iteration statements
# references (lvalue references)
# constructors
# templates


# Appendix S - New Features 
#
# S.1 New Features in C++11
# S.1.1 Strongly typed enums
# S.1.2 Lambda functions (closures)
#
# S.2 New Features in C++14
# S.3 New Features in C++17

# Appendix T - Defined Terms

# Appendix W - Remarkable Warnings

# Appendix X - C++ techniques

# Appendix Y - Non-C++ concepts
#
# Y.1 Memory address

# Appendix Z - References


# ==============================================================================

Table Index

# 2.13.2   Types of integer literals
# 2.13.3   Types of Character and Character String Literals
# 2.13.4   Types of Floating-Point Literals
# 2.13.15  Escape Sequences

# 3.9.1	   C++ Arithmetic Types


# ==============================================================================


# ==============================================================================
# 0 The (C++) standard
# ==============================================================================

a) This document is updated to the C++ standard document [1_1]:

  - n4582.pdf : November 2014 working draft (free).
    	      	This working draft contains the C++14 standard plus
    	      	minor editorial changes.

b) All c++11 concepts are included into c++14

c) Using the proper c++ version in your programs:

   Makefile support must be added to CXXFLAGS  compilation flags+

   # c++14 support: CXXFLAGS += -std=c++14
   #
   # c++11 support: CXXFLAGS += -std=c++11
   #
   # C++98 support: otherwise


# ==============================================================================
# # 1 General
# ==============================================================================

# 1.1 Scope

- C++ is a general purpose programming language based on the C programming lang.


# 1.7 The C++ memory model

Note.- byte, word, and memory location (Y.1)

1) The byte

- The fundamental storage unit in the C++ memory model is the byte.

- The memory available to a C++ program consists of one or more sequences of
  contiguous bytes.

- Every byte has a unique address.

- byte size = IMPLEMENTATION-DEFINED

  WARNING a C++ byte does not exactly means 8-bits:

  A byte is at least large enough to contain any member of the basic
  execution character set (2.3) and the eight-bit code units of the
  Unicode UTF-8 encoding form.

  A byte is composed of a contiguous sequence of bits, THE NUMBER of
  which IS IMPLEMENTATION-DEFINED.

3) A memory location

   A MEMORY LOCATION IS either an object of scalar type or a maximal
   sequence of adjacent bit-fields all having nonzero width.

   Two or more threads of execution (1.10) can access separate memory
   locations without interfering with each other.

   mem address != mem location: a mem. location occupies one or more mem. addr.

4) Bit fields and memory locations

   - A bit-field and an adjacent non-bit-field are in separate memory locations.

   - The same is applicable tot two bit-fields, if one is declared
     inside a nested struct declaration and the other is not,

   - or if the two are separated by a zero-length bit-field declaration,

   - or if they are separated by a non-bit-field declaration.

   It is not safe to concurrently update two bit-fields in the same struct
   if all fields between them are also bit-fields of non-zero width.

   [ Example: 

   struct
   {
    char a;    // field
    int b:5,   // bit-field
    c:11,      // bit-field
    :0,	       //  zero-length bit-field declaration
    d:8;       // bit-field
    struct {int ee:8;} e; // nested bit-field declaration
   }

   Result: 'a', 'd', and 'e.ee' are each separate memory locations.
   	   'b' and 'c' together constitute the fourth memory location.

   —end example ]

# 1.8 The C++ object model

1) An object is a region of storage. [ Note: A function is not an object,
   regardless of whether or not it occupies storage in the way that objects do.]

- Object creation ways:
  	 by a definition (3.1)
  	 by a new-expression (5.3.4)
  	 by the implementation (temporary object - 12.2) when needed.

- The properties of an object are determined when the object is created.

- An object can have a name (Clause 3).

- An object has a storage duration (3.7 - static, thread, automatic, dynamic)
  which influences its lifetime (3.8).

- An object has a type (3.9): the type with which the object is created.

- Some objects are polymorphic (10.3); the implementation generates
  information associated with each such object that makes it possible
  to determine that object’s type during program execution.

- For other objects, the interpretation of the values found therein is
  determined by the type of the expressions (Clause 5) used to access them.

2) Subobjects & Complete Objects.

   - Objects can contain other objects, called subobjects: member
     subobject (9.2), base class subobject (10), or an array element.

   - An object that is not a subobject of any other object is called a
     complete object.

4) Most derived class (type), and Most derived object

   - Most derived class: if a complete object, a data member subobject,
     or an array element subobject is of class type, its type is considered
     the most derived class, to distinguish it from the class type of any
     base class subobject.

   - Most derived object: an object of a most derived class type
     	  	  	  or of a non-class type.

   # e.g.

   class base {};
   class derived : base {};
   class base2 {};
   class mostderived : derived, base2 {};
   mostderived md; // most derived class is: type mostderived
   	       	   // most derived object: md
   int number;	   // mdc: not applicable to a non-class type
   	       	   // mdo: number

   "md::derived"   // The subobject derived within md is a base class subobject,
   		   // thus its type is not a most derived class,
   		   // thus it is not a most derived object.

5) Object storage:

   - Unless it is a bit-field (9.6), a most derived object shall have
     a non-zero size and shall occupy one or more bytes of storage.

   - Base class subobjects may have zero size.

   - An object of trivially copyable or standard-layout type (3.9.4.2)
     shall occupy contiguous bytes of storage.

6) Unless an object is a bit-field or a base class subobject of zero size,
   the address of that object is the address of the first byte it occupies.


# 1.9 Program execution

My_note.- this chapter marks the rules to compiler makers.
	  Read [1_1] for details.

- The semantic descriptions in this International Standard define a
  parameterized nondeterministic abstract machine.

- “as-if” rule: conforming implementations (of the standard) are
  required to emulate (only) the observable behavior of the abstract
  machine => an implementation is free to disregard any requirement of
  this International Standard as long as the result is as if the
  requirement had been obeyed.


# 1.10 Multi-threaded executions and data races

My_note.- Most of this chapter is oriented to compiler builders.
	  Read [1_1] for complete details of threads in C++.
	  

1) A thread of execution is a single flow of control within a program, [...]

   Every thread in a program can potentially access every object and
   function in a program.

   An object with automatic or thread storage duration (3.7) is associated
   with one specific thread, and can be accessed by a different thread only
   indirectly through a pointer or reference (3.9.2).

   The execution of the entire program consists of an execution of all
   of its threads.

   Under a freestanding implementation, it is implementation-defined
   whether a program can have more than one thread of execution.

2) A signal handler that is executed as a result of a call to the
   raise function belongs to the same thread of execution as the call
   to the raise function. Otherwise it is unspecified which thread of
   execution contains a signal handler invocation.

6) Two expression evaluations conflict if one of them modifies a
   memory location (1.7) and the other one reads or modifies the same
   memory location.

7) The Atomic operations library (29) defines a number of atomic
   operations and operations on mutexes (30) that are specially
   identified as synchronization operations.

23) Two actions are potentially concurrent if
    (23.1) — they are performed by different threads, or
    (23.2) — they are unsequenced, and at least one is performed by a
    	     signal handler.

    - Data race: The execution of a program contains a data race if it
    contains two potentially concurrent conflicting actions, at least
    one of which is not atomic, and neither happens before the other,
    except for the special case for signal handlers described below.

    - Any such data race results in undefined behavior.



# ==============================================================================
# 2 Lexical conventions
# ==============================================================================

# 2.1 Separate translation

  \brief: separate translation = one object-file per translation unit,
  	  and/or per instantiation unit.


1) translation units (TU) and instantiation units

a) translation units (TU)

   def [1_1]: TU = source file + included headers + included sources -
      	      	   - source lines skipped by any of the conditional inclusion
             	   preprocessing directives ([1_1])

   My-def: TU = source file after it has been processed by the C preprocessor.

Note: A C++ program need not all be translated at the same time.

b) Instantiation units

def [1_1]: These are similar to translated translation units, but contain no
       references to uninstantiated templates and no template definitions. 

def [6_3]: Instantiation units are separate files where template instantiations
       encountered by the compiler in a TU are stored, so that each template
       instantiation is compiled only once per program. 

My-def: Units created by the compiler to store the template-code actually
	INSTANTIATED in any of the translation units.

	# e.g.
	// sources
	a.h: with template functions 1,2,3
	b.h: with template functions 4,5.6
	main.cpp: uses 1 and 5
	// compilation
	The compiler ignores 2,3,4,6 and store 1 & 5 in a separate file "x".
	The file "x" is an instantiation unit.
	Then the compiler compiles "x".


2) Translated translation units and instantiation units can be preserved
   individually or in libraries.

The separate translation units of a program communicate (3.5) by (for
example) calls to functions whose identifiers have external linkage,
manipulation of objects whose identifiers have external linkage, or
manipulation of data files.

Translation units can be separately translated and then later linked
to produce an executable program (3.5).


# 2.2 Phases of translation

My_note.- Here a brief explanation. Read [1_1] for details.

  C preprocessor (invoked by the compiler)

1-3. Tokenization: the source file is decomposed into preprocessing tokens.

4. Preprocessing directives are executed, macro invocations are expanded, and
   _Pragma unary operator expressions are executed. Steps 1-4 are repeated for
   every #include

5-6. Preprocess string literals (concatenation, ...)

   C++ compiler:

7. Tokens are syntactically and semantically analyzed and translated as a
   translation unit.

8. Translated translation units and instantiation units are combined as follows:
   a) Each translated translation unit is examined to produce a list of
      required instantiations.   
   b) All the required instantiations are performed to produce instantiation
      units. The program is ill-formed if any instantiation fails.

   C++ linker:

9. a) Linkage is executed to resolve external references.
   b) All such translator output is collected into an image which contains
      information needed for execution in its execution environment.


# 2.3 - 2.9

My_note.- Ignored. Read [1_1] for details. 

- Basic Character set = [a-z][A-Z][0-9] _ {  ...  * +  ...  " ' 

# 2.10 Identifiers

3) WARNING reserved ids:

(3.1) — Each identifier that contains a double underscore __ or begins with an
underscore followed by an uppercase letter is reserved to the implementation
for any use.

    .*__.*   is reserved
    _[A-Z]   is reserved


(3.2) — Each identifier that begins with an underscore is reserved to the
implementation for use as a name in the global namespace.

     _.+ is reserved

# 2.11 Keywords

1) Reserved keywords

   alignas .. bool .. while

WARNING reserved for future use:  export  register

2) reserved for certain operators and punctuators

   and      and_eq   bitand   bitor   compl   not
   not_eq   or 	     or_eq    xor     xor_eq


# 2.12 Operators and punctuators

  {   ..   xor_eq

# 2.13 literals

# 2.13.1 Kinds of literals

  integer-literal
  character-literal
  floating-literal
  string-literal
  boolean-literal
  pointer-literal
  user-defined-literal
  

NOTICE	
We can override literal's default types by using a suffix.
# i.e. 20L or 024L or 0x14L  // type long instead (default) type int 


# 2.13.2 integer-literal

  integer-literal:				(prefix)     (example)
    binary-literal integer-suffixopt       	0b or 0B     0B10100
    octal-literal integer-suffixopt		0     	     024
    decimal-literal integer-suffixopt		none	     20
    hexadecimal-literal integer-suffixopt	0x or 0X     0x14	 

- By default, decimal literals are signed whereas octal and
  hexadecimal literals can be either signed or unsigned types.

- The type of an integer literal is the first (the smallest) of the
  corresponding list in Table 2.13.2 in which its value can be represented:


                   Table 2.13.2 Types of integer literals
 ==============================================================================
  Suffix        Decimal literal		  Binary, octal, or hexadecimal literal
 ==============================================================================
  none		int			  int
  		long int		  unsigned int
  		long long int		  long int
		     	  		  unsigned long int
		     	  		  long long int
		     	  		  unsigned long long int 
 ------------------------------------------------------------------------------
  u or U	unsigned int		  unsigned int
  		unsigned long int	  unsigned long int
  		unsigned long long int	  unsigned long long int
 ------------------------------------------------------------------------------
  l or L	long int		  long int
  		long long int	  	  unsigned long int
		     	  		  long long int
		     	  		  unsigned long long int 
 ------------------------------------------------------------------------------
  both u or U	unsigned long int	  unsigned long int
  and l or L	unsigned long long int	  unsigned long long int
 ------------------------------------------------------------------------------
  ll or LL	long long int		  long long int
  			  		  unsigned long long int
 ------------------------------------------------------------------------------
  both u or U    unsigned long long int   unsigned long long int
  and ll or LL
 ==============================================================================

... thus:

- A decimal literal has the smallest type of int, long, or long long
  in which the literal’s value fits.

- Octal and hexadecimal literals have the smallest type of int,
  unsigned int, long, unsigned long, long long, or unsigned long long
  in which the literal’s value fits.

- It is an error (ill-formed program) to use a literal that is too
  large to fit in the largest related type

CONCLUSIONS 
The type of an integer literal depends on its value and notation
  # e.g. 12   is of type int
  # e.g. 12UL is of type unsigned long
  notation: suffix UL => possible types are unsigned long or unsigned long long
  value: 12 => unsigned long is the smallest type that can represent that value
  

# 2.13.3 character-literal

  A character enclosed within single quotes is a literal of type char: i.e 'a'

    Table 2.13.3 Types of Character and Character String Literals
  ================================================================
    Prefix (one of)     Meaning                       Type
  ----------------------------------------------------------------
	u		Unicode 16 character          char16_t
    	U	  	Unicode 32 character   	      char32_t
   	L	  	wide character   	      wchar_t   
    	u8	  	utf-8 (string literals only)  char

  # e.g. 'a' is of type char
  # e.g. u'a' is of type char16_t


# 2.13.4 floating-literal

- Floating-point literals include either a decimal point or an
  exponent specified using scientific notation (e/E)
  # e.g. 3.14159 3.14159E0 0. 0e0 .001

- The type of a floating literal is double unless explicitly specified
  by a suffix :

  Table 2.13.4 Types of Floating-Point Literals
  =============================================
	Suffix     Type
  ---------------------------------------------
	f or F     float
	l or L     long double        
  =============================================

  
# 2.13.5 string-literal

- Zero or more characters enclosed in double quotation marks: i.e "Hello"

- The default type of a string literal is array of constant chars. 
  An optional prefix can be used to change the default type (Table 2.13.3)

- The compiler appends a null character (’\0’) to every string literal:
  size of "Hello" = 6 ('H' 'e' 'l' 'l' 'o' ’\0’)

- Two string literals that appear adjacent to one another and that are
  separated only by spaces, tabs, or newlines are concatenated into a
  single literal (by the compiler - see 2.2 ).
  # e.g. // multiline string literal
  std::cout << "a really, really long string literal "
  	       "that spans two lines" << std::endl;

- Escape Sequences:

                   Table 2.13.15 Escape Sequences
 ==============================================================================
    newline         \n    horizontal tab  \t    alert (bell)  \a
    vertical tab    \v 	  backspace  	  \b 	double quote  \"
    backslash 	    \\ 	  question mark   \?    single quote  \'
    carriage return \r 	  formfeed 	  \f
    octal number    \ooo  hex number      \xhhh
 ==============================================================================

  We use an escape sequence as if it were a single character.

- Generalized escape sequences:

    \x followed by ONE OR MORE hexadecimal digits, or
    \ followed by ONE, TWO, or THREE octal digits.

  The value represents the numerical value of the character. 
  Some examples (assuming the Latin-1 character set):
    \7 (bell)   \12 (newline)   \40 (blank)
    \0 (null)   \115 ('M')      \x4d ('M')

- Raw string literal: string-literal that has an R in the prefix:
  [ Example: The raw string
    R"a(
    )\
    a"
    )a"
    is equivalent to "\n)\\\na\"\n".
   —end example ]

# 2.13.6 boolean-literal

  The Boolean literals are the keywords false and true. Such literals
  are prvalues and have type bool.


# 2.13.7 pointer-literal

  nullptr

[ Note: std::nullptr_t is a distinct type that is neither a pointer type nor a
pointer to member type; rather, a prvalue of this type is a null pointer
constant and can be converted to a null pointer value or null member pointer
value. See 4.10 and 4.11. —end note ]


2.13.8 user-defined-literal

   i.e. 123_km

1) If a token matches both user-defined-literal and another literal kind, it is
   treated as the latter.

2) A user-defined-literal is treated as a call to a literal operator or literal
   operator template (13.5.8).

   i.e.  void operator "" 123_km(long double);


# ==============================================================================
# 3 Basic concepts
# ==============================================================================

- Entity

An entity is a value, object, reference, function, enumerator, type,
class member, bit-field, template, template specialization, namespace,
or parameter pack.


- Name

A name is a use of an identifier (2.10), operator-function-id (13.5),
literal-operator-id (13.5.8), conversion-function-id (12.3.2), or
template-id (14.2) that denotes an entity or label (6.6.4, 6.1).

Every name that denotes an entity is introduced by a declaration.
Every name that denotes a label is introduced either by a goto statement (6.6.4)
or a labeled-statement (6.1).

A name used in more than one translation unit can potentially refer to
the same entity in these translation units depending on the linkage (3.5)
of the name specified in each translation unit.


- Object

A region of memory that has a type.
A variable is an object that has a name.


- Variable

A variable is an object that has a name.

A variable is introduced by the declaration of a reference other than
a non-static data member, or by the declaration of an object.

The variable’s name, if any, denotes the reference or object.


# 3.1 Declarations and definitions

To support separate compilation (2.1), C++ distinguishes between
declarations and definitions.


a) declaration (name)

- A promise that a NAME exists. NEEDED BY THE COMPILER.

- A declaration makes a name known to the program. A file that wants
  to use a name defined elsewhere includes a declaration for that name.

- A variable declaration specifies the type and name of a variable.

b) definition (entity)

- A definition creates the associated ENTITY to the name. NEEDED BY THE LINKER.

- A definition is also a declaration (8.5)

- NOTICE
  In addition to specifying the name and type, a definition also ALLOCATES
  STORAGE and may provide the variable with an initial value.
  To obtain a declaration that is not also a definition, we add the
  extern keyword and may not provide an explicit initializer [k3101]

  # e.g. declararions
  extern int a;		// declares a
  extern const int c; 	// declares c
  int f(int);  	   	// declares f
  struct S; 		// declares S
  typedef int Int; 	// declares Int
  extern X anotherX; 	// declares anotherX
  using N::d; 		// declares d

  # e.g. definitions
  int a;			// defines a
  int a = 1;			// defines and initialices a
  extern const int c = 1; 	// defines c
  int f(int x) { return x+a; } 	// defines f and x



# 3.2 One-definition rule [k3201]

My_note.- Informally "odr-used" means "bind, or memory location accessed"

Note.- an identifier can be DECLARED as often as you want.
       double f(int, double); // legal code: twice definition in a row
       double f(int, double);


(4) Inline vs non-inline definition [1_1]

   Every program shall contain exactly one definition of every
   non-inline function or variable that is odr-used in that program.

   An inline function shall be defined in every translation unit in
   which it is odr-used.


# 3.2.1 One-per-Program Constraints [3_102]

RULE1	No program shall contain more than one DEFINITION of any...

a) Variables with external linkage  (3.5.1)

   i) namespace scope
   ii) non-static global variables  // check at [k3201]

b) Functions:

   i) Noninline functions
   ii) Noninline member functions
   iii) Noninline function templates
   iv) Noninline member function templates

c) Static data members // check at [k3201]

d) Class template data members when they are declared with export (14.5.3)

   i) Noninline members of class templates when ... export

   ii) Static data members of class templates when ... export


RULE1_EXCEPTION This rule does not apply to entities with internal
		linkage (3.5.2)

  [ Example: (explicitly declared) static names // check at [k3201]

  // Translation unit 1:
  static int counter = 2; // unrelated to other1 translation units
  namespace n1 {
  static int counter = 2222; // unrelated to other translation units
  }

  // Translation unit 2:
  static int counter = 0; // unrelated to other translation units
  namespace n1 {
  static int counter = 2; // unrelated to other translation units
  }


  // Translation unit 1:
  const int const_counter = 0; // unrelated to other translation units

  // Translation unit 2:
  const int const_counter = 2; // unrelated to other translation units

  —end example ]


RULE2 Every program SHALL contain exactly one definition of every
      previous item ( RULE_1's a) to d) ) that is odr-used in that
      program. [1_1]

RULE2_EXCEPTION There are two kinds of references that do not
		constitute an odr-use in the previous sense:

e2-a) A reference to an entity appears as part of a sizeof operator

e2-b) A reference that appears as part of a typeid operator it is not
      odr-used unless the argument of the typeid operator ends
      designating a polymorphic object (because in general it is not
      always possible to determine the result of a polymorphic typeid
      operation until run time).

  [ Example:

  #include <typeinfo>

  class Decider
  {
  #if defined(DYNAMIC)
  virtual ~Decider() {}
  #endif
  };
  
  extern Decider d;

  int main()
  {
   int retval = (int) sizeof(d);  // ok: e2-a
   const char* name = typeid(d).name(); // ok: (e2-b) iff DYNAMIC is not defined
                                        // error: if DYNAMIC defined
   return retval;
  }

  —end example ]


WARNING
According to the C++ standard, the constraints described in this
section do not require a diagnostic from a C++ implementation.
In practice, they are almost always reported by linkers as duplicate
or missing definitions.


# 3.2.2 One-per-Translation Unit Constraints [3_102]

RULE3	No translation unit shall contain more than one DEFINITION of any entity

  [ Example:

  inline void f() {}
  inline void f() {} // ERROR: duplicate definition

  —end example ]

  This is one of the main reasons for surrounding the code in header
  files with so-called guards:
  
  // File guard_demo.hpp:
  #ifndef GUARD_DEMO_HPP
  #define GUARD_DEMO_HPP

  … // content discarted the second time this is #included => following RULE3

#endif // GUARD_DEMO_HPP


WARNING
The C++ standard requires that compilers issue some sort of diagnostic
when one of these rules is violated.
An exception is the lack of definition of a nonexported parameterized
function. Such situations are typically not diagnosed.


# 3.2.3 Cross-Translation Unit Equivalence Constraints [3_102]

WARNING

The ability to define certain kinds of entities in more than one translation
unit brings with it the potential for a new kind of error: multiple definitions
that don't match.

Unfortunately, such errors are hard to detect by traditional compiler
technology in which translation units are processed one at a time. =>
C++ does NOT mandate to be detected nor diagnosed => C++ qualifies
this as UNDEFINED behaviour.


# 3.3 Scope (name - declaration)

# 3.3.1 Declarative regions and scopes

- declarative region: every name is introduced in some portion of
  program text called a declarative region.

- scope: In general, each particular name is valid only within some
  possibly discontiguous portion of program text called its scope.


# 3.3.2 Point of declaration

- The point of declaration for a name is immediately after its complete
  declarator (Clause 8) and before its initializer (if any), (unless exceptions)


# 3.3.3 Block scope

1) A name declared in a block (6.3) is local to that block; it has block scope.
   Its potential scope begins at its point of declaration (3.3.2) and ends at
   the end of its block.
   A variable declared at block scope is a local variable.

2) The potential scope of a function parameter name (including one
   appearing in a lambda-declarator) or of a function-local predefined
   variable in a function definition (8.4) begins at its point of declaration.
   [...]
   A parameter name shall not be redeclared in the outermost block of
   the function definition nor in the outermost block of any handler
   associated with a function-try-block.

3) The name declared in an exception-declaration is local to the handler
   and shall not be redeclared in the outermost block of the handler.

4) Names declared in the for-init-statement, for-range-declaration, if, while,
   for, and switch statements are local to the if, while, for, or switch
   statement (including the controlled statement)
   and shall not be redeclared in a subsequent condition of that
   statement nor in the outermost block (or, for the if statement, any
   of the outermost blocks) of the controlled statement; see 6.4.


# 3.3.4 Function prototype scope

In a function declaration, ...., names of parameters (if supplied)
have function prototype scope.


# 3.3.5 Function scope

Labels (6.1) have function scope and may be used anywhere in the
function in which they are declared. Only labels have function scope.


# 3.3.6 Namespace scope

Declarations within the namescape body has namespace scope.

Its potential scope begins at its point of declaration and ends at the
end of the namespace.


[ Example: [k3306]

    namespace N
    {
	int i;
	int g(int a) { return a; }
	int j();
	void q();

  	int get_j = j(); // ok: j() already declared (and defined later)

  	int get_h = h(); // error: h() not declared yet, the point of
		    	 // declaration of h() is after this statement
    }

    //unnamed namespace
    // the potential scope of l is from its point of declaration
    // to the end of the translation unit => unit-local scope
    namespace { int l=1; }

    namespace N
    {
	int g(char a)	// overloads N::g(int)
	{ 
    	  return l+a;	// l is from unnamed namespace
    	}

    	int i;		// error: duplicate definition
    	int j(); 	// OK: duplicate function declaration

    	int j()  	// OK: definition of N::j()
    	{ 
      	  return g(i);	// calls N::g(int)
    	}
    
	int q();	// error: different return type

  	int h() {return 77;}  // definition of h()
  	int get_h = h();      // Here: ok: h() declared and defined

	
    } //eof namespace N

—end example ]


# 3.3.6.1 (Translation unit) local scope or internal linkage

Every member of every unnamed namespace in a translation unit has local scope.
Thus its potential scope is from its point of declaration to the end of the
translation unit.


# 3.3.6.2 Global scope & global names

- The outermost declarative region of a translation unit is also a
  namespace, called the global namespace.

- A name declared in the global namespace has global namespace scope
  (also called global scope).

- The potential scope of such a name begins at its point of declaration (3.3.2)
  and ends at the end of the translation unit that is its declarative region.

WARNING
All the global variables (names), belongs to the same translation unit
=> multiple definitions of the same name in different source files is
equivalent to multiple declarations of the same variable => linkage error.

  # e.g. 
  //file a.cpp
  int name1=7;
  //file b.cpp
  int name1=7;  // compilation error: multiple definitions of `name1'


- A name with global namespace scope is said to be a global name.

a) Naming the global namespace: the unary scope operator "::" (3.4.3 4)

  # e.g. [k33062a]
  int c = 0; // global variable ::c  
  int main()
  {
   int c = 1; //local variable c
   assert(c==1);
   assert(::c==0);
   ...
  }



# 3.3.7 Class scope

1) The following rules describe the scope of names declared in classes.

   ...

   2) A name N used in a class S shall refer to the same declaration
      in its context and when re-evaluated in the completed scope of S. 
      No diagnostic is required for a violation of this rule.

   ...


   [ Example: [k3307]

   typedef int c;
   enum { i = 1 };
   class X 
   {
	char v[i];			// error (violates rule 2)
	     				// i refers to ::i
	     				// but when re-evaluated is X::i

	int f() { return sizeof(c); }	// OK: X::c
	char c;
	enum { i = 2 };			// error: changes meaning of ‘i’
		     			// from ‘<anonymous enum> i’
   };

   typedef char* T;
   struct Y 
   {
	T a;				// error (rule 2): T refers to ::T
	  				// but when re-evaluated is Y::T
	typedef long T;
	T b;
   };

   typedef int I;
   class D 
   {
	typedef I I;			// error, even though no reordering 
		  			// involved
					// error: changes meaning of ‘I’ 
					// from ‘typedef int I’
   };
   —end example ]


# 3.3.8 Enumeration scope

The name of a scoped enumerator (7.2) has enumeration scope. Its
potential scope begins at its point of declaration and terminates at
the end of the enum-specifier.


#!\todo  3.3.9 Template parameter scope


# 3.3.10 Name hiding

My_note: A name can be hidden by a new declaration with the same name.

My_note: A name can be hidden by a new declaration in an inner scope
	 (see example just bellow), or can be hidden while it is in scope
	 (see example [k3310] at 5 later).
  
  # e.g. name hiding in an inner scope
  int i = 33;
  {
   double i =2.8;  // ok: hiding 'int i' in this block
   std::cout << i; 	   // prints '2.8'
  }
  std::cout << i; 	   // 'int i' is visible again; prints '33'


2) A class name (9.1) or enumeration name (7.2) can be hidden by the
   name of a variable, data member, function, or enumerator declared
   in the same scope. The declaration order doesn't matters. [k3310]

... 

5) If a name is in scope and is not hidden it is said to be visible.

  # e.g. [k3310]
  int b;
  int a=1;		// (a_1)
  void f()
  {
      int a=2;		// (a_2) the other 'a' is hidden inside the function f()
      b = a;   	  	// Here: b = (a_2) == 2
      assert(b==2);
  }			// (a_1) is visible again
  int main()
  {  
     b = a; 		// Here: b = (a_1) == 1
     assert(b==1);
     f();
  }
  

# 3.4 Name lookup

1) The process by which the USE of a NAME is MATCHED to its DECLARATION.

- Name lookup shall find an unambiguous declaration for the name.

- Name lookup may associate more than one declaration with a name if
  it finds the name to be a function name; the declarations are said
  to form a set of overloaded functions (13.1).

- Expression processing steps:
  a) name lookup, 
  b) (after a success): overload resolution
  c) (after b success): access rules (public, protected, ...)
  d) (after c success): process the name in the expression.



WARNING From now, brief description for each point, read [1_1] for details.


# 3.4.1 Unqualified name (Appendix T) lookup

1) Name lookup ends as soon as a declaration is found for the name. 
   If no declaration is found, the program is ill-formed.

   [ Example: [k3401]
   namespace M 
   {
	class B { };
   }
   namespace N 
   {
	class Y : public M::B 
	{
		class X 
		{
		      int a = i;
		};
	};
   }
   // The following scopes are searched for a declaration of i:
   // 1) scope of class N::Y::X, before the use of i (see my_note_1 bellow)
   // 2) scope of class N::Y, before the definition of N::Y::X
   // 3) scope of N::Y’s base class M::B
   // 4) scope of namespace N, before the definition of N::Y
   // 5) global scope, before the definition of N
   //
   // my_note_1.- 'i' can be declared AFTER it is used, but then 'a' will be 
   // default-init, instead of initialised with the value of 'i' ([k3401])


# 3.4.2 Argument-dependent name lookup

\brief For functions calls, other namespaces not considered during the
       usual unqualified lookup (3.4.1) may be searched.

[1_1] for details.

  [ Example:
  namespace N 
  {
    struct S { };
    void f(S);
  }
  
  void g() 
  {
    N::S s;
    f(s);    // OK: calls N::f (HERE: arg-dep lookup)
    (f)(s);  // error: N::f not considered; parentheses 
    	     // prevent argument-dependent lookup
  }
  —end example ]


# 3.4.3 Qualified name lookup

My_note.- In a name of the form "nname::id":

	  'nns::id' 	   qualified id

	  'nns'  	   nested-name-specifier of a qualified-id,


1) "nns::" If the name found does not designate a namespace, class,
   enumeration, or dependent type, the program is ill-formed.

  [ Example:
  class A {
   public:
   static int n;
  };
  
  int main() 
  {
   int A;
   A::n = 42; // OK
   A b;       // ill-formed: A does not name a type (Here A is for "int A")
  }
  —end example ]

3) In a declaration in which the declarator-id is a qualified-id (see
   "X C::arr" bellow), names used before the qualified-id being
   declared are looked up in the defining namespace scope; names
   following the qualified-id are looked up in the scope of the
   member’s class or namespace.

  [ Example:
  class X { };
  class C 
  {
    class X { };
    static const int number = 50;
    static X arr[number];
  };
  X C::arr[number]; // ill-formed:
		    // equivalent to: ::X C::arr[C::number];
		    // not to: C::X C::arr[C::number];
		    //
		    // C::Arr is a qualified-id, then
    		    // X is looked up in ::X, and
  		    // number is looked up in C
  —end example ]

4) A name prefixed by the unary scope operator :: (5.1) is looked up
   in global scope, in the translation unit where it is used. 

   The name shall be declared in global namespace scope or shall be a
   name whose declaration is visible in global scope because of a
   using-directive (3.4.3.2).

   The use of :: allows a global name to be referred to even if its
   identifier has been hidden (3.3.10).

5) A name prefixed by a nested-name-specifier that nominates an
   enumeration type shall represent an enumerator of that enumeration.

   [ Example:
   enum color { red = 1, blue = 2 };
   color a = color::red;      // ok
   color b = color::green;    // error
   —end example ]
   
6) If a pseudo-destructor-name (5.2.4) contains a nested-name-specifier, 
   the type-names are looked up as types in the scope designated by the 
   nested-name-specifier.
   
	p->C::I::~I(); // I is looked up in the scope of C
   
   - Similarly, in a qualified-id of the form: 

     nested-name-specifier_opt class-name :: ~ class-name

     the second class-name is looked up in the same scope as the first.
   
	q->I1::~I2(); // I2 is looked up in the scope of the postfix-expression


# 3.4.3.1 Class members

1) case class_nns::X

   a) X is looked up in the scope of the class (10.2)

   b) X shall represent one or more members of that class or of one of
      its base classes (Clause 10).

- The exceptions to the name lookup rule above are the following:
 
(1.1) — the lookup for a destructor is as specified in 3.4.3;

(1.2) — a conversion-type-id of a conversion-function-id is looked up
      	in the same manner as a conversion-type-id in a class member
      	access (see 3.4.5);

(1.3) — the names in a template-argument of a template-id are looked
      	up in the context in which the entire postfix-expression occurs.

(1.4) — the lookup for a name specified in a using-declaration (7.3.3)
      	also finds class or enumeration names hidden within the same
      	scope (3.3.10).


2) In a lookup in which function names are not ignored and the
   nested-name-specifier nominates a class C (read [1_1] for details)

  [ Example:
  struct A { A(); };
  struct B: public A { B(); };
  A::A() { }
  B::B() { }

  B::A ba;	    // ok: object of type A
  //A::A a; 	    // error: A::A is not a type name, is the constructor of A
  struct A::A a2;   // object of type A
  A a;              // ok: object of type A
  —end example ]


# 3.4.3.2 Namespace members [k34032]
 
\brief S(X,m). Read [1_1] for details. 

For a namespace X and name m, S(X,m) is the namespace-qualified lookup set.

a) Search:

   - m is searched recursively in all the namespaces used in X. 
     No search in the global namespace.

   - each referenced namespace is searched at most once


b) Result: unique declaration or ill-formed program

   - If S(X,m) is the empty set, the program is ill-formed.

   - Otherwise if the use of m is not one that allows a UNIQUE
     DECLARATION to be chosen from S(X,m), the program is ill-formed.


[ Example:

int x;              // global variable ::x

namespace Y 
{
 void f(float);
 void h(int);
}

namespace Z 
{
 void h(double);
}

namespace A 
{
 using namespace Y;
 void f(int);
 void g(int);
 int i;
}

namespace B 
{
 using namespace Z;
 void f(char);
 int i;
}

namespace AB 
{
 using namespace A;
 using namespace B;
 void g();
}


void h()
{
 AB::g();     // g is declared directly in AB,
	      // therefore S is { AB::g() } and AB::g() is chosen

 AB::f(1);    // f is not declared directly in AB so the rules are
 	      // applied recursively to A and B;
	      // BECAUSE f is found in A and/or B, then namespace Y is
	      // not searched and Y::f(float) is not considered;
	      // S is { A::f(int), B::f(char) } and overload
	      // resolution chooses A::f(int)

 AB::f(’c’);  // as above but resolution chooses B::f(char)

 AB::x++;     // x is not declared directly in AB, and
 	      // is not declared in A or B , so the rules are
	      // applied recursively to Y and Z,
	      // S is { } so the program is ill-formed

 AB::i++;     // i is not declared directly in AB so the rules are
 	      // applied recursively to A and B,
	      // S is { A::i , B::i } so the use is ambiguous
	      // and the program is ill-formed

 AB::h(16.8); // h is not declared directly in AB and
 	      // not declared directly in A or B so the rules are
	      // applied recursively to Y and Z,
	      // S is { Y::h(int), Z::h(double) } and overload
	      // resolution chooses Z::h(double)
}


5) Because each referenced namespace is searched at most once, the
   following is well-defined:

namespace B 
{
 int b;
}
namespace A 
{
 using namespace B;
 int a;
}
namespace B 
{
 using namespace A;
}
void f()
{
 A::a++; // OK: a declared directly in A, S is { A::a}
 B::a++; // OK: both A and B searched (once), S is { A::a}
 A::b++; // OK: both A and B searched (once), S is { B::b}
 B::b++; // OK: b declared directly in B, S is { B::b}
}

end example ]


My_note.- More examples of different cases in [1_1]


# 3.4.4 Elaborated type specifiers

1 An elaborated-type-specifier (7.1.6.3) may be used to refer to a
  previously declared class-name or enum-name even though the name has
  been hidden by a non-type declaration (3.3.10).


# 3.4.5 Class member access

  Shown & Pass.

# 3.4.6 Using-directives and namespace aliases [basic.lookup.udir]

1 In a using-directive or namespace-alias-definition, during the
  lookup for a namespace-name or for a name in a nested-name-specifier
  only namespace names are considered.



# 3.5 Program and linkage

(1) A program consists of one or more translation units (Clause 2) linked
   together. A translation unit consists of a sequence of declarations.

(2) A NAME is said to HAVE LINKAGE when it might denote the same
   object, reference, function, type, template, namespace or value as
   a name introduced by a declaration in another scope:


# 3.5.1 External linkage

(2.1) When a name has external linkage, the entity it denotes can be
      referred to by names:

      a) from scopes of other translation units

      b) from other scopes of the same translation unit


Names with external linkage:

a) Named namespaces (including the global namespace)


# 3.5.2 Internal linkage

(2.2) Can be referred only from other scopes of the same translation
      unit (i.e. names of an unnamed namespace)


Names with internal linkage:

a) Unnamed namespaces

b) Names in named namespaces that are:

   b1) (explicitly declared) static names

       (including the global namespace, see 3.2.1 RULE1_EXCEPTION's example)

   b2) a variable of non-volatile const-qualified type that is neither
       explicitly declared extern nor previously declared to have
       external linkage:

       (non-extern) (non-volatile) const ...

   b3) A data member of an anonymous union.


# 3.5.3 No linkage

(2.3) When a name has no linkage, the entity it denotes cannot be
      referred to by names from other scopes.


# 3.5.4 Linkage and Storage class specifiers 

The linkages implied by successive declarations for a given entity
shall agree. That is, within a given scope, each declaration declaring
the same variable name or the same overloading of a function name
shall imply the same linkage. Each function in a given set of
overloaded functions can have a different linkage, however. (7.1.1)


  [ Example:

  static char* f();	// f() has internal linkage
  char* f()    	    	// f() still has internal linkage
  { /* ... */ }

  char* g();		// g() has external linkage
  static char* g() 	// error: inconsistent linkage
  { /* ... */ }

  void h();
  inline void h();	// external linkage

  inline void l();
  void l();		// external linkage

  inline void m();
  extern void m();	// external linkage

  static void n();
  inline void n();	// internal linkage

  static int a; 	// a has internal linkage
  int a;     		// error: two definitions

  static int b; 	// b has internal linkage
  extern int b; 	// b still has internal linkage

  int c;     		// c has external linkage
  static int c; 	// error: inconsistent linkage

  extern int d; 	// d has external linkage
  static int d; 	// error: inconsistent linkage

  —end example ]


aki lo dejo 1   STANDARD


# 3.6 Start and termination
# 3.7 Storage duration
# 3.8 Object lifetime


aki lo dejo 2   (after standard 3.8 finished), goto PRIMER's Chapter 2. Variables and Basic Types
   


# 3.9 Types

FACT_2 Each variable in C++ has a type.

FACT_3 In C++, the type of an object determines what operations can be
       performed on it.

FACT_4 C++ is a statically typed language; type checking is done at compile time
 

- Built-in types: default types provided by C++.

- Class types: types defined by the programmer.


# 3.9.1 Fundamental (built-in) types

built-in types = scalar types (3.9.1.3) + void type

# 3.9.1.1 Integral types: boolean, characters, integers.

  sizeof: machine dependant (Table 3.9.1)


# 3.9.1.2 Arithmetic types:integral types and floating-point types.

a) size of arithmetic types

The standard guarantees minimum sizes as listed in Table 3.9.1
 
However, compilers are allowed to use larger sizes for these types.

Because the number of bits varies, the largest (or smallest) value that a type
can represent also varies (range = 2 ** num_bits)

=======================================================================
    	      Table 3.9.1 C++ Arithmetic Types
=======================================================================
Type  	     Meaning				MINIMUM Size
----------------------------------------------------------------
bool	     boolean				NA
char         character		 	 	 8 bits
wchar_t      wide character		 	16 bits
char16_t     Unicode character		 	16 bits
char32_t     Unicode character		 	32 bits
short        short integer		 	16 bits
int          integer		 	 	16 bits
long         long integer		 	32 bits
long long    long integer		 	64 bits
float	     single-precision floating point	 6 significant digits
double	     double-precision floating point	10 significant digits
long double  extended-precision floating point	10 significant digits
=======================================================================

FACT_5 char is the same size as a single machine byte (1.7.1)

NOTICE
The language guarantees that an int will be at least as large as short,
The language guarantees that a long at least as large as an int, and
The language guarantees that long long at least as large as long.


b) Signed and Unsigned Types

NOTICE
The standard does not define how signed types are represented, but does specify
that the range should be evenly divided between positive and negative values.

- integral types may be signed or unsigned: [unsigned] type-name

- chars: char, signed char, and unsigned char. Where the (plain) char type uses
  either signed or unsigned char representation depending on the compiler.

WARNING
Don’t Mix Signed and Unsigned Types (negative signed numbers will be converted
to unsigned):
e.g. // WRONG: u can never be less than 0; the condition will always succeed
     // when u==0 and --u is executed, then u won't be -1 but a high signed)
     for (unsigned u = 10; u >= 0; --u)
     std::cout << u << std::endl;


c) Deciding which Type to Use

BEST_PRACTICE [3_1]

• Use an unsigned type when you know that the values cannot be negative.

• Use int for integer arithmetic.
  If your data values are larger than the minimum guaranteed size of an int,
  then use long long.

• Do not use plain char or bool in arithmetic expressions.

  - For Tiny integers:
    WARNING char is signed on some machines and unsigned on others =>
    	    explicitly specify either signed char or unsigned char.
    my_note: use (unit8_t ,..) types in <stdint.h> library instead

• Use double for floating-point computations:
  - Float lacks precision and in fact, on some machines, double-precision
    operations are faster than single.
  - The precision offered by long double usually is unnecessary and often
    entails considerable run-time cost.


# 3.9.1.3 Scalar types

  Arithmetic types,
  enumeration types,
  pointer types, pointer to member types (3.9.2), std::nullptr_t,
  and cv-qualified versions of these types (3.9.3)



# 3.9.2 Compound types

\todo

# 3.9.3 CV-qualifiers

# a) volatil eQualifier [3_1].19.8.3.

WARNING
The precise meaning of volatile is inherently machine dependent and
can be understood only by reading the compiler documentation. Programs
that use volatile usually must be changed when they are moved to new
machines or compilers.

NOTICE
An object should be declared volatile when its value might be changed
in ways outside the control or detection of the program.  (i.e. a
program might contain a variable updated by the system clock.)

- The volatile keyword is a directive to the compiler that it should
  not perform optimizations on such objects.

- A type can be both const and volatile

- A class can define member functions as volatile. Only volatile
  member functions may be called on volatile objects.

  (e.g.) [k5]
  volatile int v;      // v is a volatile int
  int *volatile vip;   // vip is a volatile pointer to int
  volatile int *ivp;   // ivp is a pointer to volatile int
  volatile int *volatile vivp; // vivp is a volatile pointer to volatile int
  ivp = &v; 	           // ok
  vivp = &v; 	           // ok
  volatile int & vref = v; // ok
  int *ip = &v;            // error: must use a pointer to volatile


- Synthesized Copy/Move & assigment operator Does Not Apply to volatile Objects:

  So the programmer must define its own versions:
  
    class Foo {
    public:
     Foo(const volatile Foo&); // copy from a volatile object

     // assign from a volatile object to a NONVOLATILE object
     Foo& operator=(volatile const Foo&);

     // assign from a volatile object to a VOLATILE object
     Foo& operator=(volatile const Foo&) volatile;
    };


  WARNING
  A deeper question is whether it makes any sense to copy a volatile object.


# b) const Qualifier


# c) const volatile Qualifier


# ------------------------------------------------------------------------------
# 3.9.4 Types not defined in the standard
# ------------------------------------------------------------------------------

WARNING (TrivialType, StandardLayoutType, PODType)
"Note, that the standard doesn't define a named requirement or concept with this
name. This is a type category defined by the core language. It is included here
as concept only for consistency."


# 3.9.4.1 TrivialType

[http://en.cppreference.com/w/cpp/concept/TrivialType]

a) definition

   Specifies that a type is trivial type.

b) Requirements

b1) TriviallyCopyable 

b2) Has one or more default constructors, all of which are either
    trivial or deleted, and at least one of which is not deleted.

c) See also

is_trivial (C++11): checks if a type is trivial (class template)
is_trivially_copyable (C++17)


# 3.9.4.2 StandardLayoutType [4_6_6] [4_6_3]

a) definition

Specifies that a type is standard layout type. Standard layout types are useful
for communicating with code written in other programming languages.

b) Requirements

   See [4_6_6] [4_6_3]

c) See also [k8503]

   is_standard_layout (C++11): checks if a type is standard-layout type
		      	       (class template)


# 3.9.4.3 PODType

PODType (Plain Old Data), or PDS (Passive data structure) [4_6_1] [k8503]

a) definition

The idea of a POD is to capture basically two distinct properties:
1. It supports static initialization, and
2. Compiling a POD in C++ gives the same memory layout as a struct compiled in C

Specifies that the type is POD (Plain Old Data) type. This means
the type is compatible with the types used in the C programming
language, can be manipulated using C library functions: it can be
created with std::malloc, it can be copied with std::memmove, etc,
and can be exchanged with C libraries directly, in its binary form.


b) Requirements

   Either:

b1) a scalar type;

b2) a class type (class or struct or union) that is: 

- (until C++11)
  an aggregate type;
  has no non-static members that are non-POD;
  has no members of reference type;
  has no user-defined copy constructor;
  has no user-defined destructor; 

- (since C++11)
  a trivial type;
  a standard layout type;
  has no non-static members that are non-POD; 

b3) an array of such type. 


c) is_pod (since C++11) 

   #include <type_traits>
   template< class T >
     constexpr bool is_pod_v = is_pod<T>::value;

d) Examples [k8503]:

  struct base0 { int b01, b02; };
  // is_trivial:         true
  // is_standard_layout: true
  // is_pod:             true

  struct base1 { int b1, b2 = 42; }; // b=42 => copy constructor => non-trivial
  // is_trivial:         false
  // is_standard_layout: true
  // is_pod:             false // non-trivial

  struct base2
  {
    base2() : b3(42) {} // user-defined constructor => non-trivial
    int b3;   	     	//                          => non-aggregate
  };
  // is_trivial:         false
  // is_standard_layout: true
  // is_pod:             false // non-trivial

  struct derived_from_trivial
  : base0
  { int dft; };

  // is_trivial:         true  
  // is_standard_layout: false // non-s data members in diff. classes (C++14)
		       	       // base classes with non-s data members (C++11)
  // is_pod:             false // non-standard_layout


  struct derived //!\warning derivation, causes is_standard_layout == false
  :  base1 // public derivation from an aggregate
  { int d; };
  // is_trivial:         false // derivated from a non-trivial
  // is_standard_layout: false // same as derived_from_trivial
  // is_pod:             false // non-trivial, non-standard_layout



# 3.10 Lvalues and rvalues

1 Expressions are categorized according to the taxonomy in Figure 1

                  expression
                  |        |
                  v        v
              glvalue     rvalue
              |     |     |    |
             v       v   v      v
          lvalue     xvalue    prvalue


(1.1) — An lvalue designates a function or an object. 


(1.2) — An xvalue (an “eXpiring” value) also refers to an object,
      	usually near the end of its lifetime (so that its resources
      	may be moved, for example).

	Certain kinds of expressions involving rvalue references
	(8.3.2) yield xvalues. [ Example: The result of calling a
	function whose return type is an rvalue reference to an object
	type is an xvalue (5.2.2). — end example ]


(1.3) — A glvalue (“generalized” lvalue) is an lvalue or an xvalue.


(1.4) — An rvalue is an xvalue, a temporary object (12.2) or subobject
        thereof, or a value that is not associated with an object.


1.5) — A prvalue (“pure” rvalue) is an rvalue that is not an xvalue.

       [ Example: The result of calling a function whose return type
         	  is not a reference is a prvalue.

         	  The value of a literal is also a prvalue. — end example ]


FACT_3_10_1 Every expression belongs to EXACTLY ONE of the fundamental
	    classifications in this taxonomy: lvalue, xvalue, or prvalue.
	    This property of an expression is called its value category.


# ==============================================================================
# 4 Standard conversions
# ==============================================================================


FACT_1  Only (zero or) one implicit conversion is allowed (ill-formed otherwise)



1) Standard conversions are implicit conversions with built-in meaning.


# ------------------------------------------------------------------------------
# \todo 4.1 Explicit conversions [4_12_1]
# ------------------------------------------------------------------------------
 
Converts between types using a combination of explicit and implicit conversions.


( new_type ) expression 	(1) 	
new_type ( expression ) 	(2) 	
new_type ( expressions ) 	(3) 	
new_type ( ) 	(4) 	
new_type { expression-list(optional) } 	(5) 	(since C++11)
template ( expressions(optional) ) 	(6) 	(since C++17)
template { expressions(optional) } 	(7) 	(since C++17)

Returns a value of type new_type. 


# ------------------------------------------------------------------------------
# 4.2 Implicit conversions [4_12_2]
# ------------------------------------------------------------------------------

Implicit conversions are performed whenever an expression of some type T1 is 
used in context that does not accept that type, but accepts some other type T2;
in particular:


- when the expression is used as the argument when calling a function
  that is declared with T2 as parameter;

- when the expression is used as an operand with an operator that expects T2;

- when initializing a new object of type T2, including return
  statement in a function returning T2;

- when the expression is used in a switch statement (T2 is integral type);

- when the expression is used in an if statement or a loop (T2 is bool). 

  
WARNING
The program is well-formed (compiles) only if there exists (zero or) ONE 
unambiguous implicit conversion sequence from T1 to T2. [k6]


WARNING 
The compiler can not perform an implicit conversion for a non-const 
reference because it can't be temporary, (it has no sense) [k6]:



# 4.2.1 Order of the conversions

Implicit conversion sequence consists of the following, in this order:

1) ZERO OR ONE standard conversion sequence (in this order)

   i) zero or one lvalue transformation;
   ii) zero or one numeric promotion or numeric conversion;
   iii) zero or one function pointer conversion;              (since C++17)
   iv) zero or one qualification adjustment.


2) zero or one user-defined conversion;

   i) zero or one non-explicit single-argument constructor 
   ii) zero or one non-explicit conversion function call


# 4.2.2 Implicitly convertible expression

An expression e is said to be implicitly convertible to T2 if and only if:

    T2 t = e; 

is well-formed (can be compiled), for some invented temporary t. 


# 4.2.3 \todo Contextual conversions

# 4.2.4 \todo Value transformations

Value transformations are conversions that change the value category of an 
expression. They take place whenever an expression appears as an operand of 
an operator that expects an expression of a different value category.


# ------------------------------------------------------------------------------
# \todo 4.3 User-defined conversions
# ------------------------------------------------------------------------------

Enables implicit conversion or explicit conversion from a class type
to another type.

operator conversion-type-id 	(1) 	

explicit operator conversion-type-id 	(2) 	(since C++11)


# ------------------------------------------------------------------------------
# \todo 4.4 cpp standard chapter 4 
# ------------------------------------------------------------------------------


    a) When we assign one arithmetic type to another [3_1] 2.1.2

    bool b = 42;          // b is true
    int i = b; 		  // i has value 1
    i = 3.14; 		  // i has value 3 (truncated)
    double pi = i; 	  // pi has value 3.0
    unsigned char c = -3; // assuming 8-bit chars, c has value 253 (256 - 3%256)
    //
    // WARNING If we assign an out -of -range value to an object of
    // signed type, the result is undefined. 
    signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined




# ==============================================================================
# \todo # 5 Expressions
# ==============================================================================

# 5.2 Postfix expressions


# \brief cast modes  [4_13_1]

Use dynamic_cast for converting pointers/references within an
inheritance hierarchy.

Use static_cast for ordinary type conversions.

Use reinterpret_cast for low-level reinterpreting of bit patterns. Use
with extreme caution.

Use const_cast for casting away const/volatile. WARNING Avoid this unless you
are stuck using a const-incorrect API.



# \todo    5.2.7 Dynamic cast
# \todo    5.2.8 Type identification
# \todo    5.2.9 Static cast


# 5.2.10 Reinterpret cast

1 The result of the expression reinterpret_cast<T>(v) is the result of
  converting the expression v to type T.

2 The reinterpret_cast operator shall not cast away constness (5.2.11).

3 [ Note: The mapping performed by reinterpret_cast might, or might
   not, produce a representation different from the original value. —
   end note ]

Note.- Largely, the only guarantee you get with reinterpret_cast is
       that normally if you cast the result back to the original type,
       you will get the exact same value (but not if the intermediate
       type is smaller than the original type). [4_13_1]




# 5.2.11 Const cast  [1_1].114

1 The result of the expression const_cast<T>(v) is of type T.

6 [ Note: Depending on the type of the object, a write operation
  through the pointer, lvalue or pointer to data member resulting from
  a const_cast that casts away a const-qualifier MAY PRODUCE UNDEFINED
  BEHAVIOR (7.1.6.1). — end note ]

9 [ Note: some conversions which involve only changes in
  cv-qualification cannot be done using const_cast.  For instance,
  conversions between pointers to functions are not covered because
  such conversions lead to values whose use causes undefined
  behavior. For the same reasons, conversions between pointers to
  member functions, and in particular, the conversion from a pointer
  to a const member function to a pointer to a non-const member
  function, are not covered. — end note ]


# ==============================================================================
# 6 Statements
# ==============================================================================

# 6.5 iteration statements [3_1].page37

  a) while

  b) for

  c) if

  d) Reading an Unknown Number of Inputs (read until end-of-file)   [k4]

     while (std::cin >> value)  // EOF == false
        ...

WARNING Entering an End-of-File from the Keyboard:
	Unix: control-d
	Win:  control-z




# ==============================================================================
# 7 Declarations
# ==============================================================================

#
# 7.1 Specifiers

# \todo 7.1.1 Storage class specifiers

1) The storage class specifiers are

   extern
   static
   thread_local
   mutable


# 7.1.1.1 extern (Appendix T)

- The extern specifier can be applied only to the names of variables
  and functions.

WARNING 
The extern specifier cannot be used in the declaration of class members 
or function parameters.
  # e.g. 
  class X
  {
   extern int i;  // error: storage class specified for ‘i’
   int i;     	  // ok	  
   int a = i;
  };

- For the linkage of a name declared with an extern specifier, see 3.5.

- The name of a declared but undefined class can be used in an extern
  declaration. Such a declaration can only be used in ways that do not
  require a complete class type. 
  [ Example:
  struct S;
  extern S a;
  extern S f();
  extern void g(S);
  void h() 
  {
   g(a); // error: S is incomplete
   f(); // error: S is incomplete
  }
  —end example ]


# \todo 7.1.2 Function specifiers

1) Function-specifiers can be used only in function  DECLARATIONS.

   function-specifier:
	inline
	virtual
	explicit


# 7.1.2.1 inline

2) The inline specifier indicates to the implementation that inline
   substitution of the function body at the point of call is to be
   PREFERRED to the usual function call mechanism, thus Inline
   Functions Avoid Function Call Overhead

WARNING
An implementation IS NOT REQUIRED to perform this inline substitution
at the point of call: the inline specification is only a request to
the compiler.

FACT_7_1 The inline keyword has no effect on the linkage of a function (3.5.4)


3) A function defined within a class definition is an inline function.

   The inline specifier shall not appear on a block scope function declaration.

   If the inline specifier is used in a friend declaration, that
   declaration shall be a definition or the function shall have
   previously been declared inline.

4) An inline function shall be DEFINED in every translation unit in
   which it is odr-used and shall have exactly the same DEFINITION in
   every case (3.2). [ Note: A call to the inline function may be
   encountered before its definition appears in the translation
   unit. —end note ]

   If the definition of a function appears in a translation unit
   before its first declaration as inline, the program is ill-formed.

   If a function with external linkage is DECLARED inline in one
   translation unit, it shall be DECLARED inline in all translation
   units in which it appears; no diagnostic is required.

   An inline function with external linkage shall have the same
   address in all translation units (My_note.- this is for the
   compiler makers)

   A static local variable in an extern inline function always refers
   to the same object (I.1). 

   A type defined within the body of an extern inline function is the
   same type in every translation unit.


WARNING (Recommendation) Put inline in Header Files [3_1].6.5.2).
(Either in the declaration, or in the definition of template functions.)
Why: Multiple (identical) definitions may exists (one-def rule, see 4)
bellow). As a result, inline functions normally are defined in headers.


# ==============================================================================
# 8 Declarators
# ==============================================================================

- A declarator declares a single variable, function, or type, within a
  declaration.

  # (e.g.) some examples:
  
  T D1;                // single declaration
  T D1, D2, ... Dn;    // multiple declaration
  T D1, *D2;           // mixing noptr-declarator with ptr-declarator
  T D1 = some-T-value; // initializer (8.5)


- A declaration with several declarators is usually equivalent to the
  corresponding sequence of declarations each with a single declarator:

  T D1, D2, ... Dn;    // is usually equivalent to
  T D1; TD2; ... T Dn;

Exception structs:
  struct S ... ;
  S S, T; // declare two instances of struct S
which is not equivalent to:
  struct S ... ;
  S S;
  S T; // error: "S S" caused an ambiguity

Exception auto:
  auto i = 1, j = 2.0; // error: deduced types for i and j do not match
  auto i = 1;   // OK: i deduced to have type int
  auto j = 2.0; // OK: j deduced to have type double


# ------------------------------------------------------------------------------
# 8.3 Meaning of declarators
# ------------------------------------------------------------------------------

# 8.3.3 Pointers to members

Example:

  struct X
  {
   void f(int);
   int a;
   int b;
   void g(int);
  };
  
  struct Y;
  
  //declarations:

  int X::* pmi = &X::a;         // pointer to a member of X of type int
  
  void (X::* pmf)(int) = &X::f; // pointer to a member of X of type void(int)

  double X::* pmd;  // pointer to a member of X of type double
  	      	    // well-formed even though X has no members of type double
  char Y::* pmc;    // pointer to a member of Y of type char
       	    	    // well-formed even though Y is an incomplete type.

  // uses of pmi and pmf
  X obj;
  obj.*pmi = 7;  // assing 7 to the integer member 'a' of obj
  pmi = &X::b;
  obj.*pmi = 10; // assing 10 to 'b'
  (obj.*pmf)(7); // call X::f with the argument 7
  pmf = &X::g;
  (obj.*pmf)(7); // call X::g with the argument 7


WARNING
A pointer to member shall not point to a static member of a class (9.4),
a member with reference type, or “cv void”.

WARNING
The type “pointer to member” is distinct from the type “pointer”.

WARNING
There is no “reference-to-member” type in C++.


# ------------------------------------------------------------------------------
# 8.5 Initializers
# ------------------------------------------------------------------------------

A declarator can specify an initial value for the identifier being declared.

  # (e.g.) 
  T D1 = some-T-value;
  int sum = 0, value =2, *ptr = 0;   	   
  double price = 109.99, discount = price * 0.16; 

WARNING
Initialization is not assignment. Initialization happens when a variable is
given a value when it is created. Assignment obliterates an object’s current
value and replaces that value with a new one. (i.e. copy-ctor vs operator=)


# 8.5.0 Initialiation before C++11  [4_5_1]

a) C++03 Initialization 

not_1) Initialization of fundamental types:

   int n = 0, n2(0);         /* (1)  obj = value  OR  obj(value)  */ 


not_2) Initialization of data members in a class and objects

   struct S
   {
      explicit S(int n, int m) : a(n), b(m){}   /* (2)  mem-init */ 
    private:
      int a, b;
   };
   S s(0,1);   /* (3)  object initializers enclosed in parentheses */
   S s={0,1};  /* (4)  compilation error */


not_3) Initialization of aggregates (arrays / structs / string literals)

Agregate init. requires braces '{}' ...
  int c1[2]={0,2};       /* (5) arrays */    
  struct S { int a,b; };
  S s={0,1};             /* (6) structs  */

... with the exception of string literals:
  char c2[]="message";                           /* (7) string literals */
  char c3[]={'m','e','s','s','a','g','e','\0'};  /* (8) string literals*/


WARNING
Note (4) vs (6) => struct init. != class init.


# b) C++03 Initialization: Arbitrary Restrictions and Loopholes [4_5_1]

- inability to initialize member arrays:

  class C
  {
    int x[100];
    C();        //no proper way to initialize x
  };


- inability to initialize a dynamically allocated POD array (T.POD) [4_6_3]:

  char *buff=new char[1024]; //no proper way to initialize the elements of buff


- no easy way to initialize the elements of a Standard Library container.

  i.e For instance, to initialize a vector of strings, you'd normally
  use a sequence of push_back() calls:

  vector <string> vs;
  vs.push_back("alpha"); ... ; vs.push_back("beta");


# 8.5.1 Aggregates [1_1] [4_6_5] [4_6_4]

0) For what it is used for?

They are are simple & clear data structures (opposite to abstract data types)
=> they are used to create higher-level structures.
=> they are used for a more effective data use.

Advantages:
- Easy data structure.
- Public access.
- Special (easy) initialization syntax:  i.e. Data val3 = {0, "A", 3};


1) Explanation

WARNING
The conditions to be an "aggregate type" differs in the different
versions of C++: 98, 2011, 2014, 2017.

An aggregate is one of the following types: 
- array type
- class type (typically, struct or union), that has:

(1.1) — no user-provided constructors (12.1),
        including those inherited from public bases,
	(explicitly defaulted or deleted constructors are allowed) (since C++11)

(1.2) — no private or protected non-static data members,

(1.3) — no virtual functions (10.3), and

(1.4) — no virtual, private, or protected base classes (10.1).

WARNING (only C++2011)
(1.5) It has no default member initializers (only C++2011)
      i.e. struct SS {int a = 0; int s = 2;}; // ok since C++14, error in C++11 

=> thus, all the data members are known and public, and can/MUST be
   initialized by the user of the aggregate


2) The elements of an aggregate are:

(2.1) — for an array, the array elements in increasing subscript order, or

(2.2) — for a class, the direct base classes in declaration order
      	followed by the direct members in declaration order.


3) Initialization

- Syntax:

  T object = {arg1, arg2, ...};
  T object {arg1, arg2, ...};    (since C++11)


- Example: C++14 aggregate class definition [k8502]

    struct Data14
    // : protected SomeClass // error: no virtual, private, or protected bases
    {
     // Data14() {} //error: no user-provided constructors

     Data14() = default;  // ok: not defined by the user
     int i;
     static int si;       // ok: static not considered a member to init
     int :17;             // ok: anonymous bit-field not considered a member
     int j;
     // virtual void f() {} // error: no virtual member functions

     // private:
     // int member; //error: no private or protected non-static data members

     int public_non_virtual_member_function();  // ok
	  
     private:
     int private_non_virtual_member_function();  // ok
     static int static_member; // ok
    };

    Data14 val1 = {0, 1};     // ok: complete initialization of aggr. class
    	      	    	      // i = 0; j = 1
    Data14 val2 = {0};        // ok: j = int{}, that is, j = 0
    Data14 val3 = {0, 1, 3};  // error: too many elements


- Notes [4_6_5]

Note.- An aggregate array or an aggregate class may contain elements
       of a class type with a user-provided constructor

Note.- Until C++11, narrowing conversions were permitted in aggregate
       initialization, but they are no longer allowed.
       # e.g. narrowing conversion (from double to int):
       int ai[] = { 1, 2.0 }; // error since C++11, okay before C++11

Note.- Until C++14, the direct-initialization form "T a {args..}" did
       not permit brace elision:
       # e.g. brace elision
       int ar2d1[2][2] = {{1, 2}, {3, 4}}; // fully-braced array: ok since C++11
       int ar2d2[2][2] = {1, 2, 3, 4};     // brace elision: error in C++11
       
       WARNING A test has been made that contradicts this statement [k8502]:
       compiler version: g++ (Debian 4.9.2-10) 4.9.2
       compiler flag: -std=c++11
       result: brace elision in C++11 works without errors.


# 8.5.2 Character arrays [4_6_5]

1) Arrays of character types (char, signed char, unsigned char,
   char16_t, char32_t, wchar_t) can be initialized from an appropriate
   string literal, optionally enclosed in braces.

2) There shall not be more initializers than there are array elements.

   char a[] = "abc";
   // equivalent to char a[4] = {'a', 'b', 'c', '\0'};

   unsigned char b[3] = "abc"; // ill-formed: no space for required final '\0'
   unsigned char b[5]{"abc"};  // ok: equivalent to {'a', 'b', 'c', '\0', '\0'};
 
   wchar_t c[] = {L"кошка"}; // optional braces (using '=')
   // equivalent to wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};


WARNING
In C, character array of size one less than the size of the string
literal may be initialized from a string literal; the resulting array
is not null-terminated. This is not allowed in C++.


# ------------------------------------------------------------------------------
# 8.5.3 References
# ------------------------------------------------------------------------------


BRIEF   A reference is an ALIAS to an object (referent): not a pointer to, nor a
	copy of, but the object itself. And it is to be used exactly as
	the object itself:

	[const] Type & reference = referent;

	(e.g.) int int_var = 100;
  	       int &ref1 = int_var;


WARNING A reference is not an object, is an ALIAS to an already existing object

WARNING Do not mistake a memory reference to a variable (ref1), with the
	address of the variable (&int_var)


FACT_1 When we define a reference, instead of copying the
       initializer’s value, we BIND the reference to its initializer.


FACT_2 Once initialized, a reference remains bound to its initial
       object => use the reference is equivalent to use the initial object.

       assert(ref1 == int_var);
       assert(&ref1 == &int_var);
  
   ... , BUT with the weight (memory size) similar to a pointer instead of the
       	 referent type.


FACT_3 There is no way to rebind a reference to refer to a different object.

       &ref1 = another_var;  => compilation error:
       	       		     	lvalue required as left operand of assignment


FACT_4 Because there is no way to rebind, references MUST be initialized.

       int &ref2;    	     => compilation error:
       		     	     	'ref2' declared as reference but not initialized



FACT_5 Because references are not objects, we MAY NOT define a
       reference to a reference.

       int &ref3 = ref1; 

       => OK: This is not a reference to a reference, but a reference
       	      to a variable, because 'ref1' is already an alias to int_var.


FACT_6 New in C++: the ability to truly (genuinely) pass references. [4_2_2]
       (References only exists in C++, there simply are no references in C)


FACT_7 a previously-valid reference only becomes invalid in two cases: [4_2_3]

    - released local objects: If it refers to an object with automatic
      allocation which goes out of scope,
    
    - heap (new-delete) object released: If it refers to an object
      inside a block of dynamic memory which has been freed.


FACT_8 The initializer can be omitted for a reference only in a
       parameter declaration ( 8.3.5 ), in the declaration of a
       function return type, in the declaration of a class member
       within its class definition ( 9.2 ), and where the extern
       specifier is explicitly used. [4_2_0]



WARNING A reference must refer to an object, not a dereferenced null
	pointer [4_2_1]

	It means this is illegal (C++ standard, says it’s illegal, it
	doesn't matter what a particular compiler do):

    	T* p = NULL;
    	T &r = *p;      // illegal
	std::cout << r; // runtime error:  segmentation fault


INFO It is unspecified whether or not a reference requires storage [1_1]


INFO The direct reason references were introduced in C++ was to
     support operator overloading. [4_2_1]

     void f1(const complex* x, const complex* y) // without references
     {
          complex z = *x+*y;  // ugly
     	  // ...
     }

     void f2(const complex& x, const complex& y) // with references
     {
          complex z = x+y;    // better
     	  // ...
     }   


INFO Why is 'this' not a reference?  [4_2_1]

(note.- 'this' is a pointer)
Because this was introduced into C++ (really into C with Classes)
before references were added. Also, Stroustrup chose this to follow
Simula usage, rather than the (later) Smalltalk use of self.


INFO Should I use call-by-value or call-by-reference?  [4_2_1]

(Note: This FAQ needs to be updated for C++11.)

  That depends on what you are trying to achieve:

1. If you want to change the object passed: call by reference or use a pointer:
   e.g., void f(X&); or void f(X*);.
    
2. If you don’t want to change the object passed and it is big, call by
   const reference; e.g., void f(const X&);.

3. Otherwise, call by value; e.g. void f(X);.



# 8.5.3.1 Uses of references [4_2_1]

FAQ) When should I use references, and when should I use pointers?

     "Use references when you can, and pointers when you have to."

     REFERENCES are usually preferred over pointers WHENEVER YOU DON’T
     NEED “RESEATING”.

     This usually means that references are most useful in a class’s
     public interface. REFERENCES typically appear ON THE SKIN of an
     object, and POINTERS on the INSIDE:

     Rule: public interface => use references.
   	   private section => use pointers.


     The exception to the above is where a function’s parameter or
     return value needs a “sentinel” reference — a reference that does
     not refer to an object. This is usually best done by
     returning/taking a pointer, and giving the NULL pointer this
     special significance (references must always alias objects, not a
     dereferenced null pointer).
     

a) Pass-by-reference

   HINT Passing by reference avoid copy_construction-destruction.
   

   a1) Passing large objects to functions without cost:  'const T&'

     	void f_fast(const BigObject& x) { /* ... */ }


   a2) Passing of parameters used for output: "T &"

       WARNING as in case (a1), no copy/destroy, and then no cost occurs [k5] 

       void swap(int& i, int& j)
       {
	int tmp = i; i = j; j = tmp;
       }
       
       int main()
       {
        int x, y;
	swap(x,y);
       }


b) Using functions as lvalues: "return T & function/method"

   Returning a reference allows function calls to be assigned to
   (i.e. operator[] in classes):


    class Array {
    public:
      int size() const;
      float& operator[] (int index);
      // ...
    };
    
    int main()
    {
      Array a;
      for (int i = 0; i < a.size(); ++i)
        a[i] = 7;    // This line invokes Array::operator[](int)
      // ...
    }

   
c) Method chaining: "object.method1().method2()"

   + The most common use is iostream: x << y << .. << z

   + A less common use: "the Named Parameter Idiom." [4_7_6]

     (e.g.) File f = OpenFile("foo.txt")
			.readonly()
			.createIfNotExist()

	    class File { ...   File & readonly(); ... };

   
d) Using references as data members

   BEST_PRACTICE member objects should be by value (see [note-3])

   See Dangers of using references as data members (8.5.3.2.b)
   

e) To state that something is just a reference

   References are also useful in wrapper objects and functors--i.e. in
   intermediate objects that logically contact no members but only
   references to them.

   (e.g.)

   class User_Filter
   {
     public:
     
       Functor (std::list<User> const& lst) : stop_list(lst) { }
       
       bool operator()(User const& u) const { return stop_list.exists(u); }

     private:
       std::list<User> const& stop_list;
   };

   find_if(x.begin(),x.end(),User_Filter(user_list));

   Goal: checking at compilation: compile error if you don't
   	 initialize a reference in constructor of such an object.


f) Other uses

   i.e. Using a reference to function as a function parameter [k5]

   i.e. See the solution to: FAQ How do I prevent the “static
   	initialization order fiasco”?


# 8.5.3.2 Issues on using references

a) Dangers of giving acccess to data members via references:

    e.g.

    class Whatever
    {
     T& First() { return the_first; }
    
    private:
    T the_first;
    };


i. Encapsulation is breached: you leak an implementation detail, which
   means that you can no longer alter your class internals as you wish
   ('T the_first' must always be preserved in order to preserve the
   reference to it promised by 'First()')

ii. Invariant are no longer sustainable (in case of non-const
    reference): anybody may access and modify the attribute referred
    to at will, thus you cannot "monitor" its changes.

iii. Lifetime issues: it's easy to keep a reference or pointer to the
     attribute after the original object they belong to ceased to
     exist. This is of course undefined behavior.


- A solution to (ii):   const T& First() const;

- There are cases where these issues are not problems, but the way you
  need it to be: i.e. stl's vector class:

  std::vector<t>::operator[] breaks (i) and (ii), and may break (iii):
  
  breaking-i) As you will always want to have the positions of the
  vector: no problem.
  
  breaking-ii) You want to provide an easy and intuitive way to set
  values: "v[i] = 4"

  breaking-iii) This could happen if the vector if re-sized, but it
  will be protected inside the operator[] function: if(position>size)
  ...


b) Dangers of using references as data members [4_2_4]

i. Invariant are no longer sustainable (See ii above), due to the referent.

ii. Lifetime issues (See iii above), due to the referent.

iii. Object reseating: impossible real object re-assignation (deep copy)
     Note.- The compiler will not generate the copy assignment operator=().

iv. Copy operations will cause implicit modifications in the referent.

v. Unit testing: references can't be changed to different test values.


	(e.g.) #include <string> [k5]

       	struct Foo
       	{
	  std::string& text;
       	  Foo(std::string& s):text(s){}
	  Foo & operator=(const Foo& src)  // MUST be defined by the programer
	  {  
      	    if(this != &src)
	    {
		// &text = &src.text;  // iii: compilation error
		text = src.text;
	    }
      	    return *this;
	  }
        };

       	void f()
        {
	  std::string s1("I am s1");
	  std::string s2("I am s2");
	  Foo foo_s1(s1); 
	  Foo foo_s2(s2);
	  foo_s2 = foo_s1;       // iv. s2 implicitly modified! (I am s1)
	  s2 = "Still  I'am s2"; // i.  foo_s2 implicitly modified!

	  // Lifetime issues: referent ceased to exist.
	  std::string * s3 = new std::string("I am temporary.");
	  Foo foo_s3(*s3);
	  delete(s3); s3=0; // ii. foo_s3 reference to a released referent.
        }


FACT_9 If an object must be re-assignable, references cannot be used
       as data members.

BEST_PRACTICE member objects should be by value (see [note-3])


8.5.3.3 Defining (binding) references to objects [k5]

a) Ordinary definitions

"Ordinarily, we can bind a reference or a pointer ONLY to an object
that has the SAME TYPE as the corresponding reference or pointer
([3_1] 2.3.1, and [3_1] 2.3.2) or to a type that involves an ACCEPTABLE const
conversion ([3_1] 4.11.2)."  [note-1] ; [3_1] 15.2.3.


a1) Reference to an object of the same type

    int int_var = 100, &ref1 = int_var;

    (e.g) int funcX() { return 42 ; };  
    	  int (&ref_funcx)() = funcX;	// reference to function


a2) Using a reference as an initializer to another reference => OK

    int &ref3 = ref1;          // HERE: 'ref1' is actually the variable int_var
    assert(&ref3 == &int_var);


a3) const reference to an lvalue-constant (a particular case of a1) => OK

    const int int_const = 55;
    const int &ref4 = int_const;


a4) Reference as data member

    WARNING It must be initialized in the initializer list

    (e.g) Correct initialization
    
    class Rclass {
     public:
     Rclass(int &a):the_ref(a) {}  // OK
     private:
     int & the_ref;
    };


    (e.g) Initialization error

    class Rclass {
     public:

     // No init. => Compilation error: uninitialized reference member in ‘int&’
     Rclass(int &a){}
     
     // No init., but assignation instead
     // => Compilation error: uninitialized reference member in ‘int&’
     Rclass(int &a) {the_ref = a;} 

     private:
      int & the_ref; // Compiler note: ‘the_ref’ should be initialized
   };


a5) Pointer references (references to pointers)

    void ptr_incr(int* &i) { i++; }

    int main() {
      int* i = 0;
      cout << "i (addr) = " << i << endl;
      ptr_incr(i);
      cout << "i (addr)= " << i << endl;  // the pointer is incremented,
      	      	 	      	   	  // not what it points to.
    } 


a6) Array references

    int array[3] = {1, 2, 3};
    int (&rarray)[3] = array; // 'rarray' refers to the array 'array'
    assert(rarray==array);
    rarray[1] = 22;
    assert(rarray==array);


b) Definition exceptions 

b1) Classes related by inheritance

    "We can bind a pointer or reference to a base-class type, to an object
    of a type derived from the base class."   [3_1].15.2.3. (page743)

    class BaseClass{};
    class DerivedClass: public BaseClass {};

    DerivedClass do1;
    BaseClass &ref5 = do1


b2) Const reference to a non-const object of the same type, or to a
    type that involves an ACCEPTABLE const conversion [3_1].4.11.2

    # (e.g) same type
    int int_var=0;
    const int &ref6 = int_var; // REF6 refers to int_var


    # (e.g) const conversion from literal 
    const int &ref7 = 7;     // ref7 refers to TEMPORARY with value 7
    const int &ref7 = { 7 }; // the same with  c++11 list-initialization


    # (e.g) const conversion from a different type
    double dval = 3.14;
    const int &ref62 = dval; // ref62 refers to TEMPORARY with value 3
    	      	       	     // NOT to the original variable [note-4]
    // demo				 
    assert(&dval != &ref62);
    std::clog << &dval << std::endl;  // 0x7ffdb16abe18
    std::clog << &ref62 << std::endl; // 0x7ffdb16abe40 (different address)
    std::cout << dval << std::endl;   // 3.14
    std::cout << ref62 << std::endl;  // 3
    dval*=7.0; 
    std::cout << dval << std::endl;   // 21.98
    std::cout << ref62 << std::endl;  // 3 : the value hasn't change


    # (e.g) 
    double g() { return 9.81 }
    const int &ref = g();	      // ref refers to temporary with value 9


[note-4] Explanation: [4_2_0], sentence (5.2.2.2)

R rvar;
T &tref = rvar;       // error: 
const T &tref = rvar; // HERE: three things happens:

1. Implicit conversion from R to T performed by the compiler.

2. The resulting temporary T-variable can only be bound to a
   const reference 'const T&'

3. The lifetime of the temporary variable is extended to match
   that of the reference it is bound to.

Thus: the reference is not made on the original R variable =>
      'tref' and 'rvar' are not bind at all


FACT_10 In all cases except the last ones (i.e., creating and
	initializing a temporary from the initializer expression), the
	reference is said to bind directly to the initializer
	expression. [4_2_0]



b3) A reference declared as extern does not require initialization (see FACT_8)

    extern const int &ref71; // Declaration at base.h
    const int &ref71 = 22;   // Definition at refs_lib.cpp
    std::cout << ref71;      // Use at main.cpp


c) Invalid definitions

c1) (non-const) reference to a literal 

    "[...] a reference may be bound only to an object, not to a
    literal or to the result of a more general expression"  [3_1].2.3.1 (page84)


    "Otherwise, the reference shall be an lvalue reference to a
    NON-VOLATILE CONST type ... ,
    or the reference shall be an rvalue reference." [4_2_0], sentence (5.2)

    # (e.g.)
    double& rd2 = 2.0; //(compiler) error: not an lvalue and reference not const

    # (e.g.) 
    double getd() { return 2.0; }
    double& rd2 = getd(); // error: not an lvalue and reference not const


c2) (non-const) reference to a different type  [4_2_0], sentence (5.2)

    # (e.g.)
    int i = 2;
    double& rd3 = i;        // error: type mismatch and reference not const

    # (e.g.) 
    const int ic = 55;
    int &ref10 = ic;        // error: type mismatch (int - const int)
    	       	 	    // and reference not const
    
    # (e.g.) : 
    int i = 2;
    int &ref11 = &i;        // error: type mismatch (int - int*)
    	       	 	    // and reference not const


c3) A reference must refer to an object, not a dereferenced null pointer.

    int* pnull = NULL;
    int &ref101 = *pnull;  // illegal: compilation OK ...
    std::cout << ref101;   => runtime error:  segmentation fault



d) Definitions using the volatile Qualifier

  \brief Unique valid cases:  [const] volatile T & = volatile T

  # (e.g.) : 
  volatile int vi = 1;
  volatile int & vref = vi;		// ok: vref refers to vi
  assert(&vref==&vi);


  # (e.g.) : 
  const volatile int & cvref = vi;	// ok: vref refers to vi
  assert(&cvref==&vi);



  \brief Exceptions of using the volatile Qualifier

  # (e.g.) : 
  const volatile int cvi = 1;
  const int& r2 = cvi;			// error: type qualifiers dropped
  assert(r2==cvi);

  # (e.g.) : 
  const volatile int & cvref = 77;	// error: type qualifiers dropped

  # (e.g.) : 
  double dval = 3.14;
  const volatile int & cvref = dval;	// error: type qualifiers dropped
  

8.5.3.4 References as functions parameters [k5]


NOTICE Passing an object to a function's reference parameter is
       equivalent to define a reference to an object:

    (e.g. defining a reference to an object)
    int int_var=0;
    const int &ref = int_var; # explicit definition


    (e.g. passing an object to a function's reference parameter)
    f(const int &ref) {...}
    f(int_var);                # implicit definition: &ref = int_var 
       					   

... so the cases 'a1' ... 'c3' have the same result when calling
    functions (see [k5] examples)



8.5.3.5 functions returning references
 
a) Returning references to local variables.

a1) Returning a local variable.

   (e.g.)
   
   int& f()
   {
     int local_obj=4;
     return local_obj; => compilation warning here
   }
   int &ref12 = f();


- Expected: undefined returned value (disaster): local variables are
  	    stored into stack memory => memory released at function end.

- Obtained:
  Compilation: warning: "reference to local variable ‘local_obj’ returned"
  Returned value: undefined (as expected)

- Solution: never do this.


a2) Returning a reference to a local variable

   (e.g.)
   
   int& f2()
   { int local_obj=4;
   int &local_ref = local_obj;
   return local_ref;
   }
   int &ref13 = f2();   => compilation OK
       	      		=> returned value = undefined value (i.e. -1013474526)


- Expected: undefined returned value (disaster): local variables are
  	    stored into stack memory => memory released at function end.

- Obtained:

  Compilation: OK
  
     This case is, by definition of memory reference, equivalent to
     case 'a' BUT the compiler does not rise a warning and accepts the
     code instead.

  Returned value: undefined (as expected)

- Solution: never do this.


a3) Returning a static local variable

   (e.g.)
   
   int& fstatic()
   {
    static int x =144;
    return x;
   }

   int &ref14 = fstatic();


- Expected: valid returned value: STATIC local variables are stored
  	    into stack memory => never released until the end of the program.

- Obtained: the expected.

- Solution: tricky unusual use (but valid)



# ------------------------------------------------------------------------------
\todo std::ref
# ------------------------------------------------------------------------------

[8_1] [8_2]


# ------------------------------------------------------------------------------
# 8.5.4 List-initialization (or braced-init-list) [C++11] 
# ------------------------------------------------------------------------------

- References: [4_5_1] [4_5_2] [3_1].2.2.1 
- Examples: [k8501]

1) Initializer-list

Introducing a UNIVERSAL initialization notation that applies to every type:
   
(1.1) — as the initializer in a variable definition (8.5)

      	int a {1};
	string s{"hello"};
  	string s2{s};      //copy construction
	std::map<std::string,int> anim =  // stl containers
	   { {"bear",4}, {"cassowary",2}, {"tiger",7} };

(1.2) — as the initializer in a new-expression (5.3.4)

      	double *pd= new double [3] {0.5, 1.2, 12.99}; // dynamic POD array
	
(1.3) — in a return statement (6.6.3)

      	std::pair<std::string,int> f(const char* p, int x) {
          return {p,x};  // return statement
      	}
	
(1.4) — as a for-range-initializer (6.5)

	for (int x : {-1, -2, -3};) 

(1.5) — as a function argument (5.2.2)

       f( {"Nicholas", 7} ); // pass list of two elements

(1.6) — as a subscript (5.2.1)

(1.7) — as an argument to a constructor invocation (8.5, 5.2.3)

      	x = double{1}; // explicitly construct a double
	
(1.8) — as an initializer for a non-static data member (9.2)
        
        class C {
     	    int x[4]{}; // four ints init to zero
	  ...

(1.9) — in a mem-initializer (12.6.2)

      	  ... 
	  public:
            C(): x{0,1,2,3}  // mem-init
	    {std::cout << "C()" << std:: endl;}  
        };

(1.10) — on the right-hand side of an assignment (5.18)


a) Default initialization "{}"

  POD types: usually means initialization to binary zeros.
  non-POD types: default initialization means default construction.

  int n{};      // zero initialization: n is initialized to 0
  int *p{}; 	// initialized to nullptr
  double d{}; 	// initialized to 0.0
  char s[12]{}; // all 12 chars are initialized to '\0'
  string s{}; 	// same as: string s;
  char *p=new char [5]{}; // all five chars are initialized to '\0'


WARNING narrowing conversion
In List-initialization of built-in types narrowing conversion is not
allowed => compiler error: i.e. int ii = {2.0}; // error: narrows


2) initializer-list (sequence) constructor [k8501]

An object of type std::initializer_list<T> is a lightweight proxy
object that provides access to an array of objects of type const T.

a) What is it used for?

   A std::initializer_list object is automatically constructed when:


a1) a braced-init-list is bound to auto, including in a ranged for loop

    for (int x : {-1, -2, -3}) // the rule for auto makes this ranged-for work
    	std::cout << x << ' ';


a2) a braced-init-list is used in list-initialization, including
     function-call list initialization and assignment expressions.

- Typically Used to IMPLICITLY INITIALIZE STL CONTAINERS through a sequence of
  values. For example:

    vector<int> vi {1,2,3,4,5,6};
    map<string, string> stars { {"Superman", "+1 (212) 545-7890"},
    			        {"Batman", "+1 (212) 545-0987"} };

- It also can be used in user defined types too. See example bellow.

 
b) How it works?

- Detail: Read [4_5_1] [4_5_2]

  WARNING
  Although superficially this new syntax seems identical to the
  brace-init notation we discussed earlier, behind the scenes it's a
  different story. C++11 furnishes every STL container with a new
  constructor type called a sequence constructor.

- Brief:

   (1) std containers or user defined classes, have a constructor
   that accepts an std::initializer_list<T> argument.

   (2) the user initialize an object via list-initialization.

   (3) the compiler calls the constructor defined in (1) and creates &
       initializes the object.


   # Example with a user defined type.- [4_5_2]

   template <class T>
   struct S
   {
      std::vector<T> v;

      // (1) constructor 
      S(std::initializer_list<T> l) : v(l)
      {
       std::cout << "constructed with a " << l.size() << "-element list\n";
      }

      // ...
   };

   int main()
   {
      S<int> s = {1, 2, 3, 4, 5}; // (2) copy list-initialization
      	       	     	      	  // (3) Here, the compiler calls
				  // S(std::initializer_list<T> l)
   }


   # Another, Example with a user defined type.- [4_5_2]

   template <typename T>
   void templated_fn(T) {}

  //templated_fn({1, 2, 3}); // error: "{1, 2, 3}" is not an expression,
                             // it has no type, and so T cannot be deduced
  templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK
  templated_fn<std::vector<int>>({1, 2, 3});           // also OK  


# ------------------------------------------------------------------------------
# 8.5.5 Class Member Initialization (or In-Class Initializers)
# ------------------------------------------------------------------------------

- We can supply an In-Class Initializer to initialize a data member.

- Members without an initializer are default initialized ([3_1] 2.2.1, p. 72).


a) Using class member initialization [k8501]

  # e.g. 
  class C
  {
    string s="abc";     //class member initializers ...
    double d=0;
    char * p {nullptr};
    int y[5] {1,2,3,4};
    int x=7;
    
  public:
    C();
  };

WARNING
Regardless of the initialization form used, the compiler conceptually
transforms every class member initializer into a corresponding mem-init.

Thus, class C above is semantically equivalent to the following class:

  # e.g. 
  class C
  {
    string s;
    double d;
    char * p;
    int y[5];

  public:
   C() : s("abc"), d(0.0), p(nullptr), y{1,2,3,4} {} }


b) Class member initializer vs mem-init

If the same data member has both a class member initializer and a
mem-init in the constructor, the latter (mem-init) takes precedence.

  # e.g. 
  class CC
  {
   int x=7; // class member initializer
   C();     //x is initialized to 7 when the default ctor is invoked
   C(int y) : x(y) {} //overrides the class member initializer
  };
  C c;      //c.x = 7
  C c2(5);  //c.x = 5


# ==============================================================================
# 9 Classes
# ==============================================================================


# In C++ we define our own data types by defining a class:

   class (or struct) : [public|protected|private] base-specifier-list{
   	 [declarations]
   } [variable-definitions];


   # i.e   struct Sales_data { /* ... */ } accum, trans, *salesptr;



# Introducing Classes [3_1].1.5

- To use a class we need to know three things:
  • What is its name?     (i.e. Sales_item) 
  • Where is it defined?  (i.e. sales_item.h)
  • What operations does it support?

- Every class defines a type = the name of then class


  class ClassExample {
  
    // [...]	// WARNING can have no content

  }; //!\warning semicolon required
  



# ==============================================================================
# 10 Derived classes
# ==============================================================================

# 10.3 Virtual functions

1) Virtual functions support dynamic binding and object-oriented programming.

FACT_1 A class that declares or inherits a virtual function is called
       a polymorphic class.


# 10.3.1 Calling virtual member functions vs calling non-virtual member funcs.

a) Non-virtual member functions are resolved statically (at compile-time),
   BASED ON the TYPE of the POINTER (or reference) TO THE OBJECT. 
   This is called “static binding.”

b) Virtual member functions are resolved dynamically (at run-time),
   BASED ON the TYPE of the OBJECT, not the type of the ptr/ref to
   that object. This is called “dynamic binding.” [4_11_1] [k14]


- Applying member access rules (compiler - static)
    
Member access control rules (public/privete/protected) for a member
function are checked based on the type of the pointer, regardless if
the function id virtual or not. Thus, dynamic/static binding and
access rules are two different and complementary concepts. (11.5) [k14]

      # (e.g.)
      class Shape{...};
      class Circle: public Shape{...};
      Circle my_circle;
      Shape * shape1 = &my_circle; // static binding: type Shape.
                                   // dynamic binding: type Circle
				   // member access rules:  type Shape.
      Circle * circle1 = &my_circle; // all bindings & access rules: Circle


- How is the 'virtual' qualifier inherited?

The "virtual" qualifier is not required in the derived classes:

Once a class declares a member function (i.e. draw) as virtual, then
all its derived classes, and all the derived classes of the derived
classes, and all ..., are also polymorphic classes (10.3, FACT_1),
whose (draw) method is virtual.


     # e.g. [k14]

     class Shape {
     public:
      virtual void draw() const;
     }

     class Circle : public Shape{
     public:
      void draw() const; // here: "virtual" is not necessary, already specified
      	   	  	 // at Shape
     }

     class SolidCircle : public Circle 
     {
     public:
      void draw() const; // "virtual" function inherited 
     }


# 10.3.2 virtual table & virtual pointer: resolving dynamic binding [4_11_2]

Most compilers use some variant of the following technique:
If the object has one or more virtual functions, the compiler puts a
hidden pointer in the object called a “virtual-pointer” or “v-pointer.”
This v-pointer points to a global table called the “virtual-table” or “v-table.”


\brief: A 3 step  process: to compile T object.func(), the compiler do
	    	  	   => object.v_pointer => T::v_table => object.func()


a) v-table (one per class)

- The compiler creates exactly one v-table for each class that has at least one
  virtual function.

- The v-table is stored into STATIC memory somewhere (hidden static data-member)

- The v-table has one entry per each virtual function of the class.
  Each entry has a pointer to the correspondent virtual function.
  Note.- Each pointer typically fits (hardware dependent) into one
  machine word of memory space.

- Many (not all) compilers define this table while compiling the .cpp unit
  that defines the class first non-inline virtual function.


b) v_pointer  (one per object)

- The compiler creates exactly one v-pointer for each object that has
  at least one virtual function (hidden data-member)
  
  WARNING For a class hierarchy, the v-pointer is only added to the
  	  base class, then it is inherited by all the derived classes.

- The v-pointer points to the class (static) v-table data-member.

- Note.- The v-pointer pointer typically also fits into one machine
  word of memory space (hardware dependent).

 
c) Dynamic binding process

- During a dispatch of a virtual function, the run-time system follows
  the object’s v-pointer to the class’s v-table, then follows the
  appropriate slot in the v-table to the method code.

- The space-cost overhead of the above technique is nominal, thus O(1):
  an extra pointer per (polymorphic) object, plus an extra pointer per method.

- The time-cost overhead is also fairly nominal (O(1))

  Normal function call: one call 

  Virtual function call = fetch (get v-pointer) +
  	  	   	  fetch (get method address from v-table) +
			  function call
			= 2 loads + a call

  (Note: the above discussion is simplified considerably, since it
  doesn’t account for extra structural things like multiple
  inheritance, virtual inheritance, RTTI, etc., nor does it account
  for space/speed issues such as page faults, calling a function via a
  pointer-to-function, etc)
  

d) Detailed construction process:

   (Base class)

- Step #1: the compiler builds the static v-table for class Base.

- Step #2: the compiler adds the v-pointer to each object of class Base.

- Step #3: the compiler initializes this->__vptr within each
       	   constructor init-list. The idea is to cause each object’s
       	   v-pointer to point at its class’s v-table.
  WARNING	   
  The C++ standard commands the initialization of the v-pointer after
  all the base classes has been defined, but it doesn't specifies
  exactly where from this point, thus it is compiler-implementation
  dependant. [4_7_8] [k13]


   (Derived class)

- Step #1: repeat step #1 for the derived class:
       	   The compiler builds the static v-table for class Derived,
       	   keeping the same function-pointers as in Base::__vtable but
       	   replacing those slots that correspond to overrides.

- Step #2: nothing to do; v-pointer is inherited from Base.

- Step #3: repeat step #3 for the derived class.
       	   (This is not a second v-pointer; it’s the same v-pointer
       	   that was defined in the base class)



  # e.g. base class

  // v-functions: let's pretend 'FunctionPtr' is a generic pointer to a
  //              generic member function.
  //
  // v-table: let’s pretend its technical name is 'Base::__vtable'
  //
  // v-pointer: let’s pretend its technical name is '__vptr'
  

    //!\file base.h
  
    // Your original C++ source code
    class Base {
    public:
      virtual arbitrary_return_type virt0( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt1( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt2( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt3( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt4( /*...arbitrary params...*/ );
      // ...

 
    // Step #1
    // Pseudo-code (not C++,not C) for a static table declared by the compiler
    //
    public:   
      static FunctionPtr __vtable[5];  // static data-member,
    	   	       		       // consuming just 5 words of memory


    // Step #2
    // Supplied by the compiler, hidden from the programmer
    //
    public:
      FunctionPtr* __vptr;


    }; //endof_Base



    //!\file base.cpp  

    // Step #1
    //
    // Pseudo-code for init. the static table defined within file base.cpp
    //
    FunctionPtr Base::__vtable[5] =
    { &Base::virt0, &Base::virt1, &Base::virt2, &Base::virt3, &Base::virt4 };


    // Step #3
    //
    Base::Base( /*...arbitrary params...*/ )
    :
     __vptr(&Base::__vtable[0])  // Supplied by the compiler,
     			  	 // hidden from the programmer
     // ...
    {
      // warning: __vptr already defined => base virtual members can be called
      
      // ...
    }


  # e.g. derived class
  
  // let's pretend class Der doesn’t add any new virtuals.

  class Der : public Base
  {
    // HERE: inherited virtual function override
      virtual arbitrary_return_type virt0( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt1( /*...arbitrary params...*/ );
      virtual arbitrary_return_type virt2( /*...arbitrary params...*/ );
      // ...


    // Step #1
    //
    public:   
      static FunctionPtr __vtable[5];  // static data-member, let's pretend
      	     		 	       // Der doesn’t add any new virtuals.
      
    }; //endof_Der



    //!\file derived.cpp  

    // Step #1
    
    FunctionPtr Der::__vtable[5] = {
      &Der::virt0, &Der::virt1, &Der::virt2,    // Inherited override
      &Base::virt3, &Base::virt4                // Inherited as-is
    };


    // Step #3
    
    Der::Der( /*...arbitrary params...*/ )
    :
    // 1) note.- construction of virtual base classes (only for the constructor
       	  of the most derived class)
    
    // 2) note.- construction of direct base classes

    // 3) Step #3 code, Supplied by the compiler.
     __vptr(&Der::__vtable[0])
    
    // 4) note.- construction of non-static data members      
    {
      // warning: __vptr already defined => der. virtual members can be called
      
      // 5) ctor. body
    }


  # e.g. How the compiler implements a call to a virtual function:

    // Your original C++ code
    void mycode(Base* p)
    {
      p->virt3(); // cost ¢ O(1): one function call
    }

    The compiler has no idea whether this is going to call Base::virt3() or
    Der::virt3() or perhaps the virt3() method of another derived class that
    doesn’t even exist yet. It only knows for sure that you are calling virt3()
    which happens to be the function in slot #3 of the v-table.
    It rewrites that call into something like this:

    // Pseudo-code that the compiler generates from your C++
    void mycode(Base* p)
    {
      p->__vptr[3](p); // cost ¢ O(1): fetch + fetch + call 
    }


e) Conclusions:

- Objects of classes with virtual functions have only a small
  space-overhead compared to those that don’t have virtual functions.

- Calling a virtual function is fast — almost as fast as calling a
  non-virtual function.

- You don’t get any additional per-call overhead no matter how deep
  the inheritance gets. You could have 10 levels of inheritance, but
  there is no “chaining” — it’s always the same — fetch, fetch, call.

  Caveat: I’ve intentionally ignored multiple inheritance, virtual
  inheritance and RTTI. Depending on the compiler, these can make
  things a little more complicated. [4_11_2]
  

# 10.3.10 Virtual functions FAQ  \todo [4_11_1]


# ==============================================================================
# 11 Member access control
# ==============================================================================

A member of a class can be

(1.1) — private; that is, its name can be used only
      	by members and friends of the class in which it is declared.

(1.2) — protected; that is, its name can be used only
      	by members and friends of the class in which it is declared,
	by classes derived from that class, and by their friends (see 11.4).

(1.3) — public; its name can be used anywhere without access restriction.


    class X
    {
        int a; // X::a is private by default
    };

    struct S
    {
	int a; // S::a is public by default
    };


# 11.1 Access specifiers

Member declarations can be labeled by an access-specifier: public, private,
or protected.

     struct S
     {
	int a; // S::a is public by default: struct used
     protected:
	int b; // S::b is protected
     private:
	int c; // S::c is private
     public:
	int d; // S::d is public
     };


# 11.2 Accessibility of base classes and base class members [k1101]

   class Derived : [public|private|protected] Base {---};

   Where "[public|private|protected]" is the derivation access specifier.

1) Access types:

- The derivation access specifier has no effect on whether members
  (and friends) of a derived class may access the members of its own
  direct base class...

- ... The purpose of the derivation access specifier is to control the
  access that users of the derived class—including other classes
  derived from the derived class—have to the members inherited from the base:

a) class B : public A { ... };  // A is a public base of B

   A access type	 B access type (of A members)
   public           ->   public
   protected	    ->   protected
   private	    ->      - 

b) class B : protected A { ... };  // A is a protected base of B

   A access type	 B access type (of A members)
   public           ->   protected
   protected	    ->   protected
   private	    ->      - 

c) class B : private A { ... };  // A is a private base of B

   A access type	 B access type (of A members)
   public           ->   private
   protected	    ->   private
   private	    ->      -
   

d) Example:

   class Base
   {
   public:
     void pub_mem(); // public member
   protected:
     int prot_mem; // protected member
   private:
     char priv_mem; // private member
   };


   // Access to the derived classes & their friends

   struct Pub_Derv : public Base
   {
     /******************************************************************/
     /*!\note The IMPLICIT derived code would be something like this:  */
     /******************************************************************/
     public:
       void pub_mem(){};
     protected:
       int prot_mem;
     /******************************************************************/

     // Pub_Derv code     
     public:
     int f() {return prot_mem;}    // ok: prot_mem is accesible 
     char g() { return priv_mem; } // error: private members are inaccessible
     	      	       		   // to derived classes
   };


   struct Priv_Derv : private Base
   {
     /******************************************************************/
     /*!\note The IMPLICIT derived code would be something like this:  */
     /******************************************************************/
     private:
       void pub_mem();
       int prot_mem;
     /******************************************************************/

     // Priv_Derv code
     int f() {return prot_mem;} // ok: private derivation doesn't affect access
     char g() { return priv_mem; } // error: private members are inaccessible
     	      	       		   // to derived classes
   };

   // Access to the users of the derived classes:
   Pub_Derv d1; // members inherited from Base are public
   Priv_Derv d2; // members inherited from Base are private
   d1.pub_mem(); // ok: pub_mem is public in the derived class
   d2.pub_mem(); // error: pub_mem is private in the derived class


2) In the absence of an access-specifier for a base class:

  - public is assumed when THE DERIVED CLASS is defined with the key 'struct'
  - private is assumed for 'class'.

  (e.g.)
  class B { /* ... */ };
  // equivalent definitions:
  class D1 : private B { /* ... */ }; 
  class D3 : B { /* ... */ };         // B private by default

  // equivalent definitions:
  struct D4 : public B { /* ... */ }; 
  struct D6 : B { /* ... */ };         // B public by default


BEST_PRACTICE
A privately derived class should specify private explicitly rather than rely on
the default.


3) Note: A member of a private base class might be inaccessible as an
   inherited member name, but accessible directly. Same for pointer
   conversions and explicit casts.

   class B {
   public:
     int mi; // non-static member
     static int si; // static member
   };
   class D : private B { };
   class DD : public D{
      void f();
   };

   void DD::f() {
     mi = 3; // error: mi is private in D
     si = 3; // error: si is private in D
     ::B b;
     b.mi = 3; // OK ( b.mi is different from this->mi)
     b.si = 3; // OK ( b.si is different from this->si)
     ::B::si = 3; // OK
     ::B* bp1 = this; // error: B is a private base class
     ::B* bp2 = (::B*)this; // OK with cast
     bp2->mi = 3; // OK: access through a pointer to B.
   }


4) Exempting Individual Members [3_1].15.5

Sometimes we need to change the access level of a name that a derived class
inherits. We can do so by providing a using declaration

    # e.g. [k1101]
    
    class Base {
    public:
      std::size_t size() const { return n; }
    protected:
      std::size_t n;
    private:
      char priv_mem; // private member
    };

    class Derived : private Base { // note: private inheritance
    public:
      using Base::size; // changing the access: accesible to users of Derived
    protected:
      using Base::n;    // changing the access: accesible to derived classes

      using priv_mem; // error: private in base
    };


WARNING
A derived class may provide a using declaration only for names it is
permitted to access, thus not private members of the base.


# 11.3 Friends

- Friend DECLARATIONS may appear only inside a class definition. [3_1]

- A friend of a class is a function or class that is given permission
  to use the private and protected member names from the class.

- The meaning of the friend declaration is the same whether the friend
  declaration appears in the private, protected or public (9.2)
  portion of the class member-specification.

- Friendship is neither inherited nor transitive (a friend of a friend).

- A member function of a class X can be a friend of a class Y.

  class Y {
    friend char* X::foo(int);
    friend X::X(char);        // constructors can be friends
    friend X::~X();           // destructors can be friends
  };

WARNING
Many compilers do not enforce the rule that friend functions must be
declared outside the class before they can be used. But it is a good
idea to provide separate declarations for friends. [3_1].7.2.1


# 11.4 Protected member access 

An additional access check beyond those described earlier in Clause 11
is applied when a non-static data member or non-static member function
is a protected member of its naming class:

A derived class member or friend may access the protected members of
the base class only through a derived object. ([3_1] 15.5, p. 756)


  # e.g. [k1101]

  class Base {
  protected:
    int prot_mem; // protected member
  };
  
  class Sneaky : public Base {
    friend void clobber(Sneaky&); // ok: can access Sneaky::prot_mem
    friend void clobber(Base&);   // error: can't access Base::prot_mem
    int j; // j is private by default
  };


# 11.5 Access to virtual functions [k14]

1) The access rules (11) for a virtual function are determined by its
   declaration and are not affected by the rules (10.3.1.FAQ1) for a
   function that later overrides it.

   class B {
   public:
     virtual int f();  
   };

   class D : public B {
   private:
     int f();
   };

2) Access is checked at the call point using the type of the expression used to
   denote the object for which the member function is called.
   
   The access of the member function in the class in which it was defined is
   in general not known.


   void main()
   {
    D d;

    B* pb = &d; // access as B
    D* pd = &d; // access as D

    pb->f(); // ok: B::f() public  => access is checked at the call point,
    	     // D::f() is invoked  => dynamic binding
	     
    pd->f(); // error: D::f() is private
   }


# 11.6 Multiple access

1) If a name can be reached by several paths through a multiple inheritance
   graph, the access is that of the path that gives most access. [ Example:

   class W { public: void f(); };
   class A : private virtual W { };
   class B : public virtual W { };
   class C : public A, public B
   {
     void f() { W::f(); } // OK: public access through B
   };


# 11.7 Nested classes [k1101]

A nested class is a member and as such has the same access rights as any other
member. The members of an enclosing class have no special access to the INNER
members of a nested class; the usual access rules (11) shall be obeyed [note-5].

  Example:

  class E {

    friend void ff();
  
    int x;

    class B { };

    class I {
      B b; // OK: E::I can access E::B
      int y;
      void f(E* p, int i)
      {
        p->x = i; // OK: E::I can access E::x
      }
    };
  
   int g(I* p)
   {
    return p->y; // error: I::y is private
   }
  };


[note-5] Thus, B & I has complete access to E members, but E's members access to
the interior of B & I follows the general rules (public, protected, private)


# ==============================================================================
# 12 Special member functions
# ==============================================================================

- default constructor (12.1)
- copy constructor (12.8)
- copy assignment operator (12.8)
- move constructor (12.8)
- move assignment operator (12.8)
- destructor (12.4)

  class ClassExample {

    // [...]	// WARNING can have no content

  //!\warning: synthetised member function are  declared here, at the closing }
  };


WARNING
Programs may explicitly refer to implicitly-declared special member functions.

  struct A { }; // implicitly declared A::operator=
  A::operator=(s); // well formed


# ------------------------------------------------------------------------------
# 12.1 Constructors
# ------------------------------------------------------------------------------

FACT_1 What every constructor MUST assure:

 1. Initialize virtual base classes.
 
 2. Initialize direct base classes.

 3. Initialize the v-pointer for each polymorphic object.

 4. Initialize embedded data members.


FACT_2
The compiler (synthesized functions) performs only the initialization
operations that are required by the implementation, not the
programmer, to construct an object:

 - Synthesized functions make basic copies (bitcopy) only.
 - Data members are not initialized.
 - Dynamic (Heap) memory is not created [4_8_1].

The reasons are Performance and Compatibility with C.
       

 - Consequences:

   [C++98] The resultant data members have an indeterminate (UNDEFINED)
 	   value once the object has been constructed.

   [C++11] in-class initializers (8.5.5) and default-initialize (8.5.5),
	   can provide a well defined initial status if they were defined
	   by the programmer.


 WARNING
 The memory allocated by a new expression in the constructor is not
 part of the object’s space. It doesn’t matter how much memory your
 new expression allocates, sizeof (*this) remains fixed.


# 12.1.1 Trivial Constructors [4_7_1]

  The fact that a constructor is considered trivial means that neither
  the programmer nor the compiler generates code (DEFINE) for it.


   e.g. class Empty {};

   e.g. struct Person       # all data members are public
   	{
	  char name[20];
	  int age;
	};


 Question: Why Does The Compiler Implicitly DECLARE Trivial Constructors If They
	   Are Never Defined? [4_7_2]

 A: For code simplification

    Implicit DECLARATIONS have a contractual role. Each implicit
    declaration is like an article in a contract that states how a
    certain class may be used.

    Without the implicit declarations mechanism, programmers would
    have to go through every class and struct, manually adding
    declarations of every member function that’s needed for
    instantiating, copy-constructing, assigning and destroying objects.



# 12.1.2 Non-trivial constructors

\brief A class MUST have a non-trivial constructor to accomplish FACT_1.


\detail A class MUST have a non-trivial ctor. in the following cases [4_7_2]:

i) Classes with virtual member functions.

   The non-trivial constructor must initialize the correct 'v-pointer'
   address of each polymorphic object.

ii) Classes with some direct Base classes with non-trivial constructor(s).

iii) Classes with (non-static) data members with non-trivial constructor(s).

iii) Classes with some virtual base class (Virtual inheritance) [4_10_1]

    The presence of a virtual base class necessitates a non-trivial
    constructor to ensure that only one virtual subobject is present
    in every derived object. Therefore, if a class has any virtual
    base class(es), its constructor must be non-trivial.


# a) Default constructor

     - A default constructor is one that can be invoked without any arguments,
       thus a constructor that supplies default arguments for all its parameters
       also defines the default constructor: e.g. C(int a=0)

     - It can be created by the user or by the compiler (synthesized def. ctor.)

       # (e.g.)

       Class C {  C(int i=5); // can be called with no args }

       C obj1;   // ok: default constructor of class C is invoked

       C obj2(); // error: this declares a function (common mistake).


# a.1) Synthesized constructor for a class (or struct)  [k8]

    The one automatically & implicitly created by C++ iff ...

      	- If there is no user-declared constructor for a class (or struct)

      	- And if the class doesn't contain const or reference data members.

	- And if all its base classes have a default constructor. [k8]

	- And if all its data members have a default constructor. [k8]

    ... the implementation needs (MUST have) that definition.
 

- [C++11] "default" / "delete" declaration/definition [4_7_4]

  default: Ask the compiler to create the synthesized default
  	   constructor (even if another constructors already exists)

    	   class Fred() // declaration body
	   {
	    Fred() = default; // here: synthesized & inlined
	   };


    	   // At class definition: synthesized, but not inlined by default
	   Fred::Fred() = default
	   { ...  }


  delete: Forbid the compiler to create the synthetised constructor:

    	  class Fred()
    	  {
     	   Fred() = delete; 
    	  };


- [C++11] "default" initialization process [4_7_4]

    • If there is an in-class initializer (8.5.5), use it to init the member.

    • Otherwise, default-initialize (8.5.5) - ([3_1] 2.2.1, p. 72) the member.

    WARNING
    Classes that have members of built-in or compound type usually
    should rely on the synthesized default constructor only if all
    such members have in-class initializers.


# b) Converting Constructors [4_7_11] [4_7_1]  [k6]

  A constructor that is not declared with the specifier explicit and
  which can be called with a single parameter (UNTIL C++11).

  - Converting constructors are considered during direct initialization. [k6]

  - Converting constructors ARE considered during copy initialization    [k6]
    (as part of user-defined conversion sequence - see 4.3)

  - Can be used as implicit conversion operators. 

  - Implicitly-declared and user-defined non-explicit copy
    constructors and move constructors are converting constructors.


  [ Example  [[k6] :

  struct A
  {
    A() { }         // converting constructor (since C++11)  
    A(int) { }      // converting constructor
    A(int, int) { } // converting constructor (since C++11)
    A(std::string)  // converting constructor
  };
 
  void seta(const A&);   // const &: one implicit conversion allowed (see 4.2)
  void seta_noconst(A&); // no-const &: NONE implicit conversion allowed

 
  int main()
  {
   std::string sa {"literal"};
   A a1 = 1;      // OK: copy-initialization selects A::A(int)
   A a2(2);       // OK: direct-initialization selects A::A(int)
   A a3{4, 5};    // OK: direct-list-initialization selects A::A(int, int)
   A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
   A a5 = (A)1;// OK: explicit cast performs static_cast, direct-init A::A(int)
   A a8(sa);      // OK: direct-initialization selects A::A(string)
   A a9("literal");  // OK: direct-initialization selects A::A(string)
   A a10 = sa;    // OK: copy-initialization  selects A::A(string)
   A a11 = "literal"; // error: invalid conversion <= ONLY one implicit
		      // conversion allowed, 2 required: char[] => string => A
   A a12(a1);     // OK: copy constructor
   a12 = a1;      // OK: operator=(): A => A :  implicit conversion required
   a12 = sa;    // OK: operator=() accepts one implicit conversion:  string => A
   a12 = "literal";  // error: invalid user-defined conversion
		     //        ONLY one implicit conversion allowed

  seta(sa);        // OK: one implicit conversion (string => A) to make temp. A
  seta({1,2});     // OK: one implicit conversion: A::A(int, int) 
  seta("literal"); // error: ONLY one implicit conversion allowed, two required
		     
  seta_noconst(a1); // ok: zero implicit conversions
  seta_noconst(sa); // error: one implicit conversion required.
 }

  —end example ]



# c) Explicit Constructors [4_7_11] [4_7_1]

  PROBLEM of Converting Constructors: copy initialization can produce
  unexpected undesired implicit conversions (executed by the compiler)

  SOLUTION expecific specifier
  
- explicit specifier

  The explicit specifier specifies that a constructor, (or conversion function 
  since C++11), doesn't allow implicit conversions OR COPY-INITIALIZATION.

  
- Explicit constructors are ONLY considered during direct initialization. [k6]

- Explicit constructors ARE NOT considered during copy initialization. [k6]


  INFO
  Why is not 'explicit' the default behaviour of C++ constructors?
  Because the problem was detected after the definition of the
  language, and several software requiring implicit conversions would
  have be affected.


  BEST_PRACTICE
  As a rule,
  - Every constructor that takes a single argument, including constructors 
  that take multiple arguments with default values (before C++11) ...
  - All the constructors (since C++11) ...
  ... should be explicit, unless you have a good reason to allow
  implicit conversions.


  [ Example  [[k6] :

  struct B
  {
   explicit B() {}
   explicit B(int) {}
   explicit B(int, int) {}
   explicit B(std::string) {}
  };

  void setb(const B&);
  void setb_noconst(B&);

 
  int main()
  {
   std::string sb {"literal"};
   B b1 = 1;       // error: copy-initialization does not consider B::B(int)
   B b2(2);           // OK: direct-initialization selects B::B(int)
   B b3{4, 5};        // OK: direct-list-initialization selects B::B(int, int)
   B b4 = { 4, 5}; // error: copy-list-initialization selected an
                      //        explicit constructor B::B(int, int)
   B b5 = (B)1;       // OK: explicit cast, direct-init: B::B(int) 
  
                     // default construction cases
  B b6;              // OK, default-initialization selects B::B()
  B b7{};            // OK, direct-list-initialization selects B::B()
  B b8 = {};       // error: copy-list-initialization selected
                     // an explicit constructor B::B()
  
  B b8(sb);          // OK: direct-initialization selects B::B(string)
  B b9("literal");   // OK: direct-initialization selects B::B(string)

  B b10 = sb;     // error: copy-initialization does not consider B::B(string)
  B b11 = "literal"; // error: invalid conversion
  B b12(b2);         // OK: copy constructor
  b12 = b2;          // OK: operator=(): B => B : no implicit conversion 
  b12 = sb;          // error: no match for ‘operator=’
  b12 = "literal";   // error: no match for ‘operator=’

  setb(b2);    // ok: direct init
  setb(sb);    // error: explicit constructor doesn't allow implicit conversions
  setb({1,2}); // error: explicit constructor doesn't allow implicit conversions

  setb_noconst(b2); // ok: zero implicit conversions
  setb_noconst(sb); // error: one implicit conversion required.

  }

  —end example ]


# d) Constructors of Built-in Types (char, int, ...)

   char c = char();       // equivalent to: char c = char(0);
   char c = char('a');
   double d =double(3.3)  // equivalent to: double d = 3.3;
   int *pi = new int(6);


# e) Member Initialization Lists [4_7_1]

     aka constructor initializer list, mem-initializers, mem-list, mem-init

     Cellphone (long n)
     : number(n)          // mem-list: initialization
     { ... }              // constructor body: assignation

   - Def: ([3_1], Defined Terms, p 395)

   - The members are initialized BEFORE the body of the constructor is executed.

   - The order of the initialization list has to match the order of
     declarations within the class: Immediate base classes (left to right),
     then member objects (top to bottom).

   - Class members that are not initialized in the initializer list
     are implicitly initialized using the same process as is used by
     the synthesized default constructor (Since C++11: in-class
     initializer or default initialized.)

     BEST_PRACTICE
     Constructors should not override in-class initializers except to use
     a different initial value.
     If you can’t use in-class initializers (before C++11), each constructor
     should explicitly initialize every member of built-in type.

  
# e1) Mem-list vs initialization into the constructor body

     i) Equivalent cases (the compiler expands the same code):

       	Ctors. with built-in/intrinsic type data members received in the ctor.
       
	# (e.g.): 
       	Cellphone (long n) : number(n), {}  // equivalent expanded code
       	Cellphone (long n) { number = n; }  
	  

     ii) Mandatory mem-initialization because these initializations
    	 must be completed before the constructor's execution:

    	 - Initialization of const members.
	 - Initialization of reference members.
	 - Passing args. to a constructor of a base class or an embedded obj.


     iii) Cases where the use of mem-list improve the performance
     	  (due to the elimination of creation and subsequent
     	  destruction of temporary objects)

	 (e.g.) Fred::Fred() : x(whatever) { } // mem-init
	 
	 If typeof(whatever) == typeof(x), the result of the whatever
	 expression is constructed directly inside x by the compiler


	 (e.g.) Fred::Fred() { x = whatever; }  // assignation
	 
	 First, the compiler CREATES a temporary object to store 'whatever'.
	 Then, this temporary object is passed into 'x' assignment operator.
	 Finally, the compiler DESTROY the temporary object at the ';'.

	 Note.- there’s another source of inefficiency when using
	 assignment in a constructor: the member object will get fully
	 constructed by its default constructor, and this might, for
	 example, allocate some default amount of memory or open some
	 default file. All this work could be for naught if the
	 whatever expression and/or assignment operator causes the
	 object to close that file and/or release that memory (e.g.,
	 if the default constructor didn’t allocate a large enough
	 pool of memory or if it opened the wrong file). [4_7_6]


e2) Mem-list, Conclussions:

    BEST_PRACTICE
    Due to the performance difference, mem-list should be always used.

    EXCEPTIONS [4_7_6]
    (use common sense: if it’s cheaper, better, faster, etc. to not use them)
    i.e. when your class has two constructors that need to initialize the
    	 this object’s data members in different orders.
    i.e. Or it might happen when two data members are self-referential.
    i.e. when you need to do an if…throw test on a variable prior to using
    	 that variable to initialize one of your this members.
    i.e. etcetera

    BEST_PRACTICE
    Do not use a member object to init another member in the mem-list.
    It is ok inside the body, because all the members have been already init.

    FAQ  What if one member object has to be init using another member object?

    	 >>> Comment the declaration of the effected data members
	     with //ORDER DEPENDENCY

       	     class MyString {
              public:
  	       MyString(const char* s);
	  
              protected:
               uint  len_;  // ORDER DEPENDENCY  // here, order dep. is critical
               char* data_; // ORDER DEPENDENCY
             };

             MyString::MyString(const char* s): len_(std::strlen(s)),
      			       	     	        data_(new char[len_ + 1u])
             { std::memcpy(data_, s, len_ + 1u);}


 f) Copy constructor (copy initialization)

    Constructor that creates & initializes a new object as a copy of
    another existing object of the same type.

    The copy constructor is applied implicitly to pass objects to or
    from a function by value.

    If we do not provide the copy constructor, the compiler
    synthesizes one for us.

    Detailed description (12.8)
    

 g) CV-qualifiers on constructors  \todo test me

    - const and volatile semantics (7.1.6.1) are not applied on an
      object under construction. They come into effect when the
      constructor for the most derived object (1.8) ends.

    - During the construction of a const object, if the value of the
      object or any of its subobjects is accessed through a glvalue
      that is not obtained, directly or indirectly, from the
      constructor’s this pointer, the value of the object or subobject
      thus obtained is unspecified. [ Example:

      struct C;
      void no_opt(C*);

      struct C {
        int c;
        C() : c(0) { no_opt(this); }
      };

      const C cobj;
      
      void no_opt(C* cptr) // Accessed DURING the construction of a C object.
      {
       int i = cobj.c * 100; // value of cobj.c is unspecified
       cptr->c = 1;
       cout << cobj.c * 100 // value of cobj.c is unspecified
      }


# 12.1.3 Initialization order 

GOAL to accomplish FACT_1, for both Synthesized & User defined ctors. [4_7_3]

In a non-delegating constructor [C++11], the initialization proceeds
in the following order [4_7_7] [k12]:

(1) VIRTUAL BASE CLASSES are initialized in depth-first left-to-right
    order in the derived class base-specifier-list.
    Note.- Only for the constructor of the most derived class (1.8).

(2) DIRECT BASE CLASSES left to right in the derived class base-specifier-list,
    (regardless of the order of the mem-initializers).

    - Synthesized: init mem-list, before the execution of the body.
    - User-defined: init mem-list (best-practice), or ctor. body.


WARNING v-pointer initialization here (10.3.2)
Before this point, calling a member function is undefined [4_7_8] [k13], so
from this point, the v-pointer may be defined. 


(3) Non-static data members in the order they were declared (top to bottom)
    (regardless of the order of the mem-initializers).

    - Synthesized: init mem-list, before the execution of the body.
    - User-defined: init mem-list (best-practice), or ctor. body.


(4) constructor body

User-written code in the constructor body

WARNING
Assignation inside the constructor body is not the same as
initialization (i.e. references data members must be initialized)

WARNING Catching exceptions inside the constructor:
    try{
         construction;
    }catch(...)
    {
	release any-heap-data-member already created;
    	throws or handle;
    }


... Finally, The object itself is created: *this completed
		   

    # (e.g.).- Construction of an object of type C [k12]
  
    class D(){ ... };

    class A(){ ... };

    class B : public A { ... };
    
    class C : public B
    {
    public:
      // here: user-defined or synthesized constructors

    private:
      D embed;
    }
    
    int main()
    {
      C c_obj;
    }

    // output:
    // create A::A()
    // create B::B()
    // create D::D()  // embed
    // create C::C()
    // destroy C::~C()
    // destroy D::~D()
    // destroy B::~B()
    // destroy A::~A()



# \todo [C++11] Delegating Constructors [3_1] 7.5.2., p 378

# \todo [C++11] constexpr Constructors [3_1] 7.5.6. Literal Classes, p 387

# \todo [3_1] 15.7 Constructors and Copy Control (p. 768),

# \todo [3_1] 18.1.3 Function try Blocks and Constructors (p. 953),

# \todo [3_1] Chapter 13. (p. 615)

# \todo [C++11] [1_1] 12.6.3 Initialization by inherited constructor


# 12.1.4 Constructors FAQ [4_7_6]

FAQ Can one constructor of a class call another constructor of the
    same class to initialize the this object?

    >> Before C++11: No.

       Foo::Foo(char x)
       {
        Foo(x, 0); // warning: the call to Foo(char, int)
                   // actually creates a temporary Foo object.
       }

   >> Since C++11:  Yes. See Delegating Constructors [3_1] 7.5.2., p 378


FAQ Which constructor gets called when I create an array of T objects?

    >>> The defaults constructor (array-size times)
    	(e.g.) T a[10]; // Calls the default constructor of T 10 times

    >>> Exception: using std::vector: lets you decide to use any ctor.


FAQ Should you use the this pointer in the constructor?

    >>> Not recommended (the object is not fully formed yet)

    Note.- Here is something that never works: the {body} of a
    constructor cannot get down to a derived class by calling a
    virtual member function that is overridden in the derived
    class... because your object is not yet of that derived class.


    Note.- Member functions (including virtual member functions, 10.3)
    can be called for an object under construction but doing it
    before all the mem-initializers for base classes have completed,
    the result of the operation is undefined. [4_7_8]



FAQ What is the “Named Constructor Idiom”?

    >>> A technique that provides more intuitive and/or safer
        construction operations for users of your class:

    You declare all the class’s constructors in the private or protected
    sections, and provide public static "named" methods that return an object.


    # (e.g.) 
    class Point {
    public:
      Point(float x, float y);     // Rectangular coordinates
      Point(float r, float a);     // Polar coordinates (radius and angle)
      // ERROR: Overload is Ambiguous: Point::Point(float,float)
    };
    int main()
    {
      Point p = Point(5.7, 1.2);   // Ambiguous: Which coordinate system?
    }

    /* Solution using the “Named Constructor Idiom” */

    class Point {
     public:
       static Point rectangular(float x, float y);      // Rectangular coord's
       static Point polar(float radius, float angle);   // Polar coordinates
       // These static methods are the so-called "named constructors"

     private: // or protected:
      Point(float x, float y);     // Rectangular coordinates
      float x_, y_;
   };
   
   inline Point Point::polar(float radius, float angle)
   { return Point(radius*std::cos(angle), radius*std::sin(angle)); }

   int main()
   {
    Point p1 = Point::rectangular(5.7, 1.2);   // Obviously rectangular
    Point p2 = Point::polar(5.7, 1.2);         // Obviously polar
   }


    HINT
    The Named Constructor Idiom can also be used to make sure
    your objects are always created via new. [4_111_1]


    NOTE the Named Constructor Idiom, at least as implemented above,
    is just as fast as directly calling a constructor — modern
    compilers will not make any extra copies of your object.
    


FAQ Does return-by-value mean extra copies and extra overhead?

    >>> Not necessarily: all(?) commercial-grade C++ compilers
        implement return-by-value in a way that lets them eliminate
        the overhead, at least in simple cases. (details in [4_7_6])

	Note.- we talk about this type of operations:
	Foo rbv() {return Foo(42, 73);}  // returns a new value
	Foo x = rbv();  // return-value of rbv() goes into x (with optimization)
	Foo x; x= rbv(); // here: the optimization has been prevented



FAQ What about returning a local variable by value?

    >>> Your compiler might optimize away the local variable
        completely (i.e. GNU C++ (g++) since at least version 3.3.3)

	Caveat: this optimization can be applied only when all the
		function’s return statements return the same local variable.

	Note.- we talk about this type of operations:
	Foo rbv()
	{ Foo y(42, 73); // local variable created ...
	  return y;}     // ... and returned
	Foo x = rbv();   // here: optimization
	Foo x; x= rbv(); // here: non-optimization


FAQ static member data initialization & linkage

    >>> Static data members must be explicitly defined IN EXACTLY ONE
        compilation unit.

    // Fred.h
    class Fred {
       // ...
     private:
      static int j_;   // general case: declares static data member Fred::j_
      // ...
      // exception: [4_7_6]#static-const-with-initializers
      static const int maximum = 42; //static const of integral or enum types
    };

    // Fred.cpp
    #include "Fred.h"
    int Fred::j_ = some_expression_evaluating_to_an_int; // general case def.



FAQ The “static initialization order fiasco”?

    >>> A subtle way to crash your program.

    This the well known problem of initializing two GLOBAL (static)
    variables, which (even could) exist in separate source files, when
    one of them depends on the other to be initialized: 50%-50% chance
    of dying.

    WARNING It affects any type of object, even built-in/intrinsic types. [k9]

    WARNING
    Unfortunately it’s very hard to detect — the errors often occur
    before main() begins [k9]

    WARNING
    This fiasco DOES NOT IMPLIES compilation or linking errors.    
    This fiasco implies run-time undefined behaviour/errors/crashes:
    when the non-constructed value is used, the compiler gives to it
    an undefined (compiler dependent) value [k9].


    # Problem example [k9]:
    
    int x = f();  // global x initialization depends on y => fiasco
    int y = g();

    int f()
    {                // HERE 'x' depends on non-constructed 'y', 
     return 3*y + 7; // y has a default undefined value (i.e. 0) => fiasco
    }

    int g() { return 5; }


FAQ How do I prevent the “static initialization order fiasco”?  

    >>> Use the "Construct On First Use Idiom": 

    The basic idea of the Construct On First Use Idiom is to wrap your
    static object inside a function.

    # One valid solution: replace the global objects with a
      global function that returns the object by reference. Example [k9]:

    int& y();  // forward declaration

    int & x_sol()
    {
     // depends on y_sol, that will be initialized when called inside 'new'
      static int* ans = new int(3 * y_sol() + 7);      
      return *ans;
    }

    int & y_sol()
    {
     static int* ans = new int(INITIAL_Y_VALUE);
     return *ans;
    }
    
    main()
    {
     std::cout<< x_sol()<< std::flush; // here: init both globals without fiasco
     std::cout<< y_sol()<< std::flush; // y_sol already created
    }


    # Solution downside.- (intentionally) memory leak:
    The static objects are never destructed: If the object has a
    non-trivial destructor with important side effects, such as
    writing to a file or some other non-volatile action, then you need more.


FAQ How do I prevent the “static initialization order fiasco” for my
    static data members?

    Use the "Construct MEMBERS On First Use Idiom" variant:

    # Problem example:
    
    class X {
     private:
      static Fred x_; // potential fiasco: X obj used (someone calls
      	    	      // some X method), before Fred obj get constructed.
    };

    # Solution:

    // declaration (file.h)
    private:
     static Fred& x(); // member constructed on first use

    // definition (file.cpp)
    Fred& X::x()
    {
     static Fred* ans = new Fred();
     return *ans;
    }



FAQ What is a technique to guarantee both static initialization and
    static deinitialization?

    Nifty Counter Idiom [4_7_6]
    

FAQ What is the “Named Parameter Idiom”?

    It’s a fairly useful way to exploit method chaining.

    (e.g.) File f = OpenFile("foo.txt")
           	    .readonly()
           	    .createIfNotExist()



FAQ Why am I getting an error after declaring a Foo object via Foo x(Bar())?    

    WHY?
    The compiler thinks that you are declaring a function called 'x':
    1.- When the compiler sees Foo x(Bar()), it thinks that the Bar() part
    	is declaring a non-member function that returns a Bar object,
    2.- so it thinks you are declaring the existence of a function called x
    	that returns a Foo and that takes as a single parameter of type
	“non-member function that takes nothing and returns a Bar.”


    # BEST_PRACTICE [C++11]: is to use uniform initialization, which replaces
    # 	   	     the () around the Bar() call with {} instead. [k10]

      Foo x{Bar()};  // C++11 required


    # Pre-C++11 solutions [k10]
    
    - SUPERTRICKY Extra pair of ()s around the Bar() part: Foo x((Bar()));
      // Test [k10]: calling Implicit conversion ctor.: "Foo(const Bar& b)"
      
    - To use = in your declaration: Foo x = Foo(Bar());
      // Theory: calling the Foo copy-constructor
      // Test [k10]: actually calling Implicit conversion ctor. too.

    - To use an Implicit conversion operator from Bar to Foo: Foo x = Bar();
      // Test [k10]: calling Implicit conversion ctor.: "Foo(const Bar& b)"



# ------------------------------------------------------------------------------
# 12.4 Destructors  \todo
# ------------------------------------------------------------------------------

# 12.4.1 Destruction order [k12]

The destructor operates inversely to the constructors:

(1) Executes the function body:
    Typically, the destructor frees resources an object allocated
    during its lifetime.

(2) The members are (implicitly) destroyed

    (Implicit) invocation of the (nontrivial) destructors of the
    embedded object's, in reverse order from the order in which they
    were initialized.

    WARNING
    The implicit destruction of a member of built-in pointer type does
    not delete the object to which that pointer points => explicitly
    release this pointers on step1.

(3) The base classes are (implicitly) destroyed

    (Implicit) invocation of the (nontrivial) destructor of each base class.


b) The Synthesized Destructor

If no destructor is defined, the compiler will invoke a def Synthesized version.
Problem: the function body of the synthesized destructor is empty =>
no resources released.


BEST_PRACTICE Follow 'The Rule of Three' (12.8)



# \todo Complete this topic with other info fromt the web, i.e. informit.



# ------------------------------------------------------------------------------
# 12.8 Copying and moving class objects [3_1].13
# ------------------------------------------------------------------------------

A class object can be copied or moved in two ways:

i) By Copy initialization [4_7_10]:

   By initialization (12.1, 8.5), including for function argument
   passing (5.2.2) and for function value return (6.6.3): implemented
   by a copy/move constructor.

ii) by assignment (5.18): impl. by copy/move assignment operator (13.5.3).


HINT 'The Rule of Three' (aka the Law of The Big Three or The Big Three)

  \todo [c++11] rule of five [1_1].12 Special member functions

  "If a class explicitly defines one of the following it should
  probably explicitly define all three: destructor, copy-constructor,
  assignment operator"


WARNING If no copy-constructor (operator=) is defined, the compiler
	will provide a default synthesized version.
	
	Problem: Synthesized functions make basic copies (bitcopy) only,
	neither initialization nor dynamic memory creation. [4_8_1] 


# 12.8.1 copy-constructor & assignment-operator

a) When is invoked the copy-constructor ? 

   For Construction of a new object: iff the destination object does
   not exists yet.
   In these cases there's no memory to release [note-2].

   (e.g. explicit copy construction)
   
   (1) T y;
   (2) T z(y);  // HERE: calling the copy-constructor
   (3) T x = y; // HERE: calling the copy-constructor
       	     	// warning: here 'x=y' doesn't involves operator=() to be used,
		// because 'x' does not yet exists.


   (e.g. implicit copy construction: after calling a function by value) [k5]
   
   void f(T b) // HERE: calling the copy-constructor to create a temporary obj.
   {
	...
   } // HERE: calling the destructor fot the temporary object


WARNING [note-2]
Never try to release embedded data members in the copy-constructor
because they were not created yet (delete(undefined_addr) => run-time error).


b) When is invoked  the 'assignment-operator' ?
 
   For assignment of new value to an existing object (memory release required).

   (4) T x, y;  // HERE object x created
   (5) x = y;   // HERE: operator= is invoked: the different with (3) is that
      	     	// object x was already created at (4)


c) Example of copy-constructor 

   class Passbyref{
    public:
     Passbyref(int newval = 0):the_value(newval), dummy_data(new DummyData()) {}
     ~Passbyref() {  release();  }

    /* COPY-CONSTRUCTOR */

    Passbyref(const Passbyref & src):
    the_value(0), dummy_data(0) //see [note-2]
    {
     if(this != &src) // 1) Avoid self-copy
     {
       // 2) copy new values
       the_value = src.the_value;
       dummy_data = new DummyData();
     }
    }  


d) Example of assignment-operator

    /* ASSIGNMENT-OPERATOR */

    Passbyref& operator=(const Passbyref & src)
    {
     if(this != &src) // 1) Avoid self-copy
     {
       release();      // 2) release old memory

       // 3) create new memory & copy new values
       the_value = src.the_value; dummy_data = new DummyData();
     }
     return *this;     // 4) return self
    }

   private:
    int the_value;
    DummyData *dummy_data;
    void release() { delete dummy_data; dummy_data=0; }
  };


e) HINT how to prevent pass-by-value of any class objects:

   [C++11] delete: Forbid the compiler to create the synthetised constructor:

    	   class Fred(){
     	     Fred() = delete; 
    	   };


   [C++98] just DECLARE a private copy-constructor (operator=). You
   	   don’t even need to create a definition, unless one of your
   	   member functions or a friend function needs to perform a
   	   pass-by-value.


f) Conclusions:

BEST_PRACTICE
Define an explicit copy-constructor (operator=) only if it is necessary
(synthesized code use to be more efficient due to compiler optimization)


BEST_PRACTICE
Use Member Initialization Lists in the copy-constructor ([k5].Passbyref) .



# 12.8.2 move-constructor & move-operator

\todo 
[4_8_2]


# ==============================================================================
# 13 Overloading
# ==============================================================================

1) Two declarations in the same scope that declare the same name but with
   different types are called overloaded declarations.
   Only function and function template declarations can be overloaded;
   variable and type declarations cannot be overloaded.

   double abs(double); 
   int abs(int);       // ok: overloading of a function named 'abs'
   int abs; // error: variable can't be overload

2) Overload resolution process
   abs(1);   // calls abs(int);
   abs(1.0); // calls abs(double);


# 13.5 Overloaded operators 

FACTS ([3_1] 14.2):

- Operators that can not be overloaded   ::   .*   .   ?:

- We can overload only existing operators and cannot invent new operator symbols

- Four symbols (+, -, *, and &) serve as both unary and binary operators.
  The number of parameters determines which operator is being defined.

- An overloaded operator has the same precedence and associativity as
  the corresponding built-in operator.

- BEST_PRACTICES
  Ordinarily, the comma, address-of, logical AND, and logical OR
  operators should not be overloaded. (because they guarantee the
  order in which operands are evaluated)
  Note.- The standard says (1.9 Program execution): "Overloaded	operators are 
  never assumed to be associative or commutative."



# 13.5.1 Unary operators

- non-static member functions with no parameters:  x.operator@()
- non member function with one parameter:  operator@(x)


# 13.5.2 Binary operators

- non-static member functions with one parameter:  x.operator@(y)
- non member function with two parameters:  operator@(x,y)


# 13.5.3 operator= assignment operator

- An assignment operator shall be implemented by a non-static member
  function with exactly one parameter.


# 13.5.4 operator()  function call, or call operator

- A pair of parentheses “()” following a function name.
- The operator causes a function to be invoked.
- non-static member function with an arbitrary number of parameters.
- It can have default arguments.

  class Fred
  {
    int f(int a, char b);
  };


# 13.5.5 operator[]  Subscripting 

- operator[] shall be a non-static member function with exactly one parameter.

- Syntax: postfix-expression [ expr-or-braced-init-list ]
   
   # e.g.
   struct X
   {
     Z operator[](std::initializer_list<int>);
   };
   X x;
   x[{1,2,3}] = 7; // OK: meaning x.operator[]({1,2,3})
   int a[10];
   a[{1,2,3}] = 7; // error: built-in subscript operator


# 13.5.6 operator->  Class member access

- shall be a non-static member function taking no parameters.

- Syntax: postfix-expression -> templateopt id-expression
  	  postfix-expression -> pseudo-destructor-name

- x->m is interpreted as (x.operator->())->m


# 13.5.7 operator++ and operator--  Increment and decrement

  struct X
  {
   X& operator++(); // prefix ++a
   X operator++(int); // postfix a++
  };

  struct Y { };
  Y& operator++(Y&); // prefix ++b
  Y operator++(Y&, int); // postfix b++
  
  void f(X a, Y b)
  {
   ++a; // equivalent to the explicit call:  a.operator++();
   a++; // eq. to:  a.operator++(0);
   ++b; // eq. to: operator++(b);
   b++; // eq. to: operator++(b, 0);
  }


# 13.5.8 User-defined literals ??

\todo explanation and uses are needed

standard examples:

void operator "" _km(long double); // OK
float operator ""_e(const char*); // OK
float operator ""E(const char*); // error: reserved literal suffix
double operator""_Bq(long double); // OK
double operator"" _Bq(long double); // uses the reserved identifier _Bq (2.10)
float operator " " B(const char*); // error: non-empty string-literal
extern "C" void operator "" _m(long double); // error: C language linkage


# 13.6 Built-in operators

  Operator, such as ( + = .), defined by the language.
  Almost all the built-in operators can be overloaded by the user (13.5)



# ==============================================================================
# 14 Templates
# ==============================================================================

FACT_14_1
When you use a template, you pass the types as arguments (implicit or explicit).

FACT_14_2
Because templates are language features, you have full support of type checking
and scope.

FACT_14_8
Function Templates, Class Templates, ordinary functions and ordinary
classes MAY share the same header file. Then the non-templates may be
defined in a source file.  [k14109]


# ------------------------------------------------------------------------------
# 14.1 Function Templates [k1402]
# ------------------------------------------------------------------------------

# Summary

* Template functions define a family of functions for different
  template arguments.

* When you pass template arguments, function templates are
  instantiated for these argument types.

* The type of the arguments may be implicitly or explicitly deduced.

* You can overload function templates.

* When you overload function templates, limit your changes to
  specifying template parameters explicitly.

* All overload versions must be declared before calling them.


FACT_14_3
Function templates are functions that are parameterized so that they
represent a family of functions.


# 14.1.1 Defining the template

1) A function template is DEFINED inside a header file (14.5.1 The
   Inclusion Model)

WARNING Which means that it may be #included in multiple compilation sessions 


  [ Example:

  //myfunction.h  //basics/max.hpp

  template <typename T> 
  inline const T& max (const T &t1, conts T &t2) // DEFINITION in a header file
  {
    return (t1>t2) ? t1 : t2;
  }

  —end example ]


# 14.1.2 Using the template

Instantiation: the process of instantiating a "real" function/class
from a template definition.

Normally, the compiler generates different entities for every instantiation:


FACT_14_4
Templates are compiled twice
1. Without instantiation, the code itself for correct syntax.
2. At the time of instantiation, the templates code is checked to
   ensure that all calls are valid (i.e. unsupported function calls)

=>

PROBLEM
In practice, template instantiation requires that the compiler need to
see the template's definition => This breaks the usual compile and
link distinction

SOLUTION
Simplest approach: each template is implemented inside a header file
by using INLINE functions (14.5.1 The Inclusion Model)


# 14.1.3 Argument deduction

FACT_14_5
No automatic type conversion is allowed in calls to function templates. [k14104]


# 14.1.3.1 Implicit Argument deduction

Unlike class template parameters, function template parameters are
IMPLICITLY deduced from the types of their matching arguments.

  [ Example:

  double d1 = max (2.3, 4.5); // ok: implicit deduction: double(double, double)
  char cmx = max('0', '8');   // ok: implicit deduction:  char max(char, char)
  cmx = max(6, '8'); // error: no matching function for call to ‘max(int, char)’

  —end example ]


# 14.1.3.2 Explicit Argument deduction

  function-name <explicit-type-list> (function-arguments)

a) When the function template takes no arguments.
b) When you want to override the default type deduction.

  [ Example:

   int nmx = max<int>(false, 5.6); // ok: explicit int deduction
   max<double>(false, &d1);        // error: no matching function for call to
			   	   // ‘max(bool, double*)’
   float result = noargs_function<float>(); // ok: f. template takes no args.
  —end example ]


# 14.1.4 Template Parameters (14.6.1)

WARNING  template parameters VS template argumets: see 14.6.1.


# a) Template parameters

     template <typename T>   // T is a template parameter


# b) Call parameters

  ... max (const T &t1, conts T &t2)   // t1 and t2 are the call parameters




FACT_14_6
You may have as many template parameters as you like.


WARNING
Unlike class templates, in function templates NO default template
arguments can be specified (see 14.2.7)

=>

FUTURE
Maybe future compilers support this. ([3_102] 2.3)


# 14.1.5 Overloading Function Templates

As opposed to class templates, a function template does not support
partial specializations (see 14.1.5.2); instead, you use overloading.


# 14.1.5.1  Defining and using overloaded function templates

Template and nontemplate functions can coexist.The overload resolution
process normally prefers the nontemplate one.


  [ Example:

  const char *p1 = "string1";
  const char *p2 = "string2";
  const char *maxstr = max(p1, p2); //error: pointer comparison;
				    //lexicographical comparison required

  // overloading max()
  inline const char* & max(const char* & t1, const char* & t2)
  {
    int val = std::strcmp(t1,t2);
    if (val>0) return t1; else return t2;  
  }

  const char *maxstr = max(p1, p2); //ok: overloaded max() selected.

  —end example ]


WARNING
Note that in all overload implementations we pass arguments by
reference. In general it is a good idea not to change more than
necessary when overloading the function templates. Otherwise,
unexpected effects may happen. (See [3_102] page. 38-39)


# 14.1.5.2 Overloading vs partial specialization

Main difference.

a) Partial specialization doesn't introduce a new template, it extends an
   existing template.

b) An overloaded version INTRODUCES A NEW function, completely
   independent of any other overloads.

c) Overloading lookup: When the compiler has to choose which template
   version to use, it considers all of the overloaded versions
   TOGETHER, using the overload resolution rules to select the best fit.

d) Partial Spec. lookup: only the primary template is considered
   first. The, if the compiler finds a partial spec. of that template
   which template arguments that match the instantiation, the partial
   spec. is used.


5) Other differences:

a) You can specialize a member template of a class (i.e. a member
   function that is a template) without changing the class
   definition. However it's impossible to add an overloaded version of
   a member function without editing the class' definition.

b) When selecting templates, the argument matching rules are stricter
   than those of function overloading. Therefore it is possible to
   define specializations that rely on subtle parameter differences
   (i.e. T* vs const T*)

c) When you declare a function template f(T) as a friend, all
   instances thereof, say f<int>, f<char> etc. are granted the same
   privileges. However, you have to declare each overloaded version as
   a friend.


WARNING 
As a rule, you SHOULD always have all overloaded versions of a
function declared before the function is called. [3_102]


# ------------------------------------------------------------------------------
# 14.2 Class Templates [k1401] [k14101] [k14102]
# ------------------------------------------------------------------------------

# Summary

* A class template is a class that is implemented with one or more
  type parameters left open.

* To use a class template, you pass the open types as template arguments. The
  class template is then instantiated (and compiled) for these types.

* For class templates, only those member functions that are called are
  instantiated.

* You can (explicitly) specialize class templates for certain types.

* You can partially specialize class templates for certain types.

* You can define default values for class template parameters. These
  may refer to previous template parameters.


# 14.2.1 Declaration of Class Templates


Note.- In template <class T>.  Using class is equivalent to using typename.


1)  template <template_parameter_list> class class_name;

  [ Example: [k1401] [k14101]

  template <class T> class Vector;  //declaration


  template <class T> class Vector  //definition
  {
   private:

   size_t sz;
   T * buff;

   public:
   explicit Vector<T>(size_t s=100);
   ...
   
  }  

  —end example ]
  

# 14.2.1.1 Type and Name

2) In template <class T> class Vector;

   The type is: Vector<T> 

   The name is: Vector     // i.e. used in destructor and constructors


  [ Example: [k1401]

  // ok: TYPE:NAME : Vector<T>::Vector
  //
  template <class T>
  Vector<T>::Vector(size_t s): sz(s), buff(new T[s]){}    

  template <class T>
  Vector<T>::Vector<T>...   // error: ‘Vector<T>::Vector’ names the constructor,
			    // not the type Vector<T>::Vector<T>
  —end example ]


3) Within the scope of the class name (Vector in this examples,
   qualification with parameter T is redundant:

  [ Example: [k1401]

  explicit Vector(size_t s=100); // Declaration: name required, not type.

  ~Vector();            

  end example ]


# 14.2.2 Implementation (definition) of Member Functions

You have to specify that it is a function template:

    template <template_parameter>
    
And you have to use the full type qualification of the class template:

    return_type template_type::function_name(function_arguments)
    

4) Member functions can be defined outside the class body, following the class
   definition (in the same file)

  [ Example: [k1401] [k14101]

  template <class T>
  Vector<T>::Vector(size_t s): sz(s), buff(new T[s]){}    

  —end example ]


# 14.2.3 Use (instantiation) of Class Templates

You must specify the template arguments explicitly.

  [ Example: [k1401] [k14101]

    Vector<int>  v(4);

  —end example ]


5) A class template is not a "real" class.
   Instantiation: the process of instantiating a "real" class from a template.

6) (To accomplish the "generate on demand" policy (see T)) The
   compiler instantiates ONLY the necessary member functions of a
   given template specialization => the compiler generates code ONLY
   for the member functions which are used either explicitly OR
   IMPLICITLY in the program [k1401] [k14101]

7) If a class template has static members, these are instantiated ONCE
   FOR EACH TYPE.


# 14.2.4 (Explicit) Specializations of Class Templates [k14102]

8) An EXPLICIT specialization of a class template provides an alternative
   definition of the primary template. It is used instead of the primary
   definition (or a partial specialization) if the arguments match those
   that are given in the explicit specialization.

   Why needed?

   a) To optimize implementations for certain types.

   b) To fix a misbehaviour of certain types for an instantiation.


  [ Example:

    template <>		// <> indicates explicit specialization of a template
    class Vector <bool>	// <bool> template arguments

  —end example ]

  
9) If you specialize a class template, you MUST also specialize ALL its
   member functions.

10) Although it is possible to specialize a single member function,
    once you have done so, you can no longer specialize the whole class.

11) For these specializations, any definition of a member function
    must be defined as an "ordinary" member function, with each
    occurrence of T being replaced by the specialized type.

  [ Example:

    // primary template [k14101]
    template <typename T>               // template function 
    void Stack<T>::push(const T& elem)  
    ...


    //explicit spec. [k14102]
    // NOT a template function
    void Stack<std::string>::push(const std::string& elem); 

  —end example ]


# 14.2.5 Partial specialization

12) A partial specialization of a class template OVERRIDES the primary
    template for specific specializations. 

WARNING
The set of template arguments after the class name is the key.


  [ Example:

    // Declaration

    template <typename T1, typename T2> 
    class Myclass { ... };                // primary template


    // Partial specialization: both template parameters have same type
    template <typename T>
    class Myclass<T,T> { ... };


    // Partial specialization: second type is int
    template <typename T>
    class Myclass<T,int> { ... };


    // Partial specialization: both template parameters are pointer types
    template <typename T1, T2>
    class Myclass<T1*,T2*> { ... };

  —end example ]


13) The distinction between pointers and non-pointer types is needed.

  [ Example:

    v[0].destroy();  // vector of non-pointers
    v[0]->destroy(); // vector of pointers

  —end example ]

  \warning Specialization for pointers: we can either use pointers
  that point to values (no new, delete memory), or create new memory
  (delete) pointers. [k1401]



14) Instantiation: If more than one partial specialization matches
    equally well, the declaration is ambiguous.


  [ Example:

    // Instantiation

    Myclass<int,float> mif;	// uses MyClass<T1,T2>
    Myclass<float,float> mff; 	// uses MyClass<T>
    Myclass<float,int> mfi;	// uses MyClass<T,int>
    Myclass<int*, float*> mp; 	// uses MyClass<T1*,T2*>


    Myclass<int, int> m;   // ERROR: matches MyClass<T,T>, and MyClass<T,int>

    Myclass<int*, int*> m; // ERROR: matches MyClass<T,T>, and MyClass<T1*,T2*>


    // i.e. To resolve the ambiguity:
    template <typename T>
    class Myclass<T*,T*> { ... };
    
  —end example ]


15) The primary template shall be DECLARED before any specializations
    of that template. The specializations must be ordered: least
    specialized before more specialized, thus explicit specializations
    are defined the last.

  [ Example:

    template <class T> class Vector;               // primary #1
    {...};
    template <class T> class Vector <T*>;          // partial specialization #2
    {...};
    template <class T> class Vector <volatile T*>; // partial specialization #3
    {...};
    template <> class Vector <bool>                // explicit specialization #4
    {...}

  —end example ]


# 14.2.6 Template Arguments (see 4.6.1)

  < argument_1, argument_2, ... >

16) A template can take one or more type parameters (<T, U, ...>)

17) A template can take a template as a template argument

    Vector <Vector<char *> > msg_que;

    WARNING 
    When a template is used as a template argument, the space between
    the right two angle brackets is mandatory


# 14.2.7 Default Template Arguments [k14103]

18) Class templates can have default template arguments. 

    Goal: flexibility in choosing the optimal type for a particular application.
    
    i.e. using other types than size_t to manage very large or very
    	 small memory buffers.


  [ Example: [k1401]

  template <class T, class S = size_t> class Vector;
  ...
  Vector<int> ordinary;
  Vector<int, unsigned char> tiny(5);

  —end example ]

    
# ------------------------------------------------------------------------------
# 14.3 Nontype Template Parameters
# ------------------------------------------------------------------------------

# Summary

* Templates can have template parameters that are values rather than types.

* Nontype template parameters MUST be: constant integral types or the
  address of an object or function with external linkage.


1) For function and class templates, template can also take ordinary
   values as parameters (<int, char, bool, ...>)


# 14.3.1 Nontype Class Template Parameters

  See example [k14104]


# 14.3.2 Nontype Function Template Parameters

  [ Example: [k14105]

  //basics/addval.hpp
  
  template<typename T, int VAL> //VAL is a value rather than a type
  T addValue(const T& x)
  {
    return (x + VAL);
  }
  
  —end example ]


These kind of functions are useful if functions or operations are used
as parameters:

  [ Example: [k14105]

  std::transform(source.begin(), source.end(),
                 dest.begin(),
		 addValue<int,5>); //operation (function template)
  —end example ]


# 14.3.3 Restrictions for Nontype Template Parameters


2) When an ordinary type is used as a parameter, the template argument
   MUST be a constant or a CONSTANT EXPRESSION of an INTEGRAL TYPE
   (boolean, characters, integers, see 3.9.1.1 )

  [ Example: [k1401]

  const int cn = 5;
  int num = 10;
  const float cd = 5.0;  
  Array<char, 5> ac;              // ok: 5 is a const
  Array<char, cn> ac;             // ok: cn is a const
  Array<char, sizeof(float))> ac; // ok: constant expression used
  Array<char, num> ac;    	  // error: num is not a constant  
  Array<char, cd> ac;             // error: const float is not an integral type

  —end example ]


  Exceptions (other than constant expressions): 

  - pointer to a non-overloaded member
  - the address of an object or function with external linkage

  => this implies that a string literal cannot be used because they
     have internal linkage

  [ Example: [k14101]

  class MyClass { ... };

  const char* internal_linkage = "hello";
  MyClass<internal_linkage> x; //ERROR: internal linkage



  // BUT this is valid (according to [3_102])
  //
  // WARNING invalid in my test (C++14):

  extern const char external_linkage[] = "hello";
  MyClass<external_linkage> x; //OK

  //WARNING invalid in my test (C++14):
  //‘external_linkage’ has both ‘extern’ and initializer extern const
  //char external_linkage[] = "hello";

  —end example ]

 
# ------------------------------------------------------------------------------
# 14.4 Tricky Basics
# ------------------------------------------------------------------------------

# 14.4.1 Keyword Typename 

The keyword typename was introduced during the standardization of C++
to clarify that an identifier inside a template is as type.

1) In general, typename has to be used whenever a name that depends on
   a template parameter is a type. See 14.8.3.2 - [3_102].9.3.2 dor details.

  [ Example:

  class MyClass
  {
    typename T::Subtype * ptr;

    //with typename: ptr is a pointer to a type defined within class T

    //without typename: Subtype would be considered a static member of
    //class T, and then (T::Subtype * ptr) would be considered a multiplication

  };

  —end example ]


2) A typical use of typename is the access to iterators of STL
   containers in template code:

  [ Example: [k14105]

  //basics/addvaltest.cpp

  std::vector<int> dest {10,20,30};
  typename std::vector<int>::const_iterator citr;
  typename std::vector<int>::const_iterator citr_end = dest.end();
  for (citr = dest.begin();
      citr != citr_end;
      ++citr)
  {
    std::cout << *citr << " ";
  }


  template <typename T>
  void printcoll (const T& coll)
  {
    typename T::const_iterator pos; //iterator to iterate over coll
    typename T::const_iterator end(coll.end()); //end position

    for(pos=coll.begin();
    	pos!=end;
	++pos)
    {
     std::cout << *pos << ' ';
    }
   
  };


  // Where the type T::const_iterator has been declared inside each STL
  // container class

  class stlcontainer // i.e. vector, deque, ...
  {
   ...
   typedef ... iterator; // iterator for read/write access
   typedef ... const_iterator; // iterator for read access
   ...
  };
   
  —end example ]
   

# 14.4.1.1 The `.template' Construct

3) The .template notation (and similar notations such as ->template)
   should be used only inside templates and only if they follow
   something that depends on a template parameter. See 14.8.3.3 -
   [3_102].9.3.3 for details.


  [ Example:

  template <int N>
  void printBitset(std::bitset<N> const& bs)
  {
   std::cout << bs.template to_string<char, ....

   // without .template, the compiler does not know that the `<' token that
   // follows is not "less than" but the beginning of a template argument list.

  };

  —end example ]


# 14.4.2 Using this->  [k14106]

For class templates with base classes, using a name "name" by itself
is not always equivalent to this->name, even though a member name is
inherited.

  [ Example:

  template <typename T>
  class Base
  {
   public:
   void exit();  // not overloaded
   void exit2(); // overloaded
  };

  template <typename T>
  class Derived: public Base<T>
  {
   public:
    void exit2();
    void foo()
    {
	exit();  // ERROR Base::exit is never considered by the compiler, thus
             	 // either you have an error or an external exit() is called.
        Base<T>::exit(); // ok: calls Base::exit()
	this->exit();    // ok: calls Base::exit()
	exit2();         // ok: calls Derived::exit2()
	this->exit2();   // ok: calls Derived::exit2()
    }  
  };

  —end example ]


4) As a rule of thumb, we recommend that you ALWAYS qualify any symbol
   that is declared in a base that is somehow dependent on a template
   parameter with "this->" or with "Base<T>::". If you want to avoid
   all uncertainty, you may consider qualifying all member access (in
   templates). See 14.8.4.2 - [3_102].9.4.2 for details.


# 14.4.3 Member Template [k1403]

5) Template member AND member template ARE DIFFERENT things.

- Template member: is a member (var, fn), declared inside a class template.

- MEMBER TEMPLATE: IS A TEMPLATE declared inside a class or a class
  template. This is possible for both nested classes and member functions.


  [ Example:0

  template <class T>  class C
  {
   T *p;                 // a template member
   void f(T&) const;     // another template member 

   template <class T2> int f2(const T2&);  // a member template
  }

  —end example ]


6) Member templates are useful for solving the lack of implicit conversions 
   between different specializations of the same class template.

  [ Example:

  double dd =  3;      // trivial implicit converion to 3.0

  vector<int> vi {10};
  vector<double> vd;
  vd = vi;             // compilation error

  —end example ]


a) The Asymmetric Assignment Operator example: see [k14107] for the
   complete example.


# 14.4.4 Template Template Parameters [k14108]

7) You can also use class templates as template parameters, as
   so-called template template parameters.

GOAL: use templates with this notation:

      Stack<int, std::vector> vstack;

      instead this one:

      Stack<int, std::vector<int> > vstack;  // 2nd int is redundant


General expression:

	template<typename T,
                 template<typename ELEM> class CONT = std::deque> //OK

        //warning: CONT is used to define a class and must be declared with
	//         the keyword `class'
	template<typename T,
                 template<typename ELEM> typename CONT = std::deque> //ERROR


Simplified expression (when ELEM is not used inside the class):

	template<typename T,
                 template<typename> class CONT = std::deque>


8) Template template Argument Matching

Template template arguments must match exactly. Default template
arguments of template template arguments are ignored.


  [ Example: [k14108]

  //error because std::deque requires to parameters: (type, allocator)
  //
  template<typename T,
           template<typename> class CONT = std::deque> // ERROR

  template<typename T,
           template<typename ELEM, typename ALLOC = std::allocator<ELEM> >
	   class CONT = std::deque> //OK


  // declaration (simplified expression)
  template <typename T,
	  template<typename ELEM,
		   typename = std::allocator<ELEM> >
	  class CONT = std::deque>  //OK 
  class Stack { ... };

  // implementation
  template <typename T, template<typename,typename> class CONT>
  inline bool Stack<T,CONT>::empty()const { return elems.empty(); }

  —end example ]


9) Template template parameters for function parameters are not allowed


# 14.4.5 Zero Initialization

Before C++11, built-in types aren't default initialized, thus template
T built-in types neither.

10) Zero initialization in function templates:

  [ Example:

    template <typename T>
    void foo()
    {
      // T x; // before C++11, x is undefined

      T x =  T(); // zero init. for x
    }
    
  —end example ]


11) Zero initialization in class templates:

  [ Example:

    template <typename T>
    class MyClass
    {
      private:
      T x;     // before C++11, x is undefined

      MyClass(): x(); // zero init. for data member x, even for built-in types.<
    };
    
  —end example ]


# 14.4.6 Using string literals as Arguments for Function Templates

12) For string literals there is an array-to-pointer argument
    deduction if and only if the parameter is not a reference.


13) General problem:

a) string literals have different array types depending on their length:
   i.e. "apple" has type const char[6], "tomato" has type const char[7].

b) In a call to a function, during argument deduction, array-to-pointer
   conversion (decay) occurs only if the parameter isn't a reference.

   i.e.: void (std::string & val1); // NO decay
   	 void (std::string val1);   // decay occurs


14) Consequences in templates:

   In templates we know that implicit parameter deduction is executed
   upon calling a function template, and that all the template
   parameters must have the same type to be correct.

  [ Example: reference parameters (T&)  // basics/max5.cpp: passing by reference

    template <typename T>
    inline const T& max(const T& a, const T& b)
    {
      return a < b ? b : a; 
    };

    int main()
    {
      std::string s, s2;
      ::max("apple", "peach");  // OK: same type (const char[6])
      ::max("apple", "tomato"); // ERROR: different types
      ::max("apple", s);        // ERROR: different types
      ::max(s,s2);              // OK: same type (std::string)
      ::max<std::string>("apple", "tomato"); // OK: same type (std::string)
    }
    
  —end example ]


  [ Example: value parameters (T)   // basics/max6.cpp: pasing by value

    template <typename T>
    inline const T max(const T a, const T b)
    {
      return a < b ? b : a; 
    };

    int main()
    {
      ::max("apple", "peach");  // OK: same type (const char[6])
      ::max("apple", "tomato"); // OK: decays to same type
      ::max("apple", s);        // ERROR: different types
    }
    
  —end example ]


15) Possible solutions; depending on the context you can:

a) Use nonreferences instead of references => unnecessary copying 

b) Overload both reference and nonref. parameters => potential ambiguities

c) Overload with concrete types (such std:string)

d) Overload with array types, for example:

      template <typename T, int N, int M>
      const T* max(T const(&a)[N], T const(&b)[M])
      { return a < b ? b : a; }

e) Force application programmers to use explicit conversions.


# ------------------------------------------------------------------------------
# 14.5 Using Templates in Practice
# ------------------------------------------------------------------------------

* Templates challenge the classic compiler-plus-linker model. Therefore there
  are different approaches to organize template code: the inclusion model,
  explicit instantiation, and the separation model.


# 14.5.1 The Inclusion Model

1) This is the most popular approach (as of the time of writing:
   November 12, 2002) to organize template source code.


# 14.5.1.1 Linker Errors

2) If we separate the template declaration (.h file) and the template
   definition (.cpp file), then the compiler can't instantiate the
   template, thus it can't create the instantiation unit (2.1.b); the
   compialtion might be all right, but the linker can't find the
   references to the template code.


# 14.5.1.2 Templates in Header Files

3) When we include all template declarations and definitions in the
   same (header) file, the code correctly compiles, links, and executes.
   This way of organizing templates is called the inclusion model.

4) The inclusion model ensures that all the needed templates are
   instantiated. This happens because the C++ compilation system
   automatically generates those instantiations as they are needed.

5) The inclusion model computational cost problem:

WARNING
This approach considerably increase the cost of including the template
header files because it must also cause the inclusion of all the
headers already included in the template header file (i.e. all the std
libraries) => THIS IS A REAL PROBLEM IN PRACTICE.

NOTE (from [3_102])
Despite this build-time issue, we do recommend following this
inclusion model to organize your templates when possible. We examine
two alternatives, but in our opinion their engineering deficiencies
are more serious than the build-time issue discussed here.


6) Another (more subtle) observation about the inclusion approach is
that NONINLINE FUNCTION TEMPLATES are distinct from inline functions
and macros in an important way: THEY ARE NOT EXPANDED AT THE CALL
SITE. Instead, when they are instantiated, they create a new copy of a
function. Because this is an automatic process, a compiler could end
up creating two copies in two different files, and some linkers could
issue errors when they find two distinct definitions for the same
function. In theory, this should not be a concern of ours: It is a
problem for the C++ compilation system to accommodate. In practice,
things work well most of the time, and we don't need to deal with this
issue at all. For large projects that create their own library of
code, however, problems occasionally show up. A discussion of
instantiation This document was created by an unregistered ChmMagic,
please go to http://www.bisenter.com to register it. Thanks .  90
schemes in Chapter 10 and a close study of the documentation that came
with the C++ translation system (compiler) should help address these
problems.


# 14.5.2 Explicit Instantiation

a) Inclusion model: AUTOMATIC IMPLICIT instantiation BY THE COMPILER.

b) Explicit Instantiation directive: MANUAL EXPLICIT instantiation BY THE CODER.

   [ Example

     // declaration of template
     template <typename T>
     void print_typeof (T const&);

     // explicitly instantiate print_typeof() for type double
     template void print_typeof<double>(double const&);
     	      //
     	      // keyword template
	      // change T by the explicit type: double here
     
   end-example ]


7) (GIANT) PROBLEM

Each directive should appear only once in a program. Not following
this rule usually results in linker errors that report duplicate
definitions of the instantiated entities
=> For large projects this quickly becomes an excessive burden
=> hence we ([3_102] authors) do not recommend it.


8) ADVANTAGES

* The overhead of large headers is avoided.

* The source code of template definition can be kept hidden, but then
  no additional instantiations can be created by a client program.

* For some applications it can be useful to control the exact location
  (that is, the object file) of a template instance.


# 14.5.2.1 Example of Explicit Instantiation

  See [3_102] 6.2.1 for details.


# 14.5.2.2 Combining the Inclusion Model and Explicit Instantiation

  See [3_102] 6.2.2 for details.


# 14.5.3 The Separation Model

WARNING
9) We stop here because the current standard (C++14) does not support the
keyword `export' (2.11)


# 14.5.4 Templates and inline

WARNING
10) If you write function templates that should be handled as inline
functions, you should use the inline specifier (unless the function is
inline already because it is defined inside a class definition).


  [ Example:

    // declaration

    template <typename T>
    class MyClass
    {
	public:

	void memfun2() // implicitly inline
	{ ...   }
	
    	void memfun3(); // explicitly inline
    };

    // definition
    
    
    template <typename T>
    inline                       // explicitly inline
    void MyClass<T>::memfun3 ()
    { … }
  
  —end example ]
  

# 14.5.5 Precompiled Headers

* Problem: compilation time due to headers inclusion

* Proposed scheme solution:

The precompiled header scheme relies on the fact that code can be
organized in such a manner that many files start with the same lines
of code (include directives) . The these common N lines of code can be
precompiled and then, for every file in our program, we could reload
the saved state and start compilation at line N+1.

To take advantage of precompiled headers, be sure to keep the same
order fo#r include directives.

WARNING
This scheme operates outside the scope of the standard and relies on
vendor-specific options.

See [3_102] 6.5 for details.


# 14.5.6 Debugging Templates

To debug a template after a successful compilation (does it work as
expected ?), there are different approaches: tracers, oracles, archetypes.

# 14.5.6.1 Tracers

A tracer is a user-defined class that can be used as an argument for a
template to be tested.

Tracers allow us to trace the execution of templates only for specific
input data and for a specific behavior of its related functionality.

  [ Example:

    SortTracer to trace the STL::sort algorithm:
    
  —end example ]
  

See [3_102] 6.6.4 for details.


# 14.5.6.2 Oracles

An extension of tracers is known in some circles as oracles (or
run-time analysis oracles). They are tracers that are connected to a
so-called inference engine—a program that can remember assertions and
reasons about them to infer certain conclusions.


# 14.5.6.3 Archetypes

When such a minimal tracer does not generate run-time output, it is
sometimes called an archetype.



# 14.6 Basic Template Terminology

# 14.6.1 Template Arguments versus Template Parameters


1) In short, you can say that you "pass arguments to become parameters."

  [ Example:

    template <typename T, int N>	// T, N: template parameters 
    class ArrayInClass
    {
	public:
    	T array[N];
    };

    int main()
    {
	ArrayInClass<double,10> ad;	// double, 10: template arguments
    	...
    }

  —end example ]


FACT_14_7
Any template argument must be a quantity or value that can be
determined at compile time.

   =>

   Because template parameters are eventually substituted by compile-time
   values, they can themselves be used to form compile-time expressions.
   
   =>

   Because template parameters are compile-time entities, they can
   also be used to create valid template arguments.


  [ Example:

    template <typename T>
    class Dozen
    {
      public:
    	ArrayInClass<T,12>contents;  // T: both parameter and argument
    };

  —end example ]


NOTICE As becomes clear later, this requirement translates into
       dramatic benefits for the run-time costs of template entities.


# ------------------------------------------------------------------------------
# 14.7 Friends [1_1].14.5.4
# ------------------------------------------------------------------------------

1) A friend of a class or class template can be:
   - a function template
   - a class template
   - a specialization of a function template
   - a specialization of a class template
   - a non-template function or class.

  [ Example:
  
    template<class T> class task;
    template<class T> task<T>* preempt(task<T>*);
    
    template<class T> class task
    {
      friend void next_time();
      friend void process(task<T>*);
      friend task<T>* preempt<T>(task<T>*);
      template<class C> friend int func(C);
      friend class task<int>;
      template<class P> friend class frd;
    };
    
  —end example ]

2) A friend template may be declared within a class or class template.
   A friend function template may be defined within a class or class template.

   A friend class template may NOT be defined in a class or class template.

   In these cases, ALL SPECIALIZATIONS of the friend class or friend function
   template are friends of the class or class template granting friendship.


  [ Example:
  
    class A
    {
	template<class T> friend class B;    // OK: t. class declaration
    	template<class T> friend void f(T)   // OK: t. function definition
	{ /* ... */ }

	template<class T> friend class B    // ERROR: t. class definition
	{ /* ... */ }

    };
    
  —end example ]


3) A template friend declaration specifies that all specializations of
   that template, whether they are implicitly instantiated,
   partially specialized or explicitly specialized,
   are friends of the class containing the template friend
   declaration.
 
  [ Example:

    class X
    {
      template<class T> friend struct A;  // All specs. of A are friends of X
      class Y { };
    };
    template<class T> struct A { X::Y ab; };     // OK
    template<class T> struct A<T*> { X::Y ab; }; // OK
    
  —end example ]


4) When a function is defined in a friend function declaration in a class
   template, the function is instantiated when the function is odr-used.

5) A MEMBER of a class template may be declared to be a friend of a
   non-template class. In this case, the corresponding member of every
   specialization of the primary class template and class template
   partial specializations thereof is a friend of the class granting
   friendship.

   For explicit specializations and specializations of partial
   specializations, the corresponding member is the member (if any)
   that has the same name, kind (type, function, class template, or
   function template), template parameters, and signature as the
   member of the class template instantiation that would otherwise
   have been generated.

   [ Example:

     template<class T> struct A
     {
	struct B { };
	void f();           
	struct D
	{
	 void g();
	};
     };

     template<> struct A<int>
     {
	struct B { };
	int f();       // different return type => not an specialization
	               // but a different function
	struct D
	{
	  void g();
	};
     };
     
     class C
     {
	template<class T> friend struct A<T>::B;
	//
	// grants friendship to A<int>::B even though
	// it is not a specialization of A<T>::B
     
	template<class T> friend void A<T>::f();
	//
	// does not grant friendship to A<int>::f()
     	// because its return type does not match

     	template<class T> friend void A<T>::D::g();
	//
	// does not grant friendship to A<int>::D::g()
     	// because A<int>::D is not a specialization of A<T>::D

     };
     
   —end example ]


7) A friend template shall not be declared in a local class.

8) Friend declarations shall not declare partial specializations.

   [ Example:

     template<class T> class A { };
     class X
     {
	template<class T> friend class A<T*>; // error
     };

   —end example ]

9) When a friend declaration refers to a specialization of a function
   template, the function parameter declarations shall not include
   default arguments, nor shall the inline specifier be used in such a
   declaration.


# ==============================================================================
# 16 Preprocessing directives
# ==============================================================================

# 16.2 Source file inclusion

1) A "#include" directive shall identify a header OR SOURCE file that can be
   processed by the implementation.

2) # include < h-char-sequence> new-line

   - Header search: in a sequence of implementation-defined places.
   - Replacement of that directive by the entire contents of the header. 

3) # include " q-char-sequence" new-line

   - Header search: the source between "", in an
     implementation-defined manner (usually by relative path)
   - Replacement of that directive by the entire contents of the header.
   
   WARNING
   On search failure: the directive is reprocessed as if it read #include <..>
   # include < h-char-sequence> new-line

4) # include pp-tokens new-line

  pp-tokens are processed as a macro. If the directive resulting after
  all replacements does not match one of the two previous forms, the
  behavior is UNDEFINED.

  (e.g.)
  
  #if VERSION == 1
  #define INCFILE "vers1.h"
  #elif VERSION == 2
  #define INCFILE "vers2.h" // and so on
  #else
  #define INCFILE "versN.h"
  #endif
  
  #include INCFILE

7) In general programmers should use the < > form for headers provided
   with the implementation, and the " " form for sources outside the
   control of the implementation.


# ==============================================================================
# todo 25 Algorithms library
# ==============================================================================

https://en.cppreference.com/w/cpp/algorithm


remove_if: see # X.1 Erase-remove idiom [4_14_1] [k2501] 


for_each:

[ Example -  for_each and method overloading (13 Overloading)

  // How to call an specific class::method while iterating?
 
  class Example
  {
   public:
   
      void calculateCapacity();
      void calculateCapacity(string interval) { ... }
   ...      
  };


  //------

 void Example::calculateCapacity()
 {
  // e.g. std::vector<std::string> = { "a", "b", "c" }

  // How to call an Example::calculateCapacity(std::string) 


  std::for_each
     (std::begin(some_collection), std::end(some_collection),
      std::bind(static_cast<void(Example::*)(std::string)>                   //*1
  	       (&Example::calculateCapacity), this, std::placeholders::_1)); //*2
 }

 //*1 : explicitly passes to std::bind the method to overload
 //*2 : arguments to std::bind: method, object owner of the method, method params

end example ]


# ==============================================================================
# 27 Input/output library
# ==============================================================================

# 27.0 A First Look at Input/ Output [3_1].page30

a) The library

C++ IO = iostream library: part of the std library that defines the IO classes.

#include <iostream>

- istream: input stream
- ostream: output stream


HINT Use '#include <iosfwd>' (iostream declarations only) In a header
     file to improve compilation time.


b) streams functions

- Always two arguments: (std::stream &, [const] object & )

- Always return a reference to the stream object

WARNING always pass a NON-CONST reference to the stream as the first argument


- ostream

    //!\warning 2ND ARGUMENT SHOULD be CONST
    std::ostream& operator<<(std::ostream &, const T &);


- istream 

  //!\warning 2nd argument MUST NOT be CONST because it is to be modified
  std::istream& operator>>(std::istream &, T &);


  [ Example:

  
  std::istream &operator>>(std::istream &is, Sales_item &obj)
  {
   double price;
   is >> obj.the_isbn >> obj.the_num_sold >> price;

   if (is)  // check that the inputs succeeded
      obj.the_revenue = price*obj.num_sold();
   else 
      obj = Sales_item();  // input failed: reset object to default state

   return is;
  }

  —end example ]



c) Standard Input and Output Objects  [k3]


WARNING Syntax always:  stream STREAM_OPERATOR variable ';'


- cin (standard input)

      int retval = 0;
      std::cin >> retval;    // TRICK flow of info: input  --->>  program

- cout (standard output):

      std::cout << retval;   // TRICK flow of info: output <<---  program

- cerr (standard error)

- clog


INFO std::endl, also flushes the buffer (no need for std::flush) 



# ==============================================================================
# Appendix A - Advanced concepts
# ==============================================================================

# ------------------------------------------------------------------------------
# A.1 Reference and Value Semantics  [4_4_1] 
# ------------------------------------------------------------------------------

FACT_1 There are three cases when you have an actual object as opposed
       to a pointer to an object:

       i) local objects

       ii) global/static objects,

       iii) composition: fully contained member objects in a class
       	    (the most important)
       	    

FACT_2 Pros of value semantics: speed (one copy but several accesses)


FAQ Data members: Should I normally use Composition or Pointers  [4_4_1] 

>> Your should NORMALLY use composition

>> Exception examples: “wrapper” objects; also the N-to-1-uses-a
   relationship needs something like a pointer/reference)


- "The 3 performance hits": there are three reasons why “composition”
  has better performance than pointers to freestore-allocated member objects:

   1) Extra layer of indirection every time you need to access the member object

      Cost: "small potatoes"

   2) Extra freestore allocations (new in constructor, delete in destructor)

      Cost: can be an issue when there are many allocations.
      
   3) Extra dynamic binding (comes from having a pointer rather than an object.)

      Cost: great


FAQ What are relative costs of the 3 performance hits [4_4_1] 

>> (See 1-2-3 above)

Whenever the C++ compiler can know an object’s class =>
=> virtual function calls can be statically bound: allows inlining =>
=> Inlining allows zillions optimization opportunities

WARNING Thus fully-contained member objects allow significant
	optimizations that wouldn’t be possible under the “member
	objects-by-pointer” approach. This is the main reason that
	languages which enforce reference-semantics have “inherent”
	performance challenges.


FAQ  Are “inline virtual” member functions ever actually “inlined”? [4_4_1] 

>> Occasionally...

   ... when the compiler knows the “exact class” of the object which
   is the target of the virtual function call:

   i.e. local object, a global/static object, or a fully contained
   object inside a composite;

   i.e. sometimes happen even with a pointer or reference => when it
   is clear the actual type of the object (see example at [4_4_1]


WARNING The difference between inlining and non-inlining (up to 25X
	speed degradation), is normally much more significant than the
	difference between a regular function call and a virtual
	function call.



FAQ Sounds like I should never use reference semantics, right?  [4_4_1] 

>> Wrong.

(i) Therefore C++ gives us an ideal situation: we choose reference
   semantics for objects that need unique identity ("problem space
   objects") or that are too large to copy, and we can choose value
   semantics for the others ("solution space objects").

(ii) Generally, objects that are part of an inheritance hierarchy
    should be passed by reference or by pointer.


>> By (i) & (2): Unless compelling reasons are given to the contrary,
   member objects should be by value and parameters should be by
   reference. [note-3]


\todo FAQ  What is value and/or reference semantics, and which is best in C++?
\todo FAQ  What is “virtual data,” and how-can / why-would I use it in C++?
\todo FAQ  What’s the difference between virtual data and dynamic data?


# ==============================================================================
# Appendix B - Debug, memory, ...
# ==============================================================================

# B.1 Aids for Debugging: assert and NDEBUG [3_1].6.5.3

# B.1.1 assert

  #include <cassert>
  assert(boo_expr);

1) assert is a preprocessor macro: managed by the preprocessor, not
   the compiler.


# B.1.2 The NDEBUG Preprocessor Variable

2) If NDEBUG is defined, assert does nothing.

3) Most compilers provide a command-line option that lets us define
   preprocessor variables:

  [ Example:

  
  $ CC -D NDEBUG main.C # use /D with the Microsoft compiler has the same effect
       	  	 	# as writing # define NDEBUG at the beginning of main.C

  —end example ]
  

# B.1.3 Aid debugging messages.

a) Defined by the compiler:

   _ _func_ _   // it is a local static array of const char
   	      	// that holds the name of the function.


b) Defined by the preprocessor:

   _ _FILE_ _ string literal containing the name of the file
   _ _LINE_ _ integer literal containing the current line number
   _ _TIME_ _ string literal containing the time the file was compiled
   _ _DATE_ _ string literal containing the date the file was compiled


c) EXIT_FAILURE, EXIT_SUCCESS  // #include <cstdlib> 

   A zero return indicates success; most other values indicate failure.
   A nonzero value has a machine-dependent meaning. To make return values
   machine independent, the cstdlib header defines two preprocessor
   variables that we can use to indicate success or failure:

   [ Example: 

   if (word.size() < threshold)
   {
      cerr << "Error: " << __FILE__
      << " : in function " << __func__
      << " at line " << __LINE__ << endl
      << " Compiled on " << __DATE__
      << " at " << __TIME__ << endl
      << " Word read was \"" << word
      << "\": Length too short" << endl;

      return EXIT_FAILURE;
   }
   else
      return EXIT_SUCCESS;	

   Result:
   "Error: wdebug.cc : in function main at line 27
   Compiled on Jul 11 2012 at 20:50:03
   Word read was "foo": Length too short"

   -end example ]


# ------------------------------------------------------------------------------
# B.2 gdb
# ------------------------------------------------------------------------------

B.2.1 Handling cores

1 Use gdb to analyze the core in offline mode:

  gdb <program-that-cause-the-core> <core-file>

  [ Example

    gdb ./../pruebas_rman/rman core_rman_SDS-1_15997

  end example ]


2 You can find out where the program is, i.e. where the segmentation
  fault occurred, using the where command. This gives a function call
  trace of how you got to this point and shows line numbers inside files.

  [ Example

    (gdb) where
    #0  0x2350 in DoOperation (ptrs=0x18bc0) at gdbprog.cc:24
    #1  0x24b0 in main () at gdbprog.cc:45

  ]


# ------------------------------------------------------------------------------
# B.3 memory analysis 
# ------------------------------------------------------------------------------

# B.3.1 valgrind tool

  valgrind [valgrind-options] [your-program] [your-program-options]

  (i.e.)  valgrind --leak-check=yes ./a.out


# ==============================================================================
# Appendix C - Compilation, Linkage, ...
# ==============================================================================


# C.0. Compiling and Executing Our Program [3_1].page28

- Naming convention (required by the compiler): .cc, .cxx, .cpp, .cp, and .C.

- Compilation command:

  > g++ file.cpp              # (1 step) compiler generates EXECUTABLE "a.out"
  
  > g++ -c file.cpp           # compile but not run the linker (file.o)
    g++ file.o                # ... and link ("a.out" generated)


// WARNING a main() function is required to generate an executable.


- Value returned by main. Check error status

  # No error (0)
  >> echo $?
     0

  # Error code (!=0)
  >> echo $?
     98      # i.e. 98


WARNING Linking: if any of these options is used (-c, -S, -E), then
	the linker is not run, otherwise gcc & g++ always run the
	linker.


# C.1. 'gcc' versus 'g++'  Compilation [2_1]


CODE_EXAMPLES  [k1]


INFO 'gcc' refers generically to the complete suite of tools (c, c++,
     ADA, ... compilers), and also to the C compiler. 


HINT
  - g++: compile & link both C++ & C sources (as C++ code)

  - gcc: does not (explicitly) link C++ sources 


a) gcc: C compiler

INFO gcc will also compiles C++ source files (ALWAYS AS C++ CODE),
     BUT it will not link in the C++ library automatically.

     To compile & link C++ code with gcc: explicitly call to the C++
     standard library '-lstdc++' (link std c++)

     (i.e.) gcc c++_code.cpp -lstdc++
     

b) g++: C++ compiler

  g++ Compile & link C++ code (automatically includes the C++ library)


INFO g++ treats ‘.c’, ‘.h’ and ‘.i’ files as C++ source files instead
     of C source files unless -x is used

INFO g++ is also useful when precompiling a C header file with a '.h'
     extension for use in C++ compilations.

HINT How to compile C source code as actual C code with g++: using the
     '-x c' option (i.e. g++ -x c c_code.c)

HINT Compilation of multiple formats in one line: -xc & -xc++ options
     g++ -c -x c dummy_c_code.c -x c++ dummy_c++_code.cpp


WARNING g++ does not links C code as actual C code, gcc must be used
	to the linkage instead

	(i.e.compiled & linked as C code)
	g++ -x c -c c_code.c       // OK (compiled as C code)
	gcc c_code.o               // OK (linked as C code)

	(i.e. linked as C++ code)
	g++ -x c -c c_code.c       // OK (compiled as C code)
  	g++ c_code.o               // OK (linked as C++ code)


WARNING Depending on the release of the GNU compiler you are using,
	you may need to specify -std=c++0x to turn on C++11 support.


WARNING C++11 support:
-std=c++11   (plain C++11 standard)
-std=gnu++11 (gnu extentions violating the standard are enabled)


WARNING C++14 support  \todo


# C.2. File naming

CODE_EXAMPLES  [k2]

a) Source file names

   - Usually (depending on the file system), ends with a suffix. The
     suffix tells the system that the file is a C++ program.

   - Different compilers use different suffix conventions; the most
     common include .cc, .cxx, .cpp, .cp, and .C.


WARNING Compilers actually DO CARE about the form of source file names:
	[k2].test_source_suffix.cpp

	(e.g.) g++ test_source_suffix 
	       test_source_suffix: file not recognized:
	       No se reconoce el formato del fichero
	(e.g.) g++ test_source_suffix.any
	       test_source_suffix.any: file not recognized:


b) Header file names

   - Usually have a suffix '.h', but some PROGRAMMERS use '.H', '.hpp', '.hxx'

   - The standard library headers typically have no suffix at all.


WARNING Compilers usually DON’T care about the form of header file
	names, but IDEs sometimes do. [k2].test_header_suffix.cpp


# C.3. Name mangling: C & C++ compatibility

- The C++ compiler performs what is known as name-mangling - the names
  that appear in your code are not the same ones as your linker sees.


a) Using C functions in a C++ file [4_1]

  // myfile.cpp
  extern "C" int libfun();    // C function in your library

  // or do it for a whole header file:

  extern "C" {
  #include "mylibdefs.h"      // defs for your C library functions
  }


b) Making a C-header file itself work in both languages and correctly
   declare its functions as C-like to C++ [4_1]

     - In the header file:

     #ifdef __cplusplus
     extern "C" {
     #endif

     [ C code here ]
     
     #ifdef __cplusplus
     }
     #endif


     - In a source C++ file 

     extern "C" {
     #include "customlibrary.h"
     }


     - In a source C file

     #include "customlibrary.h"



# C.4. Compilation options (see man gcc)

  -c   // compile but not run the linker (file.o)

       gcc -c file.cpp


  -o file  // Place output in file file.
     	   //
	   // This applies to whatever sort of output is being
	   //produced, whether it be an executable file, an object
	   //file, an assembler file or preprocessed C code.

      gcc -o file dummy_c_code.c 


  -v  // verbose


  -E   // Stop after the preprocessing stage; do not run the compiler proper.
  

  -S  // Stop after the stage of compilation proper; do not assemble.      


# C.5. Linkage

WARNING linkage error "undefined reference to ..."

Causes:

a) Using gcc instead of g++ compiler.


b) Not providing all the ".gcc" files to the linker

   - How to detect this:

     Try g++ *.cpp. Is this works then this error is the problem.


   - (e.g) code_examples/B1_memory_references/Makefile

     ERROR:

     OBJS=refs_lib.o
     all:$(MAIN)
     $(MAIN):$(MAIN).o $(OBJS)

     > make all

     g++ -o references_test references_test.o

   references_test.o: En la función `main':
   references_test.cpp:(.text+0xe2): undefined reference to `ftest1_ref_as_fnparam(int&)' 
   collect2: error: ld returned 1 exit status


     Solution:
   
     $(MAIN):$(MAIN).o $(OBJS) 

     > make all
     g++ -o references_test references_test.o refs_lib.o

     Now 'refs_lib.o' is passed to the linker


c) Some functions has been declared (some '.h' file), but not defined
   in its correspond '.cpp' file.
   


WARNING linkage error " multiple definitions of ..." [k11]

Causes:

a) Global variable declared [and defined] in a ".h" file that is
   included by two or more other files:

   After compile those source files, the global variable will be
   defined in all of the object files, so the linker will complain
   about multiple definitions.


   (e.g.) // header.h
   	  #ifndef _HEADER_H
	  #define _HEADER_H

	  int my_global_var;

	  #endif


	  // a.cpp
	  #include "header.h"

	  // b.cpp
	  #include "header.h"


Solution: define as a constant instead -> no longer defined in any of
	  the includer files

   (e.g.) // header.h
   	  const int my_global_var = 27;


Solution: declare the variable as 'extern' (in one or many header
	  files), and then define the variable in one and only one of
	  the source files.

	  'extern' keyword tells the compiler that the variable is
	  defined somewhere else. So, no new global object entries
	  will be written to the object files.

   (e.g.) // header.h

   	  #ifndef _HEADER_H
	  #define _HEADER_H

	  extern int my_global_var;

	  #endif


	  /* ... Then, to avoid 'undefined symbol error', declare the
	     variable in one of the sources. */

	  // a.cpp
	  #include "header.h"

	  int my_global_var;


	  /* --- Now  b.cpp will obtain the value of 'my_global_var' via
	     the 'extern' variable. */

	  /*!\warning anyway, if b.cpp is compiled before a.cpp first, then
	  'my_global_var' will not be defined => AVOID global vars. */



# C.6. C++11 compilation options  [6]

[-Wc++11-compat] 

   Warn about C++ constructs whose meaning differs between ISO C++
   1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are
   keywords in ISO C++ 2011. This warning turns on -Wnarrowing and is
   enabled by -Wall.

   Note.- enabled by -Wall


[-Wmissing-field-initializers]

   Warn if a structure's initializer has some fields missing. For example, the
   following code causes such a warning, because x.h is implicitly zero:

          struct s { int f, g, h; };
          struct s x = { 3, 4 };

   Note.- enabled by -Wextra

   Note.- To get other -Wextra warnings without this one, use:
   	  -Wextra -Wno-missing-field-initializers


[-Wzero-as-null-pointer-constant] (C++ and Objective-C++ only)

    Warn when a literal ‘0’ is used as null pointer constant. This can
    be useful to facilitate the conversion to nullptr in C++11.


# C.7. Static libraries  [6_4]

Details: see ../../ferlib/libraries/static_howto/

# C.8. Shared libraries

Details: see ../../ferlib/libraries/shared_howto/


# ==============================================================================
# Appendix I - Undocumented Issues
# ==============================================================================

# I.1 Local static variables are shared by all the objects of its trans. unit

  FACT: They are just like "class variables", but with local scope
  	 (scope = the function they are defined)

  
  [ Example:  Example

  class Dummy_Static
  {
     void f_with_local_static() 
     {
       static int local_static_var= 0; //!\warning  SHARED by all the objects
     }
  };

  —end example ]
  


# ==============================================================================
# Appendix K - Code examples (./code_examples)
# ==============================================================================

# Compilation, Linkage, "./code_examples/compilation_linkage

  [k1] 'gcc' versus 'g++' compilation - "gcc_vs_c++"

  [k2] File naming - "file_naming"

  [k11] multiple definitions of... linkage error -
  "linkage/multiple_definitions_error"


# Chapter 3 Basic concepts - "./3_basic_concepts/"

  [k3101] extern declaration - "./3_1_declarations_and_definitions/extern"

  3.2 One-definition rule - "./3_basic_concepts/3_2_onedef_rule/"

  [k3201] class scope - "./namespace_scope_test.cpp"


  3.3 scope test - "./3_basic_concepts/3_3_scope/"
  
  [k3306] class scope - "./namespace_scope_test.cpp"
  [k33062a] global scope - "./global_namespace_name_test.cpp"
  [k3310] name hiding - "./name_hiding"  

  3.4 Name lookup - "./3_basic_concepts/3_4_name_lookup/"

  [k3401]  Unqualified name lookup - ./lookup_test.cpp
  [k34032] Qualified name lookup - Namespace members - ./lookup_test.cpp 
  

# io_first_look  "./code_examples/io_first_look/"

  [k3] cin & cout - basic_io_example.cpp


# iteration statements  "./code_examples/statements/iteration_statements"

  [k4]
  read until EOF -  read_until_eof.cpp


# references (lvalue references: &)

  [k5] using references - "./code_examples/references"


# constructors "./code_examples/constructors"

  [k6] Converting vs explicit constructors - "./explicit_constructor"

  [k8] default_ctor - "./default_ctor/main.cpp"

  [k9] the "static initialization order" fiasco - "./static_init_order_fiasco"

  [k10] The "Foo x(Bar())" tricky problem - "./tricky_foo_bar"

  [k12] construction_order - "./ctor_order/good_init_test.cpp"

  [k13] undef. construction_order - "./ctor_order/bad_order/undef_init_test.cpp"


# Virtual functions - "./virtual_functions"

  [k14] virtual_vs_nonvirtual_test - virtual_vs_nonvirtual_test.cpp


#  11 member access control - "./11_member_access_control"

  [k1101] virtual_vs_nonvirtual_test - virtual_vs_nonvirtual_test.cpp


# initializers - "./code_examples//initializers"

  [k8501] cpp98 vs cpp11 init - "./cpp98" &  "./cpp11"

  [k8502] aggregates - "./aggregates/aggregates_test.cpp"

  [k8503] pods - "./aggregates/pods/pod_test.cpp"


# templates - "./code_examples/14_templates"

  [k1401] class template example - "./class_template"

  [k1402] function template example - "./function_templates"

  [k1403] member template example - "./member_templates"
 

  [k14100] C++Templates_TheCompleteGuide - "./C++Templates_TheCompleteGuide"
  [k14101] class template example - "./basics/stack1test.cpp"
  [k14102] class template specialization - "./basics/stack2test.cpp"
  [k14103] default template arguments - "./basics/stack3test.cpp"
  [k14104] nontype template arguments - "./basics/stack4test.cpp"
  [k14105] nontype function template args. - "./basics/addvaltest.cpp"
  [k14106] Tricky Basics - "./basics/trickybasicstest.cpp"
  [k14107] Member templates, The Asymmetric Assignment Operator - 
  	   "./basics/asyn_assig_operatortest.cpp
  [k14108] Template Template Parameters - "./basics/stack8test.cpp
  [k14109] Templates and Non-Templates sharing header - "./lib_units_example/"


# Chapter 17 Basic concepts - "./3_basic_concepts/"

# Chapter 25 Algorithms library - "./25_algorithms_library/"

  [k2501] remove_if algorithm VS hand-written loop - "./remove"


# Appendix I - Undocumented Issues - "./code_examples/issues"

  [KI001]  static issues- "./static"


# ==============================================================================
# Appendix S - New Features 
# ==============================================================================

# S.1 New Features in C++11

  - In-Class Initializers (8.5.5)

  - std::ref:

# S.1.1 Strongly typed enums

https://www.cprogramming.com/c++11/c++11-nullptr-strongly-typed-enum-class.html

	
// this code will compile (if your compiler supports C++11 strongly typed enums)
enum class Color {RED, GREEN, BLUE}; 
enum class Feelings {EXCITED, MOODY, BLUE}; //C++98 error: BLUE already defined


Strongly typed enums, enum classes, also have better scoping. Each
enum value is scoped within the name of the enum class.
	
Color color = Color::GREEN;
if ( Color::RED == color )
{
    // the color is red
}


# S.1.2 Lambda functions (closures)

http://en.cppreference.com/w/cpp/language/lambda

https://www.cprogramming.com/c++11/c++11-lambda-closures.html

http://www.drdobbs.com/cpp/lambdas-in-c11/240168241?pgno=2



1) Sintaxis:

[ captures ] (parameters) -> returnTypesDeclaration { lambdaStatements;


[ captures ]: The capture clause, also known as the lambda introducer,
  specifies which outside variables are available for the lambda
  function and whether they should be captured by value (copying) or
  by reference. You will always be able to identify the start of a
  lambda expression with the presence of the capture clause. An empty
  capture clause [] means capture nothing, in which case the lambda
  expression body doesn't access variables in the enclosing
  scope. I'll dive deeper into capture defaults later.

( parameters ): This is the optional parameters list, also known as
  the lambda declarator. You can omit the parameters list if you want
  a function that takes zero arguments.

 -> returnTypeDeclaration: This is the return type. Most of the time,
    compilers can deduce the return type of the lambda expression when
    you have zero or one return statement. However, if it makes it
    easier to understand the code, you can specify the return
    type. There are some differences among compilers regarding the
    automatic detection of return types when you have more than one
    return statement because the standard doesn't guarantee the
    automatic detection of return types. Notice that the specification
    of the return types is based on the optional return value syntax
    introduced with C++11, which puts the return value after the
    function.

{ lambdaStatements; }: This is the lambda body. The statements within
  the lambda body can access the captured variables and the parameters.



a) definition & call

    auto func = [] () { cout << "Hello world"; }; //lambda-function definition
    func(); // now call the function
  
    auto	  // return type: OPTIONAL
    func =  	  // function-name
    []   	  // the capture specification, 
    		  // tells the compiler we're creating a lambda function. 
    ()      	  // argument list: OPTIONAL
    {... }; 	  // lambda-function code
      
b) inline def & call

   [] () { cout << "Hello world"; };  // def & call


2) Using with STL with multiple arguments

   Use std::bind + std::placeholders  (#include <functional>)


   [ Example
    
     #include <functional>
     #include <iterator>

     vector<int> int_vec {1, 2, 3}
 
     auto sum = [](const int & i1, const int & i2) 
        {std::cout << i1 + i2 << std::endl;};

     for (int loopi=0; loopi<4;++loopi)
     {
	std::for_each(std::begin(int_vect),
		      std::end(int_vect), 
     		      std::bind(sum, loopi, std::placeholders::_1));
     }
   ]
  

3) Variable Capture with Lambdas

   [] 	     Capture nothing (or, a scorched earth strategy?)
   [&] 	     Capture any referenced variable by reference
   [=] 	     Capture any referenced variable by making a copy
   [=, &foo] Capture any referenced variable by making a copy, but
    	     capture variable foo by reference
   [bar]     Capture bar by making a copy; don't copy anything else
   [this]    Capture the this pointer of the enclosing class

   [ Example.- using std::ostream & within a lambda

     std::ostream& operator<<(std::ostream &out, const std::list<int> &value)
     {
	auto last_element = 0; 
    	if(not value.empty())  { last_element = value.back(); }

    	std::for_each(std::begin(value), std::end(value),
    		      [&out, last_element](const int& id)
        {
      	  out << id;
      	  if(not (id==last_element)) { out << " -> "; }
    	});
    
       return out;
     }

     // Results:
     // input: { 1, 66, 3 } ; output:  1 -> 66 -> 3
     // input: {} ; output: 
        
   end example ]

# S.2 New Features in C++14

# S.3 New Features in C++17


# ==============================================================================
# Appendix T - Defined Terms
# ==============================================================================

Note. In the terms defined in this chapter, the quote "this
      International Standard" refers to The C++ standard document ([1_1])


A

- Arithmetic types

  Built -in types representing integral types (boolean, characters, integers),
  and floating-point numbers.


B

- bit-field 

  Class member with a integral type that specifies the number of bits
  to allocate to the member. Bit-fields defined in consecutive order
  in the class are, if possible, compacted into a common integral value.

  # e.g.
  struct { 
    int b:5;  // bit-field of size 5
  }


- (primitive) built-in type

  Type, such as int, defined by the language.
  built-in types = scalar types (3.9.1.3) + void type


- built-in operator

  Operator, such as ( + = .), defined by the language.
  Almost all the built-in operators can be overloaded by the user (13.5)


C

- Class types

  Types defined by the programmer.


- C++ Standards

  Old C++:	C++98, C++03
  Modern C++: 	C++11, C++14, ...


- The "Construct On First Use Idiom" 

Technique used to prevent the static initialization order fiasco. [4_7_6]


- Copy Initialization (copy constructor)

  Initializes an object from another object 

  T object = other;
  T object = {other} ; 	(until C++11)
  f(other)
  return other; 	
  throw object;
  catch (T object)
  T array[N] = {other};


D

- Decay

In a call to a function, during argument deduction, array-to-pointer conversion 
is often called decay. It occurs only if the parameter isn't a reference.


- Dereferencing

The dereference unary operator or indirection operator ("*").  It
operates on a pointer variable, and returns an l-value equivalent to
the value at the pointer address. This is called "dereferencing" the
pointer.

	int x = 10;
	int *p = &i;
	*p = 1; // dereferencing p => equivalent to "x=1"



- Direct Initialization

  Initializes an object from explicit set of constructor arguments.

  T object ( arg );
  T object ( arg1, arg2, ... );
  ...



- dynamic type

<glvalue> type of the most derived object (for pointers and references)
<prvalue> static type of the prvalue expression



E

- extern
 
This keyword tells the compiler that and object (variable, function, ..), 
declared in a header file, is defined somewhere else. So the compiler will 
not write the object definition in any of the object files that include 
the header, then avoiding 'multiple definitions' linkage error. [k3101]

Explanation: 

If several header files define a variable with the same name, and
two or more of them are included by any source files, then
the LINKER will rise a "multiple definition error"

Note.- If only one of the headers is been included, then no error will
be raised, but the program is ill-formed.

Solution: use <<extern>> to declare the variable in all the headers,
	  and define the variable in only one source file.
	  
  [Example] [k3101]

  // file a.h
  int shared_var; // ill-formed: multiple definition (a.h and b.h)
  extern int shared_var; // ok: extern declaration

  // file b.h
  int shared_var; // ill-formed: multiple definition (a.h and b.h)
  extern int shared_var; // ok: extern declaration

  // file a.cpp
  #include "a.h"
  int shared_var; // ok: definition in one and only one source file is required

  // file b.cpp
  #include "b.h"


G

- "generate on demand" policy.

A requirement of the C++ standard. It has two functions:

 1) Efficiency: certain class templates defines hundreds of member
    functions, but normally each program only uses a few of them.

 2) Flexibility: in some cases, not every function defined in a class
    template is supported in the target platform program.
    (i.e. operator<<() functions are only defined for some classes)


I

- ill-formed program

program that is not well-formed (see well-formed program bellow).


M

- manipulator

Object, such as std::endl, that when read or written “manipulates” the
stream itself.


- mutable

Applies to non-static class members of non-reference non-const type
and specifies that the member does not affect the externally visible
state of the class.  Mutable members of const classes are modifiable.


N

- name lookup 

Process by which the use of a name is matched to its declaration.


- The “Named Constructor Idiom”?

Technique that provides more intuitive and/or safer construction
operations for users of your class.

- Narrow character types

Plain char, signed char, and unsigned char are three distinct types,
collectively called narrow character types.


O

- Object

A region of memory that has a type. A variable is an object that has a name.


P

-  POD (Plain Old Data). (3.9.4.1), [4_6_1] [k8503]


Q

-  Qualification

Using the "::" as qualifier. 

  # e.g.
  class B { int i; }
  B::i = 7;  // qualified id 'i'
  i = 7;  // un-qualified id 'i'


  'nns::id' 	   qualified id
  'nns'  	   nested-name-specifier of a qualified-id,


S

- standard library

Collection of types and functions that every C++ compiler must support.


- string literal 

  Sequence of zero or more characters enclosed in double quotes
  i.e. "a string literal"


- Synthesized class methods

Compiler-generated methods automatically (implicitly) defined by the
compiler when the programmer doesn't: default constructor, Copy/Move &
assignment operators.


- The “static initialization order fiasco”?

This the well known problem of initializing two GLOBAL (static)
variables, which exist in separate source files, when one of them
depends on the other to be initialized.


- static type

type of an expression (3.9) resulting from analysis of the program
without considering execution semantics 
[ Note: The static type of an expression depends only on the form of
the program in which the expression appears, and does not change while
the program is executing. —end note ]


T

- type checking 

Term used to describe the process by which the compiler verifies that the way 
objects of a given type are used is consistent with the definition of that type.


U

- undefined behavior

behavior for which this International Standard imposes no requirements
[ Note: Undefined behavior may be expected when this International
Standard omits any explicit definition of behavior or when a program
uses an erroneous construct or erroneous data. Permissible undefined
behavior ranges from ignoring the situation completely with
unpredictable results, to behaving during translation or program
execution in a documented manner characteristic of the environment
(with or without the issuance of a diagnostic message), to terminating
a translation or execution (with the issuance of a diagnostic
message).  Many erroneous program constructs do not engender undefined
behavior; they are required to be diagnosed.  —end note ]


- unspecified behavior

behavior, for a well-formed program construct and correct data, that
depends on the implementation.
[ Note: The implementation is not required to document which behavior
occurs. The range of possible behaviors is usually delineated by this
International Standard. —end note ]


- Unqualified name

A qualified name is one that specifies a scope; i.e. "std::cout"
An unqualified name is one that doesn't; i.e "cout"


W

- well-formed program

C++ program constructed according to the syntax rules, diagnosable semantic 
rules, and the one-definition rule (3.2).
Note.- No compilation errors do not imply well-formed (run-time errors).




# ==============================================================================
# Appendix W - Remarkable Warnings
# ==============================================================================

WARNING_1:
A const variable can be indirectly modified by a pointer, as in the
following example:

	 const int my_age = 32;
	 *(int*)&my_age = 35;

TODO to be confirmed as a test result (gcc file.c) was: core dumped


WARNING_2
Compilers usually DON’T care about the form of header file NAMES, but
IDEs sometimes do. [k2].test_header_suffix.cpp


WARNING_3
Compilers actually DO CARE about the form of source file names:
(e.g.) g++ test_source_suffix 
       test_source_suffix: file not recognized:


WARNING_4
Linkage error "undefined reference to ..."
a) Using gcc instead of g++ compiler.
b) Not providing all the ".gcc" files to the linker
c) Some functions has been declared but not defined.


WARNING_5
public/private/protected are compile-time only.
Once your application gets compiled, private fields sit next to public
fields and there is no protection against modification.

TODO to be confirmed (http://stackoverflow.com/questions/4706788/why-can-i-expose-private-members-when-i-return-a-reference-from-a-public-member)


WARNING_6 
The program is well-formed (compiles) only if there exists (zero or) ONE 
unambiguous implicit conversion sequence from T1 to T2.


WARNING_7
When a template is used as a template argument, the space between the
right two angle brackets is mandatory

      Vector <Vector<char *> > msg_que;


WARNING_8 
(Recommendation) Put inline in Header Files [3_1].6.5.2). Either in
the declaration, or in the definition of template functions.


WARNING_9
As a rule of thumb, we recommend that you ALWAYS qualify any symbol
that is declared in a base that is somehow dependent on a template
parameter with "this->" or with "Base<T>::". If you want to avoid
all uncertainty, you may consider qualifying all member access (in templates)



WARNING_10
Overriding of methods with parameters of polymorphic classes.

1) In overriding, all function parameters MUST be of the same type as
in the base class (example bellow: ParamBase). Overriding does not
accept an inherited type (example bellow: ParamDerived)

[ Example

  class ParamBase{};
  class ParamDerived:: public ParamBase{}

  struct Base
  {
    virtual void f1 (ParamBase *) = 0; 
  };

  struct DerivedGood { void f1 (ParamBase *); // overriding Base::f1()  };

  struct DerivedBad
  {
    /**@warning This is not the method overriding of Base::f1(), but a
       different overloaded function.

       In overriding, all function parameters MUST be of the same type
       as in the base class (here: ParamBase). Overriding does not
       accept an inherited type (here: ParamDerived)
    */
    void f1 (ParamDerived *);

    // correct overriding of Base::f1() here
   // void f1 (ParamBase *);
  };

  main()
  {
   DerivedBad var1; // error: cannot declare variable ‘var1’ to be of
  		    // abstract type ‘DerivedBad’
                    // abstract => DerivedBad miss some overriding

   DerivedGood var2;  // ok
  }

end example ]


# ==============================================================================
# Appendix X - C++ techniques
# ==============================================================================

# X.1 Erase-remove idiom [4_14_1]  [k2501]

The erase–remove idiom is a common C++ technique to eliminate elements
that fulfill a certain criterion from a C++ Standard Library container

1) Motivation

"... erase can be used to delete an element from a collection, but for
containers which are based on an array, such as vector, all elements
after the deleted element have to be moved forward, ..."

2) Limitation

The erase–remove idiom cannot be used for containers that return
const_iterator (e.g.: set) [4_14_2]


# ==============================================================================
# Appendix Y - Non-C++ concepts
# ==============================================================================

# Y.1 Memory address  [7_1]

a) byte & memory location: C++ concepts (1.7.1)

b) Word (processor concept)

  A word is the natural unit (fixed-size) of data used by a particular
  processor design (register size)

  Most common word sizes are 8, 16, 32 and 64 bits, but other are possible.

c) address size (processor concept)

   - address size = number of memory locations.  

   - total memory available = 2 exp address-size

   - For a computer, the address size can be equal, larger or smaller
     than the word size.

   - If equal, one memory address to be efficiently stored in one word    
     e.g. 32-bit computer can address 2**32 = 4GB   



# ==============================================================================
# Appendix Z - References
# ==============================================================================


# ------------------------------------------------------------------------------

[1] C++ documents

[1_1] The C++ standard - https://isocpp.org/std/the-standard

      Current standard working draft -
      	      "./doc_references/the_standard/current_standard/*.pdf"


[1_2] Resource index (compilers, books, ...) - https://isocpp.org/get-started

# ------------------------------------------------------------------------------

[2] tools (compilers, debuggers, ...)

[2_1] gcc - https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html

[2_2] gimple: static analysis of C++ - http://www.gimpel.com/html/index.htm

[2_3] gdb guide - http://www.delorie.com/gnu/docs/gdb/gdb_toc.html#SEC_Contents

# ------------------------------------------------------------------------------

[3] books


    Level 1

[3_1] primer - C++ Primer, 5th Edition.pdf
      	       http://www.informit.com/title/032174113 (examples source code)
	       WARNING: page number divergence book/pdf: pdf_page# ~= book#


    Level 2

[3_101] modern - Effective Modern C++.pdf

[3_102] templates- C++ Templates, The Complete Guide



    C++11 C++14 (see [1_2])

[3_201] What’s new” in 10 minutes

[3_202] What’s new” in depth - 



    Reference books

[4_301] The C++ Programming Language

[4_302] The C++ Standard Library: A Tutorial and Reference


# ------------------------------------------------------------------------------

[4] C++ Concepts


[4_1] name mangling - http://stackoverflow.com/questions/1068129/c-library-not-linking-using-gcc-g


[4_2] C++ references

      [4_2_0] References at the C++ standard doc. - [1_1].8.5.3
      
      [4_2_1] ISO C++ faq - https://isocpp.org/wiki/faq/references  (*)

      [4_2_2] The difference between “pass by reference” in C and in C++? -
	http://stackoverflow.com/questions/13654138/what-exactly-is-the-difference-between-pass-by-reference-in-c-and-in-c/13654139#13654139

      [4_2_3] wikipedia - https://en.wikipedia.org/wiki/Reference_%28C%2B%2B%29

      [4_2_4] dangers of references as data members - http://stackoverflow.com/questions/892133/should-i-prefer-pointers-or-references-in-member-data


[4_3] C++ pointers

      [4_3_1] Pointers to members - see [4_8_1] 



[4_4] Reference and Value Semantics

      [4_4_1] Reference and Value Semantics - https://isocpp.org/wiki/faq/value-vs-ref-semantics  (*)



[4_5] Initialization

      [4_5_1] New C++11 Initialization Forms - http://www.informit.com/articles/article.aspx?p=1852519

      [4_5_2] std::initializer_list - http://en.cppreference.com/w/cpp/utility/initializer_list


[4_6] Aggregates, PODs, TrivialType, and StandardLayoutType

      [4_6_1] C++ concepts: PODType - http://en.cppreference.com/w/cpp/concept/PODType

      [4_6_2] Passive data structure @ wikipedia - https://en.wikipedia.org/wiki/Passive_data_structure

      [4_6_3] What are Aggregates and PODs - http://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special (*)

      [4_6_4] Aggregate Classes  - [3_1] 7.5.5, p. 387
      
      [4_6_5] Aggregate initialization - http://en.cppreference.com/w/cpp/language/aggregate_initialization  (*)

      [4_6_6] StandardLayoutType - http://en.cppreference.com/w/cpp/concept/StandardLayoutType  (*)



[4_7] Constructors

      [4_7_1] Informit Constructors -
      http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=15

      [4_7_2] Informit Constructors FAQ- http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=364

      [4_7_3] Multiple Inheritance: Construction and Destruction Order - http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=169

      [4_7_4] Synthesized Default Constructor at Primer - [3_1] 7.1.4 (p. 342)

      [4_7_5] Implicit Class-Type Conversions - [3_1] 7.5.4. (p 382)

      [4_7_6] ISO ctors. FAQ - https://isocpp.org/wiki/faq/ctors  (*)

      [4_7_7] constructor's initialization order - [1_1], 12.6.2, paragraph 13

      [4_7_8] ctor. order of member functions - [1_1], 12.6.2
      	      Initializing bases and members, paragraph 16

      [4_7_9] direct initialization -
      	      http://en.cppreference.com/w/cpp/language/direct_initialization

      [4_7_10] copy initialization -
      	       http://en.cppreference.com/w/cpp/language/copy_initialization

      [4_7_11] converting constructor -
      	      http://en.cppreference.com/w/cpp/language/converting_constructor


[4_8] Copying and moving class objects

      [4_8_1] Bitcopy versus initialization - http://www.drbio.cornell.edu/pl47/programming/TICPP-2nd-ed-Vol-one-html/Chapter11.html


      [4_8_2] Move semantics and rvalue references in C++11 - https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html


[4_9] destructors

      [4_9_1] ISO dtors. FAQ - https://isocpp.org/wiki/faq/dtors  (*)



[4_10] multiple inheritance (virtual inheritance)

      [4_10_1] what is a virtual base class? - http://stackoverflow.com/questions/21558/in-c-what-is-a-virtual-base-class

      [4_10_2] ISO C++  Inheritance — Multiple and Virtual Inheritance - https://isocpp.org/wiki/faq/multiple-inheritance

      [4_10_3] Virtual inheritance @ Wikipedia - https://en.wikipedia.org/wiki/Virtual_inheritance

      [4_10_4] Multiple Inheritance: Construction and Destruction Order - http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=169

      code example: [1_1] 12.6.2. 14
      code example: [1_1] 12.7. 4


[4_11] Virtual functions

      [4_11_1] ISO FAQ - https://isocpp.org/wiki/faq/virtual-functions  (*)

      [4_11_2] v-table & v-pointer implementation & use -               (*)
      	       https://isocpp.org/wiki/faq/virtual-functions#dyn-binding 
	       https://isocpp.org/wiki/faq/virtual-functions#dyn-binding2


[4_12] Conversions

      [4_12_1] Explicit Conversions -
      	       http://en.cppreference.com/w/cpp/language/explicit_cast

      [4_12_2] Implicit Conversions -
      	       http://en.cppreference.com/w/cpp/language/implicit_conversion
	       
      [4_12_3] user-defined conversion -
               http://en.cppreference.com/w/cpp/language/cast_operator


[4_13] Expressions
 
  [4_13_1] What type of cast to use - https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used


[4_14] Libray Algorithms

[4_14_1] Erase-remove idiom - https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom

[4_14_2] Erase-remove idiom with set- https://stackoverflow.com/questions/3792600/erase-remove-idiom-with-stdset-failing-with-constness-related-error


[4_100] Containers

  [4_100_1] ISO containers FAQ - https://isocpp.org/wiki/faq/containers (*)

  	    FACT Arrays are evil !!

[4_111] Memory Management

  [4_111_1] ISO Containers FAQ - https://isocpp.org/wiki/faq/freestore-mgmt (*)

# ------------------------------------------------------------------------------

[5] Teacher index

[5_1] Joseph Mansfield - http://stackoverflow.com/users/150634/joseph-mansfield

# ------------------------------------------------------------------------------

[6] C++ compilation model

[6_1] compiler - linker options   (*)

  [6_1_1] debug options -
  	  https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html

  [6_1_2] optimize options -
  	  https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html

  [6_1_3] warning options -
  https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html

  [6_1_4] link options - https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html

[6_2] Instantiation units - http://stackoverflow.com/questions/19971744/whats-the-meaning-of-instantiation-unit-in-c11-standard

[6_3] Single Compilation Unit (SCU) -
      https://en.wikipedia.org/wiki/Single_Compilation_Unit

[6_4] static (vs shared) libaries - https://www.geeksforgeeks.org/static-vs-dynamic-libraries/

# ------------------------------------------------------------------------------

[7] Non-C++ concepts

[7_1] Memory_address - https://en.wikipedia.org/wiki/Memory_address

# ------------------------------------------------------------------------------

[8] C++11 and after 

[8_1] std::ref - https://genbattle.bitbucket.io/blog/2016/05/29/Passing-References-to-Deferred-Function-Calls-with-std-ref/

[8_2] std::ref vs C++ referencex - http://stackoverflow.com/questions/33240993/c-difference-between-stdreft-and-t

# ------------------------------------------------------------------------------

[9] STL

https://www.geeksforgeeks.org/

https://www.geeksforgeeks.org/

[std::unordered_map] - https://www.geeksforgeeks.org/unordered_map-in-stl-and-its-applications/

# ------------------------------------------------------------------------------

# (*) local copy exists at ./doc_references


# ==============================================================================


